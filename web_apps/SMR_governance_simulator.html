<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nuclear Governance Loops — Accountability Vectors</title>
<style>
  :root { --w: 980px; --h: 560px; --pad: 10px; --r: 20px; --edge: 1.5px; --font: 13px; }
  body { font-family: system-ui, sans-serif; margin: 0; background: #fafafa; color: #111; }
  header, footer { padding: 10px 14px; background:#fff; border-bottom:1px solid #eee; }
  footer{border-top:1px solid #eee; border-bottom:none}
  .wrap { max-width: 1100px; margin: 0 auto; }
  .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .toolbar button { padding:6px 10px; border:1px solid #ddd; background:#fff; border-radius:6px; cursor:pointer; }
  .toolbar button:active { transform: translateY(1px); }
  .mini { font-size: 12px; color:#444; }
  .grid { display:grid; grid-template-columns: 320px 1fr; gap:12px; padding:10px; }
  .panel { background:#fff; border:1px solid #eee; border-radius:10px; padding:10px; }
  .panel h3 { margin:4px 0 8px; font-size: 15px;}
  #canvas { width: var(--w); height: var(--h); border:1px solid #eee; border-radius:10px; background:#fff;}
  .kv { display:grid; grid-template-columns: 1fr auto; gap:6px; font-size:13px; }
  .kv code { background:#f4f4f4; padding:2px 6px; border-radius:6px; }
  .legend { display:flex; gap:10px; align-items:center; font-size:12px; color:#333; }
  .dot { width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid #ccc;}
  .dot.src { background:#e6f3ff; }
  .dot.av { background:#ffe; }
  .edgepos { width:14px; height:2px; display:inline-block; background:#3c8; }
  .edgeneg { width:14px; height:2px; display:inline-block; background:#c44; }
  details { border-top:1px dashed #eee; padding-top:8px; margin-top:8px; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="toolbar">
      <button id="stepBtn">Step (Δt = 1)</button>
      <button id="autorunBtn">Autorun</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
      <span class="mini">Tick: <span id="tick">0</span></span>
      <span class="mini">Spectral radius: <span id="rho">—</span></span>
      <span class="mini">Max |state|: <span id="maxs">—</span></span>
    </div>
  </div>
</header>

<div class="wrap grid">
  <div class="panel">
    <h3>Explainers</h3>
    <div class="legend">
      <span class="dot src"></span> core node
      <span class="dot av"></span> accountability vector (explainer node)
      <span class="edgepos"></span> reinforcing (+)
      <span class="edgeneg"></span> balancing (–)
    </div>

    <details open>
      <summary><b>What’s an accountability vector?</b></summary>
      <p style="font-size:13px; line-height:1.35;">
        Each feedback link A→B is split into two: A→AV(A→B)→B. The middle “AV” node is an explainer that records
        <i>who</i> is accountable for the effect, the sign (+/–), and the current contribution (magnitude). This keeps system
        fidelity while making loops legible to non‑technical stakeholders.
      </p>
      <div class="kv"><div>Formula</div><code>AV = gain·A; B ← B + AV</code></div>
      <div class="kv"><div>Sign</div><code>gain &gt; 0 ⇒ reinforcing; gain &lt; 0 ⇒ balancing</code></div>
    </details>

    <details>
      <summary><b>How the Step integrator works</b></summary>
      <p class="mini">Discrete‑time linear update: <code>x(t+1) = Wx(t)</code> on the core nodes; AV nodes mirror edge flows.</p>
      <div class="kv"><div>Stability cue</div><code>ρ(W) &lt; 1 ⇒ decays; ρ(W) ≈ 1 ⇒ marginal; ρ(W) &gt; 1 ⇒ grows/oscillates</code></div>
    </details>

    <details>
      <summary><b>Try a policy nudge</b></summary>
      <p class="mini">Click an edge’s gain to edit. Step to see how accountability vectors light up and where oscillations arise.</p>
    </details>

    <details>
      <summary><b>Graphviz (static report)</b></summary>
      <pre class="mini" style="white-space:pre-wrap">digraph GovernanceLoops {
  rankdir=LR;
  node [shape=ellipse, style=filled, fillcolor="#e6f3ff", color="#9cc4ef", fontname="Helvetica"];
  Reg [label="Regulator"];
  Op  [label="Operator"];
  Ov  [label="Oversight"];

  node [shape=circle, style=filled, fillcolor="#ffffe6", color="#e6e0a3"];
  AV_e1 [label="AV(Reg→Op)\nLicence conditions"];
  AV_e2 [label="AV(Op→Reg)\nIncident reports"];
  AV_e3 [label="AV(Ov→Reg)\nParliamentary pressure"];
  AV_e4 [label="AV(Op→Ov)\nTransparency metrics"];

  edge [color="#3c8", penwidth=2];
  Reg -> AV_e1 -> Op [label="+0.35"];
  Ov  -> AV_e3 -> Reg [label="+0.20"];
  Op  -> AV_e4 -> Ov  [label="+0.30"];

  edge [color="#c44", penwidth=2];
  Op  -> AV_e2 -> Reg [label="-0.25"];
}
</pre>
      <div class="mini">Full .dot file: <code>web_apps/SMR_governance_simulator_av.dot</code></div>
    </details>
  </div>

  <div class="panel">
    <h3>Simulator</h3>
    <canvas id="canvas" width="980" height="560"></canvas>
  </div>
</div>

<footer>
  <div class="wrap mini">
    Default demo: <i>Regulator ↔ Operator ↔ Oversight</i> with one reinforcing and one balancing loop.
  </div>
</footer>

<script>
/* --------------------------
   Minimal graph + stepper
---------------------------*/
const $ = (id)=>document.getElementById(id);
const W = 980, H = 560;
const ctx = $("canvas").getContext("2d");

let tick = 0;
let autorun = null;

/* Core nodes (domain concepts) */
const nodes = [
  { id:"Reg",  label:"Regulator", x: 200, y: 160, state: 1.0 },
  { id:"Op",   label:"Operator",  x: 490, y: 280, state: 0.2 },
  { id:"Ov",   label:"Oversight", x: 780, y: 160, state: 0.0 },
];

/* Edges (A→B, gain) that will get an AV explainer node each */
let edges = [
  { id:"e1", from:"Reg", to:"Op", gain: +0.35, who:"Licence conditions" },
  { id:"e2", from:"Op",  to:"Reg", gain: -0.25, who:"Incident reports" },
  { id:"e3", from:"Ov",  to:"Reg", gain: +0.20, who:"Parliamentary pressure" },
  { id:"e4", from:"Op",  to:"Ov",  gain: +0.30, who:"Transparency metrics" },
];

/* Build accountability vectors as explainer nodes for each edge */
const avNodes = []; // {id, label, src, dst, x,y, contrib}
function buildAVs(){
  avNodes.length = 0;
  edges.forEach((e)=>{
    const a = nodeById(e.from), b = nodeById(e.to);
    const midx = (a.x + b.x)/2, midy = (a.y + b.y)/2;
    avNodes.push({
      id: "AV_"+e.id,
      label: `AV(${a.label}→${b.label})`,
      src: e.from, dst: e.to, gain: e.gain, who: e.who,
      x: midx + (e.gain>0? 0: -14), y: midy + (e.gain>0? -16: +16),
      contrib: 0
    });
  });
}
buildAVs();

function nodeById(id){ return nodes.find(n=>n.id===id) || avNodes.find(n=>n.id===id); }

/* Compute W matrix over core nodes only (order = nodes[]) */
function weightMatrix(){
  const n = nodes.length;
  const M = Array.from({length:n}, ()=>Array(n).fill(0));
  edges.forEach(e=>{
    const i = nodes.findIndex(n=>n.id===e.to);
    const j = nodes.findIndex(n=>n.id===e.from);
    if(i>=0 && j>=0) M[i][j] += e.gain;
  });
  return M;
}

/* Spectral radius (power iteration, few steps) */
function spectralRadius(M){
  const n = M.length; if(n===0) return 0;
  let v = Array(n).fill(0).map((_,i)=> i===0?1:0);
  const iters = 10;
  for(let k=0;k<iters;k++){
    const w = new Array(n).fill(0);
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++) w[i]+=M[i][j]*v[j];
    }
    const norm = Math.max(...w.map(Math.abs)) || 1e-9;
    v = w.map(x=>x/norm);
  }
  // Rayleigh quotient approx
  let num=0, den=0;
  for(let i=0;i<n;i++){
    let mvi=0; for(let j=0;j<n;j++) mvi+=M[i][j]*v[j];
    num += v[i]*mvi; den += v[i]*v[i];
  }
  return Math.abs(num/(den||1));
}

/* Step integrator: x←W x; AVs mirror edge flows */
function step(){
  const M = weightMatrix();
  // AV contributions
  edges.forEach(e=>{
    const src = nodeById(e.from);
    const av  = avNodes.find(a=>a.src===e.from && a.dst===e.to);
    av.contrib = e.gain * src.state;
  });
  // Core update
  const x = nodes.map(n=>n.state);
  const xnext = x.map(()=>0);
  for(let i=0;i<M.length;i++){
    for(let j=0;j<M.length;j++){
      xnext[i]+= M[i][j]*x[j];
    }
  }
  nodes.forEach((n,i)=> n.state = xnext[i] );
  tick++;
  updateHUD();
  draw();
}

function reset(){
  tick=0;
  nodes.forEach(n=> n.state = (n.id==="Reg"?1.0:(n.id==="Op"?0.2:0.0)));
  avNodes.forEach(a=> a.contrib=0);
  updateHUD();
  draw();
}

/* UI — autorun/pause */
$("stepBtn").onclick = step;
$("resetBtn").onclick = reset;
$("autorunBtn").onclick = ()=>{
  if(autorun) return;
  autorun = setInterval(step, 500);
};
$("pauseBtn").onclick = ()=>{ clearInterval(autorun); autorun = null; };

/* Editing gains by clicking near edge labels */
$("canvas").addEventListener("click", (ev)=>{
  const rect = ev.target.getBoundingClientRect();
  const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
  // Find nearest AV label
  let best=null, d2=99999;
  avNodes.forEach(a=>{
    const dx=a.x-mx, dy=a.y-my; const dd=dx*dx+dy*dy;
    if(dd<d2){d2=dd; best=a;}
  });
  if(best && d2<900){ // within 30px
    const e = edges.find(e=> e.from===best.src && e.to===best.dst);
    const val = prompt(`Edit gain for ${best.label}\nWho: ${e.who}\nCurrent: ${e.gain.toFixed(2)}\n(positive=reinforcing, negative=balancing)`, e.gain.toFixed(2));
    if(val!==null){
      const g = parseFloat(val);
      if(!Number.isNaN(g)){ e.gain = g; buildAVs(); draw(); updateHUD(); }
    }
  }
});

/* HUD */
function updateHUD(){
  const M = weightMatrix();
  const rho = spectralRadius(M);
  $("rho").textContent = rho.toFixed(3);
  $("tick").textContent = tick;
  $("maxs").textContent = nodes.reduce((m,n)=>Math.max(m,Math.abs(n.state)),0).toFixed(3);
}

/* Draw */
function draw(){
  ctx.clearRect(0,0,W,H);
  // Edges (core→core) with sign color
  edges.forEach(e=>{
    const a = nodeById(e.from), b = nodeById(e.to);
    const s = e.gain>=0? "#3c8" : "#c44";
    ctx.lineWidth = Math.max(0.8, Math.min(4, 1 + Math.abs(e.gain)*3));
    ctx.strokeStyle = s;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    // gain label (clickable hint via AV node position)
    ctx.fillStyle = "#333";
    ctx.font = "12px system-ui";
    const midx=(a.x+b.x)/2, midy=(a.y+b.y)/2;
    ctx.fillText(`g=${e.gain.toFixed(2)}`, midx+6, midy-6);
  });

  // Core nodes
  nodes.forEach(n=>{
    ctx.fillStyle = "#e6f3ff";
    ctx.strokeStyle = "#9cc4ef";
    ctx.lineWidth = 1.2;
    circle(n.x,n.y,22);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle="#0b3d6b";
    ctx.font="13px system-ui";
    ctx.textAlign="center";
    ctx.fillText(n.label, n.x, n.y-28);
    ctx.fillStyle="#222";
    ctx.font="12px system-ui";
    ctx.fillText(n.state.toFixed(2), n.x, n.y+4);
  });

  // AV nodes (explainer nodes on edges)
  avNodes.forEach(a=>{
    ctx.fillStyle = "#ffffe6";
    ctx.strokeStyle = "#e6e0a3";
    circle(a.x, a.y, 14);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle="#665c00";
    ctx.font="11px system-ui";
    ctx.textAlign="center";
    ctx.fillText("AV", a.x, a.y+4);
    // tiny label with current contribution
    ctx.fillStyle="#333";
    ctx.font="11px system-ui";
    ctx.textAlign="left";
    ctx.fillText(`${a.contrib>=0?"+":""}${a.contrib.toFixed(2)}`, a.x+16, a.y+4);
  });
}

function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); }

/* Init */
reset();
draw();
updateHUD();
</script>
</body>
</html>
