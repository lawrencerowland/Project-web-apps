<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interface Maturity Simulator (SharpCloud-style, standalone)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --ink:#e8ecff;
      --muted:#b9c1ffcc;
      --line:#263257;
      --accent:#7aa2ff;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --good:#6bffb0;
      --shadow: 0 10px 24px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 20% 10%, #1a2550 0%, #0b1020 45%, #070a14 100%);
      color:var(--ink);
      font-family: var(--sans);
      overflow:hidden;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:14px 18px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(17,26,51,.9), rgba(17,26,51,.65));
      backdrop-filter: blur(8px);
      position:sticky;
      top:0;
      z-index:5;
    }
    .title{
      display:flex;
      gap:12px;
      align-items:baseline;
      flex-wrap:wrap;
    }
    .title h1{
      font-size:16px;
      margin:0;
      letter-spacing:.2px;
      font-weight:700;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(15,23,48,.7);
      font-size:12px;
      color: var(--muted);
    }
    .pill b{color:var(--ink); font-weight:700;}
    .wrap{
      height: calc(100% - 58px);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      padding:14px;
      box-sizing:border-box;
    }
    .panel{
      background: rgba(17,26,51,.68);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .panel .hd{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: rgba(15,23,48,.65);
    }
    .panel .hd h2{
      margin:0;
      font-size:13px;
      letter-spacing:.2px;
      font-weight:700;
    }
    .panel .bd{
      padding:12px;
      overflow:auto;
      min-height:0;
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:10px 0 6px;
    }
    select,input,button,textarea{
      font-family:inherit;
      color:var(--ink);
    }
    select,input[type="number"],input[type="text"],textarea{
      width:100%;
      box-sizing:border-box;
      background: rgba(9,13,28,.65);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 10px;
      outline:none;
      font-size:13px;
    }
    input[type="range"]{width:100%}
    textarea{
      min-height:140px;
      font-family: var(--mono);
      font-size:12px;
      line-height:1.35;
      white-space:pre;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button{
      border:1px solid var(--line);
      border-radius:12px;
      background: rgba(122,162,255,.18);
      padding:10px 11px;
      cursor:pointer;
      font-size:13px;
      font-weight:650;
      transition: transform .06s ease, background .15s ease;
    }
    button:hover{ background: rgba(122,162,255,.26); }
    button:active{ transform: translateY(1px); }
    button.secondary{ background: rgba(185,193,255,.12); }
    button.danger{ background: rgba(255,107,107,.15); }
    button.danger:hover{ background: rgba(255,107,107,.23); }
    button.good{ background: rgba(107,255,176,.14); }
    button.good:hover{ background: rgba(107,255,176,.20); }
    button.info{
      cursor: default;
      text-align: left;
      width: 100%;
      line-height: 1.35;
      background: rgba(15,23,48,.7);
      white-space: pre-wrap;
    }
    button.info:hover{ background: rgba(15,23,48,.7); }
    .hint{
      font-size:12px;
      color: var(--muted);
      line-height:1.35;
      margin-top:10px;
    }
    .kbd{
      font-family: var(--mono);
      font-size:11px;
      padding:2px 6px;
      border:1px solid var(--line);
      border-radius:8px;
      background: rgba(9,13,28,.65);
      color: var(--ink);
    }

    /* Right side */
    .tabs{
      display:flex;
      gap:8px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: rgba(15,23,48,.65);
      flex-wrap:wrap;
    }
    .tab{
      font-size:12px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(9,13,28,.45);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      background: rgba(122,162,255,.22);
      color: var(--ink);
      border-color: rgba(122,162,255,.55);
    }
    .view{
      display:none;
      padding:12px;
      overflow:auto;
      min-height:0;
      height:100%;
      box-sizing:border-box;
    }
    .view.active{ display:block; }

    /* Matrix */
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      font-size:12px;
      min-width:880px;
    }
    th,td{
      border-right:1px solid var(--line);
      border-bottom:1px solid var(--line);
      padding:8px 8px;
      vertical-align:middle;
    }
    th{
      position:sticky;
      top:0;
      z-index:2;
      background: rgba(15,23,48,.95);
      text-align:left;
      font-weight:750;
      letter-spacing:.2px;
    }
    th:first-child, td:first-child{
      position:sticky;
      left:0;
      z-index:1;
      background: rgba(15,23,48,.95);
      min-width:260px;
    }
    th:first-child{ z-index:3; }
    tr:first-child th{
      border-top:1px solid var(--line);
    }
    td:first-child{ border-left:1px solid var(--line); }
    th:first-child{ border-left:1px solid var(--line); }
    td{
      background: rgba(9,13,28,.35);
    }
    .ifaceName{
      font-weight:800;
      font-size:12.5px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .metaSmall{
      margin-top:4px;
      color: var(--muted);
      font-size:11px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .sparkWrap{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:6px;
    }
    .sparkLbl{
      font-size:11px;
      color: var(--muted);
      width:56px;
    }
    .spark{
      width:110px;
      height:22px;
      border:1px solid var(--line);
      border-radius:8px;
      background: rgba(9,13,28,.55);
    }
    .cell{
      cursor:pointer;
      border-left:1px solid var(--line);
      border-top:1px solid var(--line);
      border-right:1px solid var(--line);
      border-bottom:1px solid var(--line);
      border-radius:10px;
      padding:8px 8px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      user-select:none;
      transition: transform .06s ease, outline .15s ease;
      outline: 0px solid rgba(122,162,255,.0);
    }
    .cell:hover{
      transform: translateY(-1px);
      outline: 2px solid rgba(122,162,255,.25);
    }
    .cell.selected{
      outline: 3px solid rgba(122,162,255,.55);
    }
    .cellVal{
      font-weight:900;
      font-size:13px;
    }
    .cellDelta{
      font-family: var(--mono);
      font-size:11px;
      opacity:.95;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(9,13,28,.28);
      color: var(--ink);
      white-space:nowrap;
    }
    .deltaPos{ border-color: rgba(107,255,176,.35); color: rgba(180,255,220,.95); }
    .deltaNeg{ border-color: rgba(255,107,107,.35); color: rgba(255,196,196,.95); }
    .deltaZero{ border-color: rgba(185,193,255,.25); color: rgba(185,193,255,.9); }

    /* Dashboard */
    .kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(180px,1fr));
      gap:10px;
      margin-bottom:12px;
    }
    .kpi{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(9,13,28,.35);
      padding:10px 12px;
    }
    .kpi .k{
      font-size:11px;
      color: var(--muted);
    }
    .kpi .v{
      font-size:18px;
      font-weight:900;
      margin-top:4px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:12px;
      align-items:stretch;
    }
    .card{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(9,13,28,.35);
      padding:12px;
      overflow:auto;
      min-height:0;
    }
    .card h3{
      margin:0 0 10px;
      font-size:12px;
      letter-spacing:.2px;
    }
    canvas{
      max-width:100%;
    }

    /* Network */
    .netWrap{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      align-items:stretch;
    }
    .netStage{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(9,13,28,.35);
      overflow:hidden;
      position:relative;
      min-height:520px;
    }
    .tooltip{
      position:absolute;
      pointer-events:none;
      padding:10px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background: rgba(15,23,48,.92);
      box-shadow: var(--shadow);
      font-size:12px;
      color: var(--ink);
      min-width:220px;
      display:none;
      z-index:10;
    }
    .tooltip .t{
      font-weight:900;
      margin-bottom:6px;
    }
    .tooltip .r{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-family: var(--mono);
      font-size:11px;
      color: var(--muted);
      margin:2px 0;
    }

    /* Log */
    .log{
      font-family: var(--mono);
      font-size:11.5px;
      line-height:1.35;
      white-space:pre-wrap;
      background: rgba(9,13,28,.35);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 10px;
      min-height:180px;
      max-height:280px;
      overflow:auto;
    }
    .divider{
      height:1px;
      background: var(--line);
      margin:12px 0;
    }
    .small{
      font-size:11px;
      color: var(--muted);
      line-height:1.35;
    }

    /* Small screens */
    @media (max-width: 1050px){
      body{ overflow:auto; }
      .wrap{ height:auto; grid-template-columns: 1fr; }
      .netWrap{ grid-template-columns: 1fr; }
      table{ min-width: 740px; }
      .kpis{ grid-template-columns: repeat(2, minmax(160px,1fr)); }
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <h1>Interface Maturity Simulator</h1>
    <span class="pill">Step <b id="stepPill">0</b></span>
    <span class="pill">Selected: <b id="selPill">—</b></span>
  </div>
  <div class="title">
    <span class="pill">Local iterations <b id="iterPill">4</b></span>
    <span class="pill">Spillover <b id="spillPill">0.15 / 0.05</b></span>
    <span class="pill">Friction cap <b id="fricPill">A&gt;70 → +Δ×0.5</b></span>
  </div>
</header>

<div class="wrap">

  <!-- LEFT: Controls & Log -->
  <section class="panel" aria-label="Controls panel">
    <div class="hd">
      <h2>Controls</h2>
      <div class="pill" title="Tip: click a matrix cell to prefill">
        Tip: <span class="kbd">Click</span> a cell
      </div>
    </div>
    <div class="bd" id="controls">

      <label for="ifaceSel">Interface</label>
      <select id="ifaceSel"></select>

      <label for="varSel">Variable</label>
      <select id="varSel"></select>

      <div class="row">
        <div>
          <label for="modeSel">Mode</label>
          <select id="modeSel">
            <option value="delta">Apply Δ (nudge)</option>
            <option value="set">Set absolute value</option>
          </select>
        </div>
        <div>
          <label for="deltaNum">Δ / Value</label>
          <input id="deltaNum" type="number" step="1" value="10" />
        </div>
      </div>

      <label for="deltaRange">Quick slider</label>
      <input id="deltaRange" type="range" min="-30" max="30" step="1" value="10" />

      <div class="btns">
        <button id="applyBtn" class="good">Apply</button>
        <button id="undoBtn" class="secondary">Undo</button>
        <button id="resetBtn" class="danger">Reset</button>
      </div>

      <div class="divider"></div>

      <label for="scenarioSel">Scenario nudge (exogenous bulk change)</label>
      <select id="scenarioSel">
        <option value="">— choose —</option>
        <option value="early_warning">Early-warning culture: +10 Escalation readiness (all)</option>
        <option value="contract_misalign">Contract misalign: −15 Shared incentives (all)</option>
        <option value="clarify_scope">Clarify scope: −12 Ambiguity (all)</option>
        <option value="deadline_pressure">Deadline pressure: +12 Ambiguity & −8 Trust (PM↔Client)</option>
      </select>
      <div class="btns">
        <button id="scenarioBtn" class="secondary">Apply scenario</button>
      </div>

      <div class="divider"></div>

      <details>
        <summary style="cursor:pointer; font-weight:800; color:var(--ink);">Model knobs (editable)</summary>

        <div class="row">
          <div>
            <label for="iterRange">Local coupling iterations</label>
            <input id="iterRange" type="range" min="1" max="10" step="1" value="4" />
          </div>
          <div>
            <label for="iterNum">Iterations</label>
            <input id="iterNum" type="number" min="1" max="10" step="1" value="4" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="spillStrong">Spillover (shared party)</label>
            <input id="spillStrong" type="number" step="0.01" value="0.15" />
          </div>
          <div>
            <label for="spillWeak">Spillover (no shared party)</label>
            <input id="spillWeak" type="number" step="0.01" value="0.05" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="fricThresh">Friction cap threshold (Ambiguity &gt;)</label>
            <input id="fricThresh" type="number" step="1" value="70" />
          </div>
          <div>
            <label for="fricFactor">Positive Δ factor when capped</label>
            <input id="fricFactor" type="number" step="0.05" value="0.5" />
          </div>
        </div>

        <div class="row3">
          <div>
            <label for="svEsc">Safety valve: Escalation &lt;</label>
            <input id="svEsc" type="number" step="1" value="30" />
          </div>
          <div>
            <label for="svAmb">Safety valve: Ambiguity &gt;</label>
            <input id="svAmb" type="number" step="1" value="60" />
          </div>
          <div>
            <label for="svPen">Penalty (−Trust/−Adapt)</label>
            <input id="svPen" type="number" step="1" value="5" />
          </div>
        </div>

        <div class="divider"></div>
        <div class="small">
          Local coupling edges (editable):<br/>
          <span class="kbd">Ambiguity → Trust</span>, <span class="kbd">Ambiguity → Escalation</span>, <span class="kbd">Trust → Adaptability</span>, <span class="kbd">Trust → Incentives</span>, <span class="kbd">Incentives → Ambiguity</span>
        </div>
        <div class="row3">
          <div>
            <label for="c_am_t">Ambiguity → Trust</label>
            <input id="c_am_t" type="number" step="0.05" value="-0.6" />
          </div>
          <div>
            <label for="c_am_e">Ambiguity → Escalation</label>
            <input id="c_am_e" type="number" step="0.05" value="0.3" />
          </div>
          <div>
            <label for="c_t_ad">Trust → Adaptability</label>
            <input id="c_t_ad" type="number" step="0.05" value="0.5" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="c_t_s">Trust → Shared incentives</label>
            <input id="c_t_s" type="number" step="0.05" value="0.5" />
          </div>
          <div>
            <label for="c_s_am">Incentives → Ambiguity</label>
            <input id="c_s_am" type="number" step="0.05" value="-0.4" />
          </div>
        </div>

        <div class="btns">
          <button id="applyKnobsBtn" class="secondary">Apply knobs</button>
        </div>
      </details>

      <div class="divider"></div>

      <div class="panel" style="border-radius:14px; box-shadow:none; border:1px solid var(--line); background: rgba(9,13,28,.20);">
        <div class="hd" style="border-bottom:1px solid var(--line); background: rgba(15,23,48,.40);">
          <h2>Last action log</h2>
          <span class="pill"><span class="kbd">Undo</span> is stateful</span>
        </div>
        <div class="bd">
          <div id="log" class="log">Ready.</div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="btns" style="flex-direction:column; align-items:stretch;">
        <button type="button" class="info">
          <strong>Features:</strong>
          Renders a 5×5 “SharpCloud‑style” attribute matrix (rows = interfaces, columns = variables)
          Lets you nudge any cell by Δ (or set an absolute value)
          Applies local coupling (iterated ripple), network spillover, friction cap, safety valve
          Shows logs, KPIs, sparklines, and a network view
          Includes a “SharpCloud Mapping” export pack (JSON + CSV) that is independent of any SharpCloud instance, but mirrors how you’d model it there
        </button>
        <button type="button" class="info">
          <strong>What you can do:</strong>
          Click a cell like PM↔Client → Shared incentives, apply Δ +15
          Watch:
          Local coupling ripple (Trust/Adaptability move, Ambiguity shifts via Incentives→Ambiguity)
          Spillover to interfaces sharing PM or Client
          Friction cap when Ambiguity &gt; 70 (positive deltas damped)
          Safety valve when Escalation is low and Ambiguity high
        </button>
      </div>

      <div class="hint">
        The matrix is a <strong>SharpCloud-like</strong> representation:
        rows = “stories” (interfaces), columns = attributes (Trust, Adaptability, …).  
        Click a cell → pick a Δ → watch local coupling + network spillover.
      </div>

    </div>
  </section>

  <!-- RIGHT: Views -->
  <section class="panel" aria-label="Views panel">
    <div class="tabs">
      <div class="tab active" data-tab="matrix">Matrix (Attribute Heatmap)</div>
      <div class="tab" data-tab="network">Network (Relationships)</div>
      <div class="tab" data-tab="dashboard">Dashboard (KPIs)</div>
      <div class="tab" data-tab="mapping">SharpCloud Mapping (Export)</div>
    </div>

    <div id="matrix" class="view active">
      <div class="small" style="margin-bottom:10px;">
        Click any cell to select it. Values are 0–100. Ambiguity is inverted (high = bad) for color.
      </div>
      <div id="matrixHost"></div>
    </div>

    <div id="network" class="view">
      <div class="netWrap">
        <div class="netStage" id="netStage">
          <div class="tooltip" id="netTip"></div>
          <svg id="netSvg" viewBox="0 0 1000 600" width="100%" height="100%" role="img" aria-label="Interface network"></svg>
        </div>
        <div class="card">
          <h3>Network legend</h3>
          <div class="small">
            <div style="margin-bottom:8px;">Nodes = interfaces (stories). Color = “maturity index”.</div>
            <div style="margin-bottom:8px;">Edges: <span class="kbd">shared party</span> uses spillover <b id="netStrong">0.15</b>. Weak ties use <b id="netWeak">0.05</b>.</div>
            <div class="divider"></div>
            <label style="margin:0 0 6px;">Show weak ties</label>
            <input id="showWeak" type="checkbox" checked />
            <div class="divider"></div>
            <div>
              <b>Maturity index (0–100)</b> = average of:
              Trust, Adaptability, Escalation readiness, Shared incentives, and (100 − Ambiguity).
            </div>
            <div class="divider"></div>
            <div class="small">
              Hover nodes for details.  
              Tip: after a nudge, weak ties can still move (slowly), but weights dampen large interfaces.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="dashboard" class="view">
      <div class="kpis" id="kpis"></div>
      <div class="grid2">
        <div class="card">
          <h3>Maturity index by interface</h3>
          <canvas id="barCanvas" width="900" height="320"></canvas>
        </div>
        <div class="card">
          <h3>Average maturity trend</h3>
          <canvas id="trendCanvas" width="520" height="320"></canvas>
        </div>
      </div>
      <div class="divider"></div>
      <div class="card">
        <h3>Notes you can say out loud in a demo</h3>
        <div class="small" id="demoNotes"></div>
      </div>
    </div>

    <div id="mapping" class="view">
      <div class="card">
        <h3>How this maps to SharpCloud (conceptual)</h3>
        <div class="small">
          <ol>
            <li><b>Stories</b>: each interface row becomes a Story (e.g., “PM↔Design”).</li>
            <li><b>Attributes</b>: Trust, Adaptability, Ambiguity, EscalationReadiness, SharedIncentives (numeric 0–100).</li>
            <li><b>Tags</b>: Owner, Workstream Tag, Parties (e.g., Party:PM).</li>
            <li><b>Relationships</b>: connect Stories if they share a Party (strong tie), else weak tie (optional).</li>
            <li><b>Panels</b>:
              <ul>
                <li>Attribute Matrix: heatmap (this page’s Matrix view)</li>
                <li>Network view: relationships graph (this page’s Network view)</li>
                <li>Dashboard: KPIs and trends (this page’s Dashboard view)</li>
              </ul>
            </li>
          </ol>
          This page exports a <b>standalone JSON “pack”</b> + <b>CSV</b> you could adapt to whatever import/API process you use—without depending on any SharpCloud instance.
        </div>
      </div>

      <div class="divider"></div>

      <div class="grid2">
        <div class="card">
          <h3>Export pack (JSON)</h3>
          <div class="btns" style="margin:0 0 10px;">
            <button id="copyJsonBtn" class="secondary">Copy JSON</button>
            <button id="downloadJsonBtn" class="secondary">Download JSON</button>
          </div>
          <textarea id="jsonOut" spellcheck="false"></textarea>
        </div>

        <div class="card">
          <h3>Attribute table (CSV)</h3>
          <div class="btns" style="margin:0 0 10px;">
            <button id="copyCsvBtn" class="secondary">Copy CSV</button>
            <button id="downloadCsvBtn" class="secondary">Download CSV</button>
          </div>
          <textarea id="csvOut" spellcheck="false"></textarea>
        </div>
      </div>

      <div class="divider"></div>

      <div class="card">
        <h3>Import / Export state (for this simulator)</h3>
        <div class="small">Paste a previously exported simulator state JSON here and click “Load state”.</div>
        <div class="btns" style="margin:10px 0;">
          <button id="exportStateBtn" class="secondary">Export simulator state</button>
          <button id="loadStateBtn" class="secondary">Load state</button>
        </div>
        <textarea id="stateIO" spellcheck="false" placeholder='{"step":...,"interfaces":[...]}'></textarea>
      </div>
    </div>

  </section>
</div>

<script>
/* ============================
   Interface Maturity Simulator
   (Standalone, SharpCloud-style)
   ============================ */

(() => {
  "use strict";

  /* ---------- Model meta ---------- */
  const VARS = [
    { key: "Trust", label: "Trust", goodHigh: true, tip: "Confidence that others will act in good faith." },
    { key: "Adaptability", label: "Adaptability", goodHigh: true, tip: "Ability to adjust when reality changes." },
    { key: "Ambiguity", label: "Ambiguity", goodHigh: false, tip: "Unclear scope/roles/definition of done (high = bad)." },
    { key: "EscalationReadiness", label: "Escalation readiness", goodHigh: true, tip: "How quickly issues are surfaced & resolved." },
    { key: "SharedIncentives", label: "Shared incentives", goodHigh: true, tip: "Aligned goals, shared wins/losses." }
  ];

  const DEFAULT_CONFIG = {
    localIterations: 4,
    spilloverStrong: 0.15,
    spilloverWeak: 0.05,
    frictionAmbiguityThreshold: 70,
    frictionPositiveFactor: 0.5,
    safetyEscalationThreshold: 30,
    safetyAmbiguityThreshold: 60,
    safetyPenalty: 5,
    localCouplingEdges: [
      { from: "Ambiguity", to: "Trust", coeff: -0.6 },
      { from: "Ambiguity", to: "EscalationReadiness", coeff: 0.3 },
      { from: "Trust", to: "Adaptability", coeff: 0.5 },
      { from: "Trust", to: "SharedIncentives", coeff: 0.5 },
      { from: "SharedIncentives", to: "Ambiguity", coeff: -0.4 }
    ]
  };

  const BASE_INTERFACES = [
    {
      id: "pm-design",
      name: "PM↔Design",
      parties: ["PM", "Design"],
      owner: "Alex",
      tag: "Design",
      weight: 1.0,
      values: { Trust:55, Adaptability:60, Ambiguity:45, EscalationReadiness:50, SharedIncentives:50 }
    },
    {
      id: "pm-client",
      name: "PM↔Client",
      parties: ["PM", "Client"],
      owner: "Sam",
      tag: "Governance",
      weight: 1.3,
      values: { Trust:50, Adaptability:55, Ambiguity:50, EscalationReadiness:45, SharedIncentives:52 }
    },
    {
      id: "design-supply",
      name: "Design↔Supply Chain",
      parties: ["Design", "Supply Chain"],
      owner: "Mia",
      tag: "Delivery",
      weight: 1.1,
      values: { Trust:48, Adaptability:50, Ambiguity:58, EscalationReadiness:42, SharedIncentives:46 }
    },
    {
      id: "contractor-clientrep",
      name: "Contractor↔Client Rep",
      parties: ["Contractor", "Client"],
      owner: "Lee",
      tag: "Commercial",
      weight: 1.4,
      values: { Trust:52, Adaptability:49, Ambiguity:60, EscalationReadiness:40, SharedIncentives:44 }
    },
    {
      id: "risk-finance",
      name: "Risk↔Finance",
      parties: ["Risk", "Finance"],
      owner: "Pat",
      tag: "Assurance",
      weight: 1.2,
      values: { Trust:47, Adaptability:53, Ambiguity:55, EscalationReadiness:48, SharedIncentives:50 }
    }
  ];

  /* ---------- Helpers ---------- */
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const clamp100 = (x) => Math.max(0, Math.min(100, x));
  const round1 = (x) => Math.round(x * 10) / 10;
  const round0 = (x) => Math.round(x);

  const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));

  function maturityIndex(values){
    // Average of good variables plus (100 - ambiguity)
    const good =
      values.Trust +
      values.Adaptability +
      values.EscalationReadiness +
      values.SharedIncentives +
      (100 - values.Ambiguity);
    return good / 5;
  }

  function avg(arr){
    if (!arr.length) return 0;
    return arr.reduce((a,b)=>a+b,0) / arr.length;
  }

  function intersects(a, b){
    const set = new Set(a);
    return b.some(x => set.has(x));
  }

  function sharedParties(a, b){
    const set = new Set(a.parties);
    return b.parties.filter(p => set.has(p));
  }

  // Heat color: score 0..1 => hue 0..120
  function heatColor(varMeta, value){
    const score = varMeta.goodHigh ? (value/100) : (1 - value/100);
    const s = clamp01(score);
    const hue = 120 * s;           // 0 red -> 120 green
    const sat = 70;
    const light = 30 + 18 * s;     // darker for low, lighter for high
    return `hsl(${hue}, ${sat}%, ${light}%)`;
  }

  function formatDelta(d){
    const x = round1(d);
    const sign = x > 0 ? "+" : "";
    return `${sign}${x}`;
  }

  function safeClipboardWrite(text){
    if (navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    // fallback
    window.prompt("Copy to clipboard:", text);
    return Promise.resolve();
  }

  function downloadText(filename, text){
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  function zerosDelta(){
    const d = {};
    for (const v of VARS) d[v.key] = 0;
    return d;
  }

  /* ---------- State ---------- */
  const state = {
    config: deepCopy(DEFAULT_CONFIG),
    step: 0,
    // interfaces will be expanded with history + lastStepDelta
    interfaces: [],
    undoStack: [],
    selected: { ifaceId: null, varKey: null },
    globalHistory: {
      avgMaturity: [ ],
      avgTrust: [ ]
    }
  };

  // Initialize with baseline
  function initInterfaces(){
    state.interfaces = deepCopy(BASE_INTERFACES).map(it => ({
      ...it,
      history: {
        Trust: [it.values.Trust],
        Maturity: [maturityIndex(it.values)]
      },
      lastStepDelta: zerosDelta()
    }));
    state.step = 0;
    state.undoStack = [];
    state.globalHistory.avgMaturity = [ avg(state.interfaces.map(i=>maturityIndex(i.values))) ];
    state.globalHistory.avgTrust = [ avg(state.interfaces.map(i=>i.values.Trust)) ];
    state.selected = { ifaceId: state.interfaces[0].id, varKey: VARS[0].key };
  }

  initInterfaces();

  /* ---------- Core simulation ---------- */

  function computeLocalDeltas(userVarKey, userDelta){
    // Propagate in "waves" along coupling edges for N iterations.
    // frontier starts as user delta on userVarKey, then each iteration produces new deltas.
    const N = Math.max(1, Math.min(10, state.config.localIterations|0));
    const total = zerosDelta();
    const frontier = zerosDelta();
    total[userVarKey] = userDelta;
    frontier[userVarKey] = userDelta;

    const waves = [];
    waves.push({ iter: 0, frontier: deepCopy(frontier) });

    for (let iter=1; iter<=N; iter++){
      const next = zerosDelta();
      for (const edge of state.config.localCouplingEdges){
        next[edge.to] += edge.coeff * frontier[edge.from];
      }
      for (const v of VARS){
        total[v.key] += next[v.key];
      }
      for (const v of VARS){
        frontier[v.key] = next[v.key];
      }
      waves.push({ iter, frontier: deepCopy(frontier) });
    }
    for (const v of VARS) total[v.key] = round1(total[v.key]);
    return { total, waves };
  }

  function spilloverCoeff(iFace, jFace){
    const strong = intersects(iFace.parties, jFace.parties);
    let coeff = strong ? state.config.spilloverStrong : state.config.spilloverWeak;

    // Weight damping: if j is heavier than i, scale by weight(i)/weight(j)
    if (jFace.weight > iFace.weight){
      coeff *= (iFace.weight / jFace.weight);
    }
    return { coeff, strong };
  }

  function applyDeltasToInterface(iface, deltas){
    // Apply deltas with clamp
    for (const v of VARS){
      const k = v.key;
      iface.values[k] = round1(clamp100(iface.values[k] + deltas[k]));
    }
  }

  function applySafetyValve(iface){
    const cfg = state.config;
    if (iface.values.EscalationReadiness < cfg.safetyEscalationThreshold &&
        iface.values.Ambiguity > cfg.safetyAmbiguityThreshold){
      iface.values.Trust = round1(clamp100(iface.values.Trust - cfg.safetyPenalty));
      iface.values.Adaptability = round1(clamp100(iface.values.Adaptability - cfg.safetyPenalty));
      return true;
    }
    return false;
  }

  function snapshot(){
    return deepCopy({
      step: state.step,
      interfaces: state.interfaces,
      globalHistory: state.globalHistory,
      selected: state.selected,
      config: state.config
    });
  }

  function restore(snap){
    state.step = snap.step;
    state.interfaces = snap.interfaces;
    state.globalHistory = snap.globalHistory;
    state.selected = snap.selected;
    state.config = snap.config;
  }

  function runAction({ ifaceId, varKey, mode, value }){
    // mode: "delta" => value is Δ
    // mode: "set"   => value is absolute; Δ = value - current
    const iface = state.interfaces.find(x => x.id === ifaceId);
    if (!iface) return;

    const before = snapshot();
    state.undoStack.push(before);

    // clear last-step deltas
    for (const it of state.interfaces){
      it.lastStepDelta = zerosDelta();
    }

    const current = iface.values[varKey];
    const userDelta = (mode === "set") ? (value - current) : value;

    const { total: localTotal, waves } = computeLocalDeltas(varKey, userDelta);

    // Capture before-values to compute last-step deltas at the end
    const beforeValues = new Map(state.interfaces.map(it => [it.id, deepCopy(it.values)]));

    // 1) Apply local coupling to chosen interface
    applyDeltasToInterface(iface, localTotal);

    // 2) Spillover to other interfaces
    const spillNotes = [];
    for (const other of state.interfaces){
      if (other.id === iface.id) continue;

      const { coeff, strong } = spilloverCoeff(iface, other);
      const spill = zerosDelta();
      for (const v of VARS){
        spill[v.key] = round1(localTotal[v.key] * coeff);
      }

      // Friction cap on receiver if its ambiguity is high BEFORE receiving spill
      const cfg = state.config;
      let frictionApplied = false;
      if (other.values.Ambiguity > cfg.frictionAmbiguityThreshold){
        for (const v of VARS){
          if (spill[v.key] > 0){
            spill[v.key] = round1(spill[v.key] * cfg.frictionPositiveFactor);
            frictionApplied = true;
          }
        }
      }

      applyDeltasToInterface(other, spill);

      spillNotes.push({
        to: other.name,
        coeff: round1(coeff),
        strong,
        frictionApplied,
        spill
      });
    }

    // 3) Safety valve check across all
    const safetyHits = [];
    for (const it of state.interfaces){
      const hit = applySafetyValve(it);
      if (hit) safetyHits.push(it.name);
    }

    // 4) Update step, histories, lastStepDelta
    state.step += 1;

    for (const it of state.interfaces){
      const b = beforeValues.get(it.id);
      for (const v of VARS){
        const k = v.key;
        it.lastStepDelta[k] = round1(it.values[k] - b[k]);
      }
      it.history.Trust.push(it.values.Trust);
      it.history.Maturity.push(maturityIndex(it.values));
      // keep recent window
      if (it.history.Trust.length > 30) it.history.Trust.shift();
      if (it.history.Maturity.length > 30) it.history.Maturity.shift();
    }

    state.globalHistory.avgMaturity.push(avg(state.interfaces.map(i=>maturityIndex(i.values))));
    state.globalHistory.avgTrust.push(avg(state.interfaces.map(i=>i.values.Trust)));
    if (state.globalHistory.avgMaturity.length > 60) state.globalHistory.avgMaturity.shift();
    if (state.globalHistory.avgTrust.length > 60) state.globalHistory.avgTrust.shift();

    // 5) Render and log
    renderAll();
    writeLog({
      ifaceName: iface.name,
      varKey,
      mode,
      input: value,
      userDelta: round1(userDelta),
      localTotal,
      waves,
      spillNotes,
      safetyHits
    });
  }

  function runScenario(kind){
    const before = snapshot();
    state.undoStack.push(before);

    for (const it of state.interfaces){
      it.lastStepDelta = zerosDelta();
    }
    const beforeValues = new Map(state.interfaces.map(it => [it.id, deepCopy(it.values)]));

    const notes = [];
    const applyExogenous = (ifaceId, varKey, delta) => {
      const it = state.interfaces.find(x=>x.id===ifaceId);
      if (!it) return;
      const d = zerosDelta();
      d[varKey] = delta;
      applyDeltasToInterface(it, d);
      notes.push(`${it.name}: ${varKey} ${formatDelta(delta)}`);
    };

    if (kind === "early_warning"){
      for (const it of state.interfaces) applyExogenous(it.id, "EscalationReadiness", +10);
    } else if (kind === "contract_misalign"){
      for (const it of state.interfaces) applyExogenous(it.id, "SharedIncentives", -15);
    } else if (kind === "clarify_scope"){
      for (const it of state.interfaces) applyExogenous(it.id, "Ambiguity", -12);
    } else if (kind === "deadline_pressure"){
      applyExogenous("pm-client", "Ambiguity", +12);
      applyExogenous("pm-client", "Trust", -8);
    } else {
      // unknown
      state.undoStack.pop();
      return;
    }

    const safetyHits = [];
    for (const it of state.interfaces){
      const hit = applySafetyValve(it);
      if (hit) safetyHits.push(it.name);
    }

    state.step += 1;
    for (const it of state.interfaces){
      const b = beforeValues.get(it.id);
      for (const v of VARS){
        const k = v.key;
        it.lastStepDelta[k] = round1(it.values[k] - b[k]);
      }
      it.history.Trust.push(it.values.Trust);
      it.history.Maturity.push(maturityIndex(it.values));
      if (it.history.Trust.length > 30) it.history.Trust.shift();
      if (it.history.Maturity.length > 30) it.history.Maturity.shift();
    }

    state.globalHistory.avgMaturity.push(avg(state.interfaces.map(i=>maturityIndex(i.values))));
    state.globalHistory.avgTrust.push(avg(state.interfaces.map(i=>i.values.Trust)));
    if (state.globalHistory.avgMaturity.length > 60) state.globalHistory.avgMaturity.shift();
    if (state.globalHistory.avgTrust.length > 60) state.globalHistory.avgTrust.shift();

    renderAll();
    const log = [
      `Scenario: ${kind}`,
      ...notes.map(x => `  - ${x}`),
      safetyHits.length ? `Safety valve triggered on: ${safetyHits.join(", ")}` : `Safety valve: none`
    ].join("\n");
    document.getElementById("log").textContent = log;
  }

  /* ---------- Rendering ---------- */
  const $ = (id) => document.getElementById(id);

  function renderHeaderPills(){
    $("stepPill").textContent = String(state.step);
    const sel = state.selected;
    const iface = state.interfaces.find(x=>x.id===sel.ifaceId);
    const name = iface ? iface.name : "—";
    $("selPill").textContent = (iface && sel.varKey) ? `${name} · ${sel.varKey}` : "—";
    $("iterPill").textContent = String(state.config.localIterations);
    $("spillPill").textContent = `${state.config.spilloverStrong} / ${state.config.spilloverWeak}`;
    $("fricPill").textContent = `A>${state.config.frictionAmbiguityThreshold} → +Δ×${state.config.frictionPositiveFactor}`;
    $("netStrong").textContent = String(state.config.spilloverStrong);
    $("netWeak").textContent = String(state.config.spilloverWeak);
  }

  function renderSelects(){
    const ifaceSel = $("ifaceSel");
    const varSel = $("varSel");

    // interfaces
    ifaceSel.innerHTML = "";
    for (const it of state.interfaces){
      const opt = document.createElement("option");
      opt.value = it.id;
      opt.textContent = `${it.name}  (w=${it.weight}, parties=${it.parties.join("&")})`;
      ifaceSel.appendChild(opt);
    }

    // vars
    varSel.innerHTML = "";
    for (const v of VARS){
      const opt = document.createElement("option");
      opt.value = v.key;
      opt.textContent = v.label;
      opt.title = v.tip;
      varSel.appendChild(opt);
    }

    // set selected
    ifaceSel.value = state.selected.ifaceId || state.interfaces[0].id;
    varSel.value = state.selected.varKey || VARS[0].key;
  }

  function renderMatrix(){
    const host = $("matrixHost");
    host.innerHTML = "";

    const table = document.createElement("table");
    const thead = document.createElement("thead");
    const trh = document.createElement("tr");

    const th0 = document.createElement("th");
    th0.textContent = "Interface (Story)";
    trh.appendChild(th0);

    for (const v of VARS){
      const th = document.createElement("th");
      th.textContent = v.label + (v.key==="Ambiguity" ? " (high=bad)" : "");
      th.title = v.tip;
      trh.appendChild(th);
    }

    const thM = document.createElement("th");
    thM.textContent = "Maturity index";
    thM.title = "Average of Trust, Adaptability, Escalation readiness, Shared incentives, and (100 - Ambiguity).";
    trh.appendChild(thM);

    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    const sel = state.selected;

    for (const it of state.interfaces){
      const tr = document.createElement("tr");

      // Left sticky cell
      const td0 = document.createElement("td");
      const nameLine = document.createElement("div");
      nameLine.className = "ifaceName";

      const left = document.createElement("div");
      left.textContent = it.name;

      const right = document.createElement("div");
      right.className = "pill";
      right.style.fontSize = "11px";
      right.textContent = `w=${it.weight}`;

      nameLine.appendChild(left);
      nameLine.appendChild(right);

      const meta = document.createElement("div");
      meta.className = "metaSmall";
      meta.textContent = `Parties: ${it.parties.join(" ↔ ")} · Owner: ${it.owner} · Tag: ${it.tag}`;

      const sparkWrap = document.createElement("div");
      sparkWrap.className = "sparkWrap";
      const lbl = document.createElement("div");
      lbl.className = "sparkLbl";
      lbl.textContent = "Trust";
      const canvas = document.createElement("canvas");
      canvas.className = "spark";
      canvas.width = 220;
      canvas.height = 44;
      drawSpark(canvas, it.history.Trust);

      const lbl2 = document.createElement("div");
      lbl2.className = "sparkLbl";
      lbl2.textContent = "Index";
      const canvas2 = document.createElement("canvas");
      canvas2.className = "spark";
      canvas2.width = 220;
      canvas2.height = 44;
      drawSpark(canvas2, it.history.Maturity);

      sparkWrap.appendChild(lbl);
      sparkWrap.appendChild(canvas);
      sparkWrap.appendChild(lbl2);
      sparkWrap.appendChild(canvas2);

      td0.appendChild(nameLine);
      td0.appendChild(meta);
      td0.appendChild(sparkWrap);
      tr.appendChild(td0);

      // Value cells
      for (const v of VARS){
        const td = document.createElement("td");
        const cell = document.createElement("div");
        cell.className = "cell";
        const isSelected = (sel.ifaceId === it.id && sel.varKey === v.key);
        if (isSelected) cell.classList.add("selected");

        const val = it.values[v.key];
        cell.style.background = `linear-gradient(180deg, ${heatColor(v,val)}, rgba(9,13,28,.35))`;

        const leftVal = document.createElement("div");
        leftVal.className = "cellVal";
        leftVal.textContent = String(round0(val));

        const d = it.lastStepDelta[v.key] || 0;
        const delta = document.createElement("div");
        delta.className = "cellDelta";
        if (d > 0) delta.classList.add("deltaPos");
        else if (d < 0) delta.classList.add("deltaNeg");
        else delta.classList.add("deltaZero");
        delta.textContent = `Δ${formatDelta(d)}`;

        cell.appendChild(leftVal);
        cell.appendChild(delta);

        cell.title = `${it.name}\n${v.label}: ${round1(val)} (Δ${formatDelta(d)})\nTip: ${v.tip}`;

        cell.addEventListener("click", () => {
          state.selected.ifaceId = it.id;
          state.selected.varKey = v.key;
          syncControlsToSelection();
          renderAll(); // redraw selection highlight
        });

        td.appendChild(cell);
        tr.appendChild(td);
      }

      // Maturity index column
      const tdM = document.createElement("td");
      const idx = maturityIndex(it.values);
      const cellM = document.createElement("div");
      cellM.className = "cell";
      cellM.style.cursor = "default";
      cellM.style.background = `linear-gradient(180deg, ${heatColor({goodHigh:true}, idx)}, rgba(9,13,28,.35))`;

      const v1 = document.createElement("div");
      v1.className = "cellVal";
      v1.textContent = String(round0(idx));

      const dIdx = round1(idx - it.history.Maturity[it.history.Maturity.length - 2] || 0);
      const dTag = document.createElement("div");
      dTag.className = "cellDelta";
      if (dIdx > 0) dTag.classList.add("deltaPos");
      else if (dIdx < 0) dTag.classList.add("deltaNeg");
      else dTag.classList.add("deltaZero");
      dTag.textContent = `Δ${formatDelta(dIdx)}`;

      cellM.appendChild(v1);
      cellM.appendChild(dTag);
      tdM.appendChild(cellM);
      tr.appendChild(tdM);

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    host.appendChild(table);
  }

  function drawSpark(canvas, series){
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background
    ctx.fillStyle = "rgba(0,0,0,0.0)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if (!series || series.length < 2) return;

    const pad = 6;
    const w = canvas.width - pad*2;
    const h = canvas.height - pad*2;
    const xs = series.length;
    const minV = 0;
    const maxV = 100;

    // axis line
    ctx.strokeStyle = "rgba(185,193,255,0.22)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad, pad+h);
    ctx.lineTo(pad+w, pad+h);
    ctx.stroke();

    // line
    ctx.strokeStyle = "rgba(232,236,255,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i=0; i<xs; i++){
      const x = pad + (w * (i/(xs-1)));
      const yNorm = (series[i]-minV)/(maxV-minV);
      const y = pad + (h * (1 - yNorm));
      if (i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // last dot
    const last = series[xs-1];
    const x = pad + w;
    const y = pad + (h * (1 - (last-minV)/(maxV-minV)));
    ctx.fillStyle = "rgba(122,162,255,0.95)";
    ctx.beginPath();
    ctx.arc(x,y,3.2,0,Math.PI*2);
    ctx.fill();
  }

  function renderNetwork(){
    const svg = $("netSvg");
    const tip = $("netTip");
    svg.innerHTML = "";

    const showWeak = $("showWeak").checked;

    const nodes = state.interfaces.map((it, idx) => ({
      id: it.id,
      name: it.name,
      it,
      idx
    }));

    // circle layout
    const cx = 500, cy = 290;
    const R = 210;
    const positions = new Map();
    nodes.forEach((n, i) => {
      const angle = (Math.PI*2) * (i / nodes.length) - Math.PI/2;
      positions.set(n.id, { x: cx + R*Math.cos(angle), y: cy + R*Math.sin(angle) });
    });

    // edges for all pairs (strong + optional weak)
    const edges = [];
    for (let i=0;i<nodes.length;i++){
      for (let j=i+1;j<nodes.length;j++){
        const a = nodes[i].it;
        const b = nodes[j].it;
        const shared = sharedParties(a,b);
        const strong = shared.length > 0;
        if (!strong && !showWeak) continue;
        const { coeff } = spilloverCoeff(a,b); // note: coeff depends on weight direction; for display we'll show symmetric-ish
        edges.push({
          a: nodes[i], b: nodes[j],
          strong,
          label: strong ? `Shared: ${shared.join(", ")}` : "Weak tie",
          coeff: round1(coeff)
        });
      }
    }

    // Draw edges
    for (const e of edges){
      const p1 = positions.get(e.a.id);
      const p2 = positions.get(e.b.id);

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", p1.x);
      line.setAttribute("y1", p1.y);
      line.setAttribute("x2", p2.x);
      line.setAttribute("y2", p2.y);

      const alpha = e.strong ? 0.55 : 0.22;
      line.setAttribute("stroke", `rgba(185,193,255,${alpha})`);
      line.setAttribute("stroke-width", e.strong ? 3 : 1.5);

      // hover
      line.addEventListener("mousemove", (ev) => {
        tip.style.display = "block";
        tip.style.left = (ev.offsetX + 14) + "px";
        tip.style.top = (ev.offsetY + 14) + "px";
        tip.textContent = `${e.a.name} ↔ ${e.b.name}\n${e.label}\nspillover≈${e.coeff}`;
      });
      line.addEventListener("mouseleave", ()=> tip.style.display="none");

      svg.appendChild(line);
    }

    // Draw nodes
    for (const n of nodes){
      const p = positions.get(n.id);
      const idx = maturityIndex(n.it.values);

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("transform", `translate(${p.x},${p.y})`);

      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("r", 22);
      circle.setAttribute("fill", heatColor({goodHigh:true}, idx));
      circle.setAttribute("stroke", "rgba(232,236,255,0.65)");
      circle.setAttribute("stroke-width", "2");

      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("y", 44);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("fill", "rgba(232,236,255,0.92)");
      text.setAttribute("font-size", "12");
      text.setAttribute("font-weight", "750");
      text.textContent = n.name;

      const small = document.createElementNS("http://www.w3.org/2000/svg", "text");
      small.setAttribute("y", 5);
      small.setAttribute("text-anchor", "middle");
      small.setAttribute("fill", "rgba(9,13,28,0.85)");
      small.setAttribute("font-size", "13");
      small.setAttribute("font-weight", "900");
      small.textContent = String(round0(idx));

      g.appendChild(circle);
      g.appendChild(small);
      g.appendChild(text);

      g.addEventListener("mousemove", (ev) => {
        const box = $("netStage").getBoundingClientRect();
        tip.style.display = "block";
        tip.style.left = (ev.clientX - box.left + 14) + "px";
        tip.style.top = (ev.clientY - box.top + 14) + "px";
        tip.innerHTML = ""; // build richer tooltip safely
        const t = document.createElement("div");
        t.className = "t";
        t.textContent = n.name;
        tip.appendChild(t);

        const rows = [
          ["Index", round1(idx)],
          ["Trust", n.it.values.Trust],
          ["Adapt", n.it.values.Adaptability],
          ["Ambig", n.it.values.Ambiguity],
          ["Esc", n.it.values.EscalationReadiness],
          ["Incent", n.it.values.SharedIncentives],
          ["Weight", n.it.weight]
        ];
        for (const [k,v] of rows){
          const r = document.createElement("div");
          r.className = "r";
          const a = document.createElement("span");
          a.textContent = k;
          const b = document.createElement("span");
          b.textContent = String(round1(v));
          r.appendChild(a); r.appendChild(b);
          tip.appendChild(r);
        }
      });
      g.addEventListener("mouseleave", ()=> tip.style.display="none");

      svg.appendChild(g);
    }
  }

  function renderDashboard(){
    // KPIs
    const kpis = $("kpis");
    kpis.innerHTML = "";

    const indices = state.interfaces.map(it => maturityIndex(it.values));
    const avgIdx = avg(indices);
    const avgTrust = avg(state.interfaces.map(it=>it.values.Trust));
    const hiAmb = state.interfaces.filter(it=>it.values.Ambiguity > 70).length;
    const lowEsc = state.interfaces.filter(it=>it.values.EscalationReadiness < 30).length;

    const cards = [
      { k: "Average maturity", v: round0(avgIdx) },
      { k: "Average trust", v: round0(avgTrust) },
      { k: "High ambiguity (A>70)", v: hiAmb },
      { k: "Low escalation (E<30)", v: lowEsc }
    ];
    for (const c of cards){
      const el = document.createElement("div");
      el.className = "kpi";
      const k = document.createElement("div");
      k.className = "k";
      k.textContent = c.k;
      const v = document.createElement("div");
      v.className = "v";
      v.textContent = String(c.v);
      el.appendChild(k); el.appendChild(v);
      kpis.appendChild(el);
    }

    // Bar chart
    drawBars($("barCanvas"), state.interfaces.map(it => ({
      label: it.name,
      value: maturityIndex(it.values)
    })));

    // Trend chart
    drawTrend($("trendCanvas"), state.globalHistory.avgMaturity);

    // Demo notes
    const notes = [
      `• “Notice how a single nudge creates local coupling (within the interface) AND spillover to other interfaces that share a party.”`,
      `• “Ambiguity acts like friction: once A>${state.config.frictionAmbiguityThreshold}, positive changes get damped.”`,
      `• “If escalation readiness collapses while ambiguity is high, the safety valve hits trust & adaptability: quiet + murky = rot.”`,
      `• “The weight term makes ‘big’ interfaces harder to move with spillover—so the same behaviour shift has different reach.”`,
      `• “In SharpCloud terms: these are Stories with Attributes + Relationships; the matrix and network are just two projections.”`
    ];
    $("demoNotes").textContent = notes.join("\n");
  }

  function drawBars(canvas, series){
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(0,0,w,h);

    const padL=140, padR=20, padT=24, padB=36;
    const innerW = w - padL - padR;
    const innerH = h - padT - padB;

    // axis
    ctx.strokeStyle = "rgba(185,193,255,0.25)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT+innerH);
    ctx.lineTo(padL+innerW, padT+innerH);
    ctx.stroke();

    // grid + labels (0..100)
    ctx.fillStyle = "rgba(185,193,255,0.7)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    for (let t=0; t<=100; t+=25){
      const x = padL + innerW*(t/100);
      ctx.strokeStyle = "rgba(185,193,255,0.12)";
      ctx.beginPath();
      ctx.moveTo(x, padT);
      ctx.lineTo(x, padT+innerH);
      ctx.stroke();
      ctx.fillText(String(t), x-8, padT+innerH+22);
    }

    const barH = innerH / Math.max(1, series.length);
    series.forEach((s, i) => {
      const y = padT + i*barH + 8;
      const bh = barH - 16;

      // label
      ctx.fillStyle = "rgba(232,236,255,0.92)";
      ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(s.label, 12, y+bh*0.72);

      // bar
      const val = clamp100(s.value);
      const bw = innerW * (val/100);
      ctx.fillStyle = "rgba(122,162,255,0.55)";
      ctx.fillRect(padL, y, bw, bh);

      // value
      ctx.fillStyle = "rgba(232,236,255,0.92)";
      ctx.font = "bold 12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(String(round0(val)), padL + bw + 8, y+bh*0.72);
    });
  }

  function drawTrend(canvas, series){
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const pad=24, padB=34;
    const innerW = w - pad*2;
    const innerH = h - pad - padB;

    // axis
    ctx.strokeStyle = "rgba(185,193,255,0.25)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, pad+innerH);
    ctx.lineTo(pad+innerW, pad+innerH);
    ctx.stroke();

    if (!series || series.length < 2) return;

    // line
    ctx.strokeStyle = "rgba(107,255,176,0.72)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    const n = series.length;
    for (let i=0; i<n; i++){
      const x = pad + innerW*(i/(n-1));
      const y = pad + innerH*(1 - clamp01(series[i]/100));
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // last point
    const last = series[n-1];
    const lx = pad + innerW;
    const ly = pad + innerH*(1 - clamp01(last/100));
    ctx.fillStyle = "rgba(232,236,255,0.95)";
    ctx.beginPath();
    ctx.arc(lx,ly,3.2,0,Math.PI*2);
    ctx.fill();

    // label
    ctx.fillStyle = "rgba(185,193,255,0.85)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText("Avg index", pad, 16);
    ctx.fillText(String(round0(last)), lx-18, ly-10);
  }

  function generateExportPack(){
    // Conceptual SharpCloud-like pack: Stories + attributes + relationships
    const now = new Date().toISOString();

    const attributeDefinitions = VARS.map(v => ({
      key: v.key,
      label: v.label,
      type: "number",
      min: 0,
      max: 100,
      note: v.tip
    })).concat([
      { key: "Weight", label: "Weight", type: "number", min: 0, max: 10, note: "Interface importance / inertia." },
      { key: "Owner", label: "Owner", type: "text", note: "Accountable owner." },
      { key: "Tag", label: "Tag", type: "text", note: "Workstream tag." }
    ]);

    const stories = state.interfaces.map(it => ({
      id: it.id,
      title: it.name,
      tags: [
        `Tag:${it.tag}`,
        `Owner:${it.owner}`,
        ...it.parties.map(p=>`Party:${p}`)
      ],
      attributes: {
        ...it.values,
        Weight: it.weight,
        Owner: it.owner,
        Tag: it.tag
      },
      description: `Interface between ${it.parties.join(" and ")}.`
    }));

    const relationships = [];
    for (let i=0;i<state.interfaces.length;i++){
      for (let j=i+1;j<state.interfaces.length;j++){
        const a = state.interfaces[i];
        const b = state.interfaces[j];
        const shared = sharedParties(a,b);
        const strong = shared.length > 0;

        const coeffAtoB = spilloverCoeff(a,b).coeff;
        const coeffBtoA = spilloverCoeff(b,a).coeff;

        relationships.push({
          from: a.id,
          to: b.id,
          type: strong ? "shared_party" : "weak_tie",
          label: strong ? `Shared: ${shared.join(", ")}` : "No shared party",
          strength_hint: round1(Math.max(coeffAtoB, coeffBtoA)),
          note: strong
            ? "Spillover uses strong coefficient (then weight-damped if receiver heavier)."
            : "Optional weak tie spillover."
        });
      }
    }

    const pack = {
      meta: {
        tool: "Interface Maturity Simulator",
        generatedAt: now,
        step: state.step,
        notes: [
          "This is NOT an official SharpCloud API format.",
          "It mirrors a typical Story + Attribute + Relationship structure for import/mapping."
        ]
      },
      modelConfig: deepCopy(state.config),
      attributeDefinitions,
      stories,
      relationships
    };

    return JSON.stringify(pack, null, 2);
  }

  function generateCSV(){
    const cols = [
      "Interface","PartyA","PartyB","Owner","Tag","Weight",
      ...VARS.map(v=>v.key),
      "MaturityIndex"
    ];
    const lines = [cols.join(",")];

    for (const it of state.interfaces){
      const row = [
        it.name,
        it.parties[0] || "",
        it.parties[1] || "",
        it.owner,
        it.tag,
        it.weight,
        ...VARS.map(v => round1(it.values[v.key])),
        round1(maturityIndex(it.values))
      ].map(x => {
        const s = String(x);
        // CSV escape
        return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
      });
      lines.push(row.join(","));
    }
    return lines.join("\n");
  }

  function renderMapping(){
    $("jsonOut").value = generateExportPack();
    $("csvOut").value = generateCSV();
  }

  function renderAll(){
    renderHeaderPills();
    renderSelects();
    renderMatrix();
    renderNetwork();
    renderDashboard();
    renderMapping();
    syncControlsToSelection(false);
  }

  function syncControlsToSelection(updateDeltaField = true){
    const sel = state.selected;
    $("ifaceSel").value = sel.ifaceId;
    $("varSel").value = sel.varKey;

    // Update delta field to something sensible:
    // If mode is set, show current value. If delta, keep user chosen unless asked.
    const mode = $("modeSel").value;
    const iface = state.interfaces.find(x=>x.id===sel.ifaceId);
    if (!iface) return;

    $("selPill").textContent = `${iface.name} · ${sel.varKey}`;

    if (!updateDeltaField) return;

    if (mode === "set"){
      $("deltaNum").value = String(round0(iface.values[sel.varKey]));
      $("deltaRange").value = "0";
    }
  }

  /* ---------- Logging ---------- */
  function writeLog(info){
    const lines = [];
    lines.push(`Action #${state.step}`);
    lines.push(`Nudge: ${info.ifaceName} · ${info.varKey}`);
    lines.push(`Mode: ${info.mode} | Input: ${info.input} | Effective Δ: ${formatDelta(info.userDelta)}`);
    lines.push("");
    lines.push("Local coupling (total deltas on the chosen interface):");
    for (const v of VARS){
      const k = v.key;
      const d = info.localTotal[k];
      if (Math.abs(d) > 0.05) lines.push(`  - ${k}: ${formatDelta(d)}`);
    }

    lines.push("");
    lines.push(`Local ripple waves (iterations=${state.config.localIterations}):`);
    for (const w of info.waves){
      const parts = [];
      for (const v of VARS){
        const dv = round1(w.frontier[v.key]);
        if (Math.abs(dv) > 0.05){
          parts.push(`${v.key}:${formatDelta(dv)}`);
        }
      }
      lines.push(`  iter ${w.iter}: ${parts.length ? parts.join("  ") : "—"}`);
    }

    lines.push("");
    lines.push("Spillovers (to other interfaces):");
    for (const s of info.spillNotes){
      const tag = s.strong ? "shared party" : "weak tie";
      const fr = s.frictionApplied ? " | friction cap" : "";
      lines.push(`  → ${s.to} (${tag}, coeff≈${s.coeff}${fr})`);
      const dparts = [];
      for (const v of VARS){
        const dv = s.spill[v.key];
        if (Math.abs(dv) > 0.05) dparts.push(`${v.key}:${formatDelta(dv)}`);
      }
      lines.push(`     ${dparts.length ? dparts.join("  ") : "—"}`);
    }

    lines.push("");
    if (info.safetyHits.length){
      lines.push(`Safety valve triggered on: ${info.safetyHits.join(", ")}`);
      lines.push(`  Condition: Escalation < ${state.config.safetyEscalationThreshold} AND Ambiguity > ${state.config.safetyAmbiguityThreshold}`);
      lines.push(`  Penalty: −${state.config.safetyPenalty} Trust and −${state.config.safetyPenalty} Adaptability`);
    } else {
      lines.push("Safety valve: none");
    }

    $("log").textContent = lines.join("\n");
  }

  /* ---------- UI wiring ---------- */
  function wireTabs(){
    document.querySelectorAll(".tab").forEach(tab => {
      tab.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");

        const id = tab.dataset.tab;
        document.querySelectorAll(".view").forEach(v => v.classList.remove("active"));
        $(id).classList.add("active");
      });
    });
  }

  function wireControls(){
    $("ifaceSel").addEventListener("change", (e) => {
      state.selected.ifaceId = e.target.value;
      syncControlsToSelection(true);
      renderAll();
    });

    $("varSel").addEventListener("change", (e) => {
      state.selected.varKey = e.target.value;
      syncControlsToSelection(true);
      renderAll();
    });

    $("modeSel").addEventListener("change", () => {
      syncControlsToSelection(true);
    });

    // Link number + slider
    $("deltaRange").addEventListener("input", (e) => {
      if ($("modeSel").value === "delta"){
        $("deltaNum").value = e.target.value;
      }
    });
    $("deltaNum").addEventListener("input", (e) => {
      if ($("modeSel").value === "delta"){
        const v = Number(e.target.value);
        if (!Number.isNaN(v)) $("deltaRange").value = String(Math.max(-30, Math.min(30, v)));
      }
    });

    $("applyBtn").addEventListener("click", () => {
      const ifaceId = $("ifaceSel").value;
      const varKey = $("varSel").value;
      const mode = $("modeSel").value;
      const val = Number($("deltaNum").value);
      if (Number.isNaN(val)) return;

      runAction({ ifaceId, varKey, mode, value: val });
    });

    $("undoBtn").addEventListener("click", () => {
      if (!state.undoStack.length) return;
      const snap = state.undoStack.pop();
      restore(snap);
      renderAll();
      $("log").textContent = "Undo applied.";
    });

    $("resetBtn").addEventListener("click", () => {
      initInterfaces();
      // refresh controls
      $("modeSel").value = "delta";
      $("deltaNum").value = "10";
      $("deltaRange").value = "10";
      renderAll();
      $("log").textContent = "Reset to baseline.";
    });

    $("scenarioBtn").addEventListener("click", () => {
      const kind = $("scenarioSel").value;
      if (!kind) return;
      runScenario(kind);
    });

    $("showWeak").addEventListener("change", () => {
      renderNetwork();
    });

    // Mapping buttons
    $("copyJsonBtn").addEventListener("click", () => safeClipboardWrite($("jsonOut").value));
    $("downloadJsonBtn").addEventListener("click", () => downloadText("sharpcloud-mapping-pack.json", $("jsonOut").value));
    $("copyCsvBtn").addEventListener("click", () => safeClipboardWrite($("csvOut").value));
    $("downloadCsvBtn").addEventListener("click", () => downloadText("interface-maturity.csv", $("csvOut").value));

    $("exportStateBtn").addEventListener("click", () => {
      const payload = JSON.stringify({
        step: state.step,
        interfaces: state.interfaces,
        globalHistory: state.globalHistory,
        selected: state.selected,
        config: state.config
      }, null, 2);
      $("stateIO").value = payload;
    });

    $("loadStateBtn").addEventListener("click", () => {
      try{
        const obj = JSON.parse($("stateIO").value);
        // Basic validation
        if (!obj.interfaces || !Array.isArray(obj.interfaces)) throw new Error("Missing interfaces[]");
        if (!obj.config) throw new Error("Missing config");
        state.step = obj.step ?? 0;
        state.interfaces = obj.interfaces;
        state.globalHistory = obj.globalHistory ?? { avgMaturity: [], avgTrust: [] };
        state.selected = obj.selected ?? { ifaceId: state.interfaces[0]?.id, varKey: VARS[0].key };
        state.config = obj.config;
        state.undoStack = [];
        renderAll();
        $("log").textContent = "State loaded.";
      } catch(err){
        $("log").textContent = "Load failed: " + err.message;
      }
    });

    // Knobs
    $("iterRange").addEventListener("input", (e) => {
      $("iterNum").value = e.target.value;
    });
    $("iterNum").addEventListener("input", (e) => {
      const v = Math.max(1, Math.min(10, Number(e.target.value)));
      if (!Number.isNaN(v)) $("iterRange").value = String(v);
    });

    $("applyKnobsBtn").addEventListener("click", () => {
      const cfg = state.config;

      cfg.localIterations = Math.max(1, Math.min(10, Number($("iterNum").value) || 4));
      cfg.spilloverStrong = Number($("spillStrong").value);
      cfg.spilloverWeak = Number($("spillWeak").value);
      cfg.frictionAmbiguityThreshold = Number($("fricThresh").value);
      cfg.frictionPositiveFactor = Number($("fricFactor").value);
      cfg.safetyEscalationThreshold = Number($("svEsc").value);
      cfg.safetyAmbiguityThreshold = Number($("svAmb").value);
      cfg.safetyPenalty = Number($("svPen").value);

      // Edge coeffs
      const c_am_t = Number($("c_am_t").value);
      const c_am_e = Number($("c_am_e").value);
      const c_t_ad = Number($("c_t_ad").value);
      const c_t_s  = Number($("c_t_s").value);
      const c_s_am = Number($("c_s_am").value);

      cfg.localCouplingEdges = [
        { from: "Ambiguity", to: "Trust", coeff: c_am_t },
        { from: "Ambiguity", to: "EscalationReadiness", coeff: c_am_e },
        { from: "Trust", to: "Adaptability", coeff: c_t_ad },
        { from: "Trust", to: "SharedIncentives", coeff: c_t_s },
        { from: "SharedIncentives", to: "Ambiguity", coeff: c_s_am }
      ];

      renderAll();
      $("log").textContent = "Model knobs applied.";
    });
  }

  function primeKnobInputsFromConfig(){
    const cfg = state.config;
    $("iterRange").value = String(cfg.localIterations);
    $("iterNum").value = String(cfg.localIterations);
    $("spillStrong").value = String(cfg.spilloverStrong);
    $("spillWeak").value = String(cfg.spilloverWeak);
    $("fricThresh").value = String(cfg.frictionAmbiguityThreshold);
    $("fricFactor").value = String(cfg.frictionPositiveFactor);
    $("svEsc").value = String(cfg.safetyEscalationThreshold);
    $("svAmb").value = String(cfg.safetyAmbiguityThreshold);
    $("svPen").value = String(cfg.safetyPenalty);

    // edges
    const findEdge = (from,to) => cfg.localCouplingEdges.find(e=>e.from===from && e.to===to)?.coeff ?? 0;
    $("c_am_t").value = String(findEdge("Ambiguity","Trust"));
    $("c_am_e").value = String(findEdge("Ambiguity","EscalationReadiness"));
    $("c_t_ad").value = String(findEdge("Trust","Adaptability"));
    $("c_t_s").value  = String(findEdge("Trust","SharedIncentives"));
    $("c_s_am").value = String(findEdge("SharedIncentives","Ambiguity"));
  }

  /* ---------- Boot ---------- */
  function boot(){
    wireTabs();
    wireControls();
    primeKnobInputsFromConfig();
    renderAll();

    // prefill selection
    syncControlsToSelection(true);

    // small keyboard sugar: Enter applies
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (document.activeElement === $("deltaNum") || document.activeElement === $("deltaRange"))){
        $("applyBtn").click();
      }
    });
  }
  boot();
})();
</script>
</body>
</html>
