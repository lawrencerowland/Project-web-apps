<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GraphTransforms — Living Graph‑Transform Rescheduler (D3 demo)</title>
<link rel="preconnect" href="https://unpkg.com">
<link rel="icon" href="data:,">
<style>
  :root{
    --bg:#0b0f1a; --panel:#111726; --ink:#e6f1ff;
    --muted:#a9b7d3; --ok:#6ee7b7; --warn:#fbbf24; --bad:#fb7185; --edge:#2b3757;
    --accent:#7dd3fc; --accent2:#a78bfa;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0f1a 0%, #0d1324 100%);color:var(--ink);font:16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell}
  #app{display:grid;grid-template-columns:340px 1fr;grid-template-rows:auto 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
  header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:10px 14px}
  header h1{font-size:16px;margin:0}
  header .caps{opacity:.75;font-size:12px;letter-spacing:.06em}
  header .title{display:flex;flex-direction:column;gap:4px}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
  .tab-btn{cursor:pointer;border:1px solid rgba(255,255,255,0.14);background:transparent;border-radius:999px;padding:6px 12px;color:var(--ink);font-size:12px}
  .tab-btn.active{border-color:var(--accent);box-shadow:0 0 0 1px inset rgba(125,211,252,.25)}
  aside{
    background:rgba(255,255,255,0.04);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;
    padding:12px 12px 6px;
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:auto; /* so we never lose panels */
  }
  .panel{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.07);border-radius:10px;padding:10px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:6px 0}
  .row label{font-size:13px;color:var(--muted)}
  .btn{cursor:pointer;border:1px solid rgba(255,255,255,0.14);background:transparent;border-radius:10px;padding:8px 10px;color:var(--ink)}
  .btn:hover{border-color:var(--accent)}
  .btn.primary{border-color:var(--accent);box-shadow:0 0 0 1px inset rgba(125,211,252,.25)}
  .btn.danger:hover{border-color:var(--bad)}
  .legend{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 6px;border-radius:999px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08)}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.ok{background:var(--ok)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--bad)}
  .dot.base{background:var(--accent2)} .dot.root{background:var(--accent)}
  #cy{height:100%;min-height:70vh;width:100%;background:radial-gradient(ellipse at 50% -10%, #15203a 0%, #0b0f1a 60%);border:1px solid rgba(255,255,255,0.08);border-radius:12px}
  #sandboxCy{height:320px;width:100%;background:radial-gradient(ellipse at 50% -10%, #15203a 0%, #0b0f1a 60%);border:1px solid rgba(255,255,255,0.08);border-radius:12px}
  .graph-surface{width:100%;height:100%;display:block}
  .graph-bg{fill:transparent}
  .graph-node circle{stroke:#2b3757;stroke-width:2}
  .graph-node text{fill:#e6f1ff;font-size:12px;text-anchor:middle;pointer-events:none}
  .graph-node.selected circle{stroke:#7dd3fc;stroke-width:3;filter:drop-shadow(0 0 6px rgba(125,211,252,0.7))}
  .graph-node.stepping circle{stroke:#fbbf24;stroke-width:3;filter:drop-shadow(0 0 8px rgba(251,191,36,0.8))}
  .graph-edge{stroke:#2b3757}
  .graph-edge.edgeSelected{stroke:#7dd3fc}
  .graph-edge.critical{stroke:#fb7185}
  .edge-label{fill:rgba(230,241,255,0.75);font-size:10px;pointer-events:none;text-anchor:middle}
  .small{font-size:12px;color:var(--muted)}
  details{border:1px dashed rgba(255,255,255,0.12);border-radius:10px;padding:8px}
  summary{cursor:pointer;color:var(--accent)}
  input[type="range"]{width:100%}
  input[type="checkbox"]{transform: translateY(1px);}
  code{background:rgba(255,255,255,0.06);padding:2px 6px;border-radius:6px}
  textarea, select, input[type="text"], input[type="date"]{background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1);color:var(--ink);border-radius:8px;padding:8px;font-family:inherit}
  textarea{width:100%;min-height:120px;resize:vertical}
  .tab-pane{display:none;flex-direction:column;gap:10px}
  .tab-pane.active{display:flex}
  main.panel{display:flex;flex-direction:column}
  main.panel .tab-pane{flex:1}
  .split{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .pane{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:10px;padding:10px;min-height:200px}
  .pane pre{white-space:pre-wrap;font-size:12px;max-height:240px;overflow:auto}
  .audit-rail{display:flex;flex-direction:column;gap:8px}
  .audit-rail ol{margin:0;padding-left:18px;font-size:12px;color:var(--muted);max-height:160px;overflow:auto}
  .dropzone{border:1px dashed rgba(255,255,255,0.2);border-radius:10px;padding:10px;text-align:center;color:var(--muted);font-size:12px}
  .dropzone.dragover{border-color:var(--accent);color:var(--ink)}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;background:rgba(125,211,252,0.15);border:1px solid rgba(125,211,252,0.3);font-size:11px}
  .explainer{border:none;background:rgba(125,211,252,0.15);color:var(--ink);border-radius:999px;padding:2px 8px;font-size:11px;cursor:pointer}
  .explainer + .explain{display:none;margin-top:6px;font-size:12px;color:var(--muted)}
  .explain.show{display:block}
  .pill-grid{display:flex;flex-wrap:wrap;gap:6px}
  .pill-grid .pill{font-size:11px}
  .rail{display:flex;flex-direction:column;gap:6px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px}
  .strip{display:flex;flex-wrap:wrap;gap:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08);border-radius:10px;padding:8px}
  .hotspot{color:var(--warn)}

  /* Log */
  .log{
    max-height:180px;
    overflow:auto;
    border:1px solid rgba(255,255,255,0.09);
    padding:8px;
    background:rgba(0,0,0,0.15);
    border-radius:10px;
    font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  /* Explainer modal */
  .modal{
    position:fixed;
    inset:0;
    background:rgba(3,7,18,0.78);
    display:none;
    align-items:center;
    justify-content:center;
    padding:20px;
    z-index:40;
  }
  .modal .card{
    max-width:860px;
    width:100%;
    background:#0f1629;
    border:1px solid rgba(255,255,255,0.12);
    border-radius:16px;
    box-shadow:0 20px 60px rgba(0,0,0,0.55);
  }
  .modal .head{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .modal .body{
    padding:16px 18px 20px;
    max-height:60vh;
    overflow:auto;
  }
  .modal .head h2{
    font-size:18px;
    margin:0 0 4px;
  }
  .modal .meta{
    color:var(--muted);
    font-size:12px;
  }
  .close{
    border:1px solid rgba(255,255,255,0.2);
    background:transparent;
    color:var(--ink);
    width:32px;
    height:32px;
    border-radius:8px;
    font-size:18px;
    cursor:pointer;
  }
  .btn.grid{
    width:100%;
    text-align:left;
  }

  /* Selection styling handled via classes */
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">
      <h1>GraphTransforms — living graph‑transform rescheduler (D3)</h1>
      <div class="caps small">Drag nodes • Click a node or edge • Apply rewrite rules • Watch ripple + log</div>
    </div>
    <div class="tabs" role="tablist" aria-label="GraphTransforms tabs">
      <button class="tab-btn active" data-tab="rescheduler" role="tab" aria-selected="true">Rescheduler</button>
      <button class="tab-btn" data-tab="sandbox" role="tab" aria-selected="false">Graph‑Transform Sandbox</button>
      <button class="tab-btn" data-tab="scaffold" role="tab" aria-selected="false">DAG / Fibration Scaffold</button>
      <button class="tab-btn" data-tab="agents" role="tab" aria-selected="false">Agent Scenario Explorer</button>
    </div>
  </header>

  <aside>
    <div class="panel">
      <div class="row" style="margin-bottom:8px">
        <label>Living graph feature plan</label>
        <span class="small">Open any explainer</span>
      </div>
      <div style="display:grid;grid-template-columns:1fr;gap:8px">
        <button class="btn grid" data-explainer="primer">Primer: reversible graph rewrites</button>
        <button class="btn grid" data-explainer="why">Why this beats logs</button>
        <button class="btn grid" data-explainer="model">Minimal data model</button>
        <button class="btn grid" data-explainer="governance">Governance hooks</button>
        <button class="btn grid" data-explainer="ux">Digital twin diff UX</button>
        <button class="btn grid" data-explainer="rules">Rule design pattern</button>
        <button class="btn grid" data-explainer="storage">Storage &amp; verification</button>
        <button class="btn grid" data-explainer="pilot">Pilot plan for your stack</button>
        <button class="btn grid" data-explainer="deliverables">Next‑week demo deliverables</button>
        <button class="btn grid" data-explainer="coda">Tangential coda</button>
      </div>
    </div>
    <div class="tab-pane active" data-tab-pane="rescheduler">
      <!-- View / mode -->
      <div class="panel">
        <div class="row small">
          <span>View:</span>
          <select id="view" class="btn" style="flex:1">
            <option value="slip">Slip propagation (original)</option>
            <option value="schedule" selected>Schedule ES/EF (durations + lags)</option>
            <option value="both">Both (verbose)</option>
          </select>
        </div>
        <div class="row small">
          <span>Propagation rule:</span>
          <select id="rule" class="btn" style="flex:1">
            <option value="max">Finish‑to‑Start (max predecessor)</option>
            <option value="sum">Cumulative (sum of predecessors)</option>
            <option value="mean">Averaging (toy)</option>
          </select>
        </div>
        <div class="row small" style="justify-content:flex-start;gap:10px">
          <label style="margin:0;color:var(--muted)">
            <input id="animate" type="checkbox" checked />
            Animate rewrites (stepwise)
          </label>
        </div>
      </div>

      <!-- Node slip panel (kept from base app) -->
      <div class="panel">
        <div class="row"><label>Selected node:</label><strong id="sel">—</strong></div>
        <div class="row"><label>Slip days on selected</label></div>
        <div class="row">
          <input id="delay" type="range" min="0" max="30" step="1" value="0" />
          <span><strong id="delayVal">0d</strong></span>
        </div>
        <div class="row">
          <button class="btn primary" id="apply">Apply slip (rewrite)</button>
          <button class="btn" id="clear">Clear all slips</button>
        </div>
        <div class="row small">
          <span class="small">
            Tip: In schedule mode, slip is treated as a local start delay on that task/milestone.
          </span>
        </div>
      </div>

      <!-- Edge lag (rewrite rule) panel (new: ports the toy prototype's DelayEdge rules) -->
      <div class="panel">
        <div class="row"><label>Selected edge:</label><strong id="selEdge">—</strong></div>
        <div class="row small"><span>Current lag:</span><strong id="lagNow">—</strong></div>

        <div class="row"><label>Lag delta on selected edge</label></div>
        <div class="row">
          <input id="lagDelta" type="range" min="-10" max="10" step="1" value="0" />
          <span><strong id="lagDeltaVal">+0d</strong></span>
        </div>

        <div class="row">
          <button class="btn primary" id="applyLag">Apply DelayEdge (rewrite)</button>
          <button class="btn" id="resetAll">Reset all (slips + lags + log)</button>
        </div>

        <!-- Keep the toy prototype's "quick demo" rewrite buttons (adapted to this graph) -->
        <div class="row" style="flex-wrap:wrap;justify-content:flex-start">
          <button class="btn" id="delayAB">Rewrite: Delay edge A→B by +2d</button>
          <button class="btn" id="delayBC">Rewrite: Delay edge B→C by +1d</button>
        </div>

        <div class="row small">
          <span>
            These match the minimal prototype idea: apply a local delay on an edge and watch stepwise propagation.
          </span>
        </div>
      </div>

      <!-- Makespan + Log (ports the toy prototype's log + makespan readout) -->
      <div class="panel">
        <div class="row small">
          <span>Baseline makespan:</span><strong><span id="msBase">0</span>d</strong>
        </div>
        <div class="row small">
          <span>Current makespan:</span><strong><span id="msNow">0</span>d</strong>
        </div>
        <div class="row small">
          <span>Max lateness (colored):</span><strong><span id="maxSlip">0</span>d</strong>
        </div>
        <div class="row" style="margin-top:10px"><label>Rewrite log</label></div>
        <div id="log" class="log" aria-label="Rewrite log"></div>
      </div>

      <!-- Legend (kept) -->
      <div class="panel">
        <div class="legend">
          <span class="pill"><span class="dot root"></span> Entry / Tier‑1</span>
          <span class="pill"><span class="dot base"></span> Tier‑2/3/4</span>
          <span class="pill"><span class="dot ok"></span> On track (≤3d)</span>
          <span class="pill"><span class="dot warn"></span> Risk (4–10d)</span>
          <span class="pill"><span class="dot bad"></span> Late (>10d)</span>
        </div>
      </div>

      <!-- Explanations (kept + expanded; includes ALL explanation content from the toy prototype) -->
      <details class="panel">
        <summary>What you’re seeing</summary>
        <div class="small" style="margin-top:8px">
          <div style="margin-bottom:8px">
            Each node is a milestone/task with a <code>duration</code> and an optional local slip (start delay).
            Edges encode dependencies and can carry a <code>lag</code> (edge delay).
          </div>
          <div style="margin-bottom:8px">
            <strong>Slip propagation view (original):</strong><br/>
            We compute each node’s <code>effectiveSlip</code> as a transform of predecessor slips
            (<code>max | sum | mean</code>), add the local slip, and recolor nodes by lateness.
            This is a tiny “graph of transforms” you can swap for your project rules later.
          </div>
          <div style="margin-bottom:8px">
            <strong>Schedule ES/EF view (new):</strong><br/>
            We do a forward pass to compute <code>ES</code> (early start) and <code>EF</code> (early finish):
            <code>ES = aggregate(predecessor EF + edge lag)</code>, then <code>EF = ES + duration</code>,
            plus any local slip as a start delay. “Lateness” is shown as <code>EF − baselineEF</code>.
          </div>
          <div>
            <strong>Rewrite rules:</strong><br/>
            Applying a change (e.g., <code>DelayEdge</code> or a node slip) is treated as a graph rewrite.
            Instead of one opaque reschedule, you see a sequence of small, causal updates logged in topological order.
          </div>
        </div>
      </details>

      <details class="panel">
        <summary>Living graph‑transform framing (from the minimal prototype)</summary>
        <div class="small" style="margin-top:8px">
          <div style="margin-bottom:10px">
            Here’s a compact, practical way to think about project delivery as a <strong>living graph‑transform system</strong>:
            model your plan as a graph (tasks = nodes; dependencies/resources/interfaces = edges).
            Any change—design tweak, reallocation, delay—acts like a <strong>rewrite rule</strong> applied to a local neighborhood of that graph.
            Instead of one opaque reschedule, you see a <strong>sequence of small, causal updates</strong> that propagate only as far as they must.
          </div>
          <div style="margin-bottom:10px">
            <strong>Why this helps (plain English)</strong>
            <ul style="margin:6px 0 0 18px;padding:0">
              <li><strong>Local causes, visible effects:</strong> A change at node/edge X triggers only the dependent neighborhood; you can watch the ripple step by step.</li>
              <li><strong>What‑if as animation:</strong> Each rewrite is one animation “frame” (apply rule, then recompute downstream, then settle).</li>
              <li><strong>Governance receipts:</strong> Every rewrite is a signed event (rule used, scope touched, deltas produced), which is great for audit and explaining “why the dates moved.”</li>
            </ul>
          </div>
          <div>
            <strong>Minimal prototype idea (now embedded here):</strong>
            Click the “Rewrite: Delay edge …” buttons to see how a local delay on an edge propagates as a short rewrite sequence rather than a big jump.
          </div>
        </div>
      </details>

      <details class="panel">
        <summary>How you’d harden this for real projects</summary>
        <div class="small" style="margin-top:8px">
          <ul style="margin:6px 0 0 18px;padding:0">
            <li><strong>Rules library:</strong> <code>DelayEdge</code>, <code>AccelerateTask</code>, <code>ReassignResource</code>, <code>SplitTask</code>, <code>InsertBuffer</code>—each with explicit preconditions + postconditions.</li>
            <li><strong>Locality guarantees:</strong> limit propagation by <em>k</em> hops or by time window, then surface boundary conditions for human review.</li>
            <li><strong>Artifacts for governance:</strong> store each rewrite as a verifiable event (timestamp, author/agent, rationale, span), plus a “before/after” diff and a causal subgraph.</li>
            <li><strong>Visualization:</strong> animate the rewrite sequence and highlight only touched nodes/edges.</li>
            <li><strong>Interfaces‑aware:</strong> treat interfaces as typed edges; rules can target specific interface types (data handoff vs. permit vs. physical possession, etc.).</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="tab-pane" data-tab-pane="sandbox">
      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <strong>Graph‑Transform Sandbox</strong>
          <button class="explainer" data-explain="sandboxIntro">Why?</button>
        </div>
        <div id="sandboxIntro" class="explain">
          Explore composable transforms on a raw graph while keeping a live before/after diff and audit trail.
          This mirrors how change requests become explainable rewrites rather than opaque reschedules.
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Import nodes/edges JSON</label>
          <button class="explainer" data-explain="sandboxImport">How?</button>
        </div>
        <div id="sandboxImport" class="explain">
          Paste JSON, drop a file, or load the sample. Large graphs are fine; parsing runs once and we reuse the baseline for diffs.
        </div>
        <textarea id="sandboxInput" spellcheck="false" class="mono"></textarea>
        <div class="row">
          <button class="btn" id="sandboxSample">Load sample</button>
          <button class="btn primary" id="sandboxParse">Parse + Baseline</button>
        </div>
        <div class="dropzone" id="sandboxDrop">Drag & drop JSON here</div>
        <div class="row small">
          <span class="badge">Inputs: nodes[{id,label,tags?,owner?}], edges[{source,target,lag?,duration?}]</span>
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Filters</label>
          <button class="explainer" data-explain="sandboxFilters">What/Why?</button>
        </div>
        <div id="sandboxFilters" class="explain">
          Filter by type, tag, owner, or date to project a focused subgraph. Edges are auto-pruned to matching nodes.
        </div>
        <div class="row small"><span>Type</span><input id="filterType" type="text" placeholder="permit, scope, power" /></div>
        <div class="row small"><span>Tag</span><input id="filterTag" type="text" placeholder="interface, risk" /></div>
        <div class="row small"><span>Owner</span><input id="filterOwner" type="text" placeholder="team-a" /></div>
        <div class="row small"><span>Date range</span></div>
        <div class="row">
          <input id="filterStart" type="date" />
          <input id="filterEnd" type="date" />
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Contract / merge</label>
          <button class="explainer" data-explain="sandboxContract">How?</button>
        </div>
        <div id="sandboxContract" class="explain">
          Collapse nodes into lanes (owner/type) or a single interface tag. Edges are re-wired and durations are summed.
        </div>
        <div class="row">
          <select id="contractMode" style="flex:1">
            <option value="none">No contraction</option>
            <option value="owner">Merge by owner</option>
            <option value="type">Merge by type</option>
            <option value="tag">Merge by tag</option>
          </select>
        </div>
        <div class="row small">
          <span>Tag name</span>
          <input id="contractTag" type="text" placeholder="permit" />
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Transforms</label>
          <button class="explainer" data-explain="sandboxTransforms">What happens?</button>
        </div>
        <div id="sandboxTransforms" class="explain">
          Apply filters → optional merge → topo sort → critical-path annotation. Each run creates an audit entry you can undo/redo.
        </div>
        <div class="row">
          <button class="btn primary" id="sandboxApply">Apply transforms</button>
          <button class="btn" id="sandboxUndo">Undo</button>
          <button class="btn" id="sandboxRedo">Redo</button>
        </div>
        <div class="row small"><span id="sandboxSummary">No graph loaded.</span></div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Rewrite: dependency pruning</label>
          <button class="explainer" data-explain="sandboxPruning">Explain it</button>
        </div>
        <div id="sandboxPruning" class="explain">
          <p><strong>Goal:</strong> keep only the edges that can still influence a chosen output (milestone/goal node), and drop everything else.</p>
          <p><strong>Intuition:</strong> imagine shining a flashlight backward from the output. Every edge you can reach is “influential.” Anything not lit up can’t affect that output and is safe to prune.</p>
          <ol>
            <li>Pick outputs (e.g., tag nodes as <code>output</code> or <code>milestone</code> in your JSON).</li>
            <li>Walk backward along incoming edges to collect the dependency chain.</li>
            <li>Strip edges and nodes that are not on any path to those outputs.</li>
          </ol>
          <p class="small">Result: a tight causal subgraph you can explain in a single slide—“these are the only dependencies that can move this outcome.”</p>
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Rewrite: interface braiding</label>
          <button class="explainer" data-explain="sandboxBraiding">Explain it</button>
        </div>
        <div id="sandboxBraiding" class="explain">
          <p><strong>Goal:</strong> replace cross‑lane edges with explicit, typed interface nodes (scope/contract/permit/power) so coordination happens through a small, inspectable interface.</p>
          <p><strong>Intuition:</strong> think of braiding cables through a connector. Instead of every team wiring directly into every other team, they all plug into a shared interface node that declares the type of handoff.</p>
          <ol>
            <li>Detect edges that jump lanes (e.g., Engineering → Regulatory).</li>
            <li>Insert a typed interface node like <code>permit:EnvApproval</code> or <code>contract:GridTie</code>.</li>
            <li>Replace the cross‑lane edge with two local edges: <em>source → interface</em> and <em>interface → target</em>.</li>
          </ol>
          <p class="small">Result: fewer cross‑lane edges, clearer accountability, and a lower coordination degree because many links reuse the same interface node.</p>
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Interface archetypes</label>
          <button class="explainer" data-explain="sandboxArchetypes">Why?</button>
        </div>
        <div id="sandboxArchetypes" class="explain">
          Use the palette as a quick legend overlay for scope/contract/permit/power interfaces in review decks.
        </div>
        <div class="pill-grid">
          <span class="pill"><span class="dot ok"></span> Scope</span>
          <span class="pill"><span class="dot warn"></span> Contract</span>
          <span class="pill"><span class="dot bad"></span> Permit</span>
          <span class="pill"><span class="dot base"></span> Power</span>
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Export</label>
          <button class="explainer" data-explain="sandboxExport">How to use?</button>
        </div>
        <div id="sandboxExport" class="explain">
          Export JSON/CSV/DOT. Paste DOT into GraphViz or yEd. CSV follows activity_id, pred_id, lag for P6/SharpCloud workflows.
        </div>
        <div class="row">
          <button class="btn" id="exportJson">Copy JSON</button>
          <button class="btn" id="exportCsv">Copy CSV</button>
          <button class="btn" id="exportDot">Copy DOT</button>
        </div>
      </div>

      <details class="panel">
        <summary>Reuse notes (why this fits)</summary>
        <div class="small" style="margin-top:8px">
          <ul style="margin:6px 0 0 18px;padding:0">
            <li>Static HTML, ideal for GitHub Pages + bid packs.</li>
            <li>Outputs auditable artifacts: diff, receipts, DOT/CSV.</li>
            <li>Integrations: SharpCloud tags/owner lanes; P6 CSV (activity_id, pred_id, lag).</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="tab-pane" data-tab-pane="scaffold">
      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <strong>DAG / Fibration roadmap</strong>
          <span class="badge">Tests: 3 passing</span>
        </div>
        <div class="small">
          A compact scope pack: roadmap, three canonical Graphviz transforms, and an agent note on how to diff outputs.
        </div>
      </div>

      <div class="panel">
        <div class="row"><label>Repository assets</label></div>
        <div class="small">
          <ul style="margin:6px 0 0 18px;padding:0">
            <li><code>docs/living-graph-transform-roadmap.md</code> — DAG/fibration roadmap.</li>
            <li><code>samples/</code> — input/expected Graphviz pairs.</li>
            <li><code>.ai/agent-notes.md</code> — diff + test guidance.</li>
          </ul>
        </div>
      </div>

      <details class="panel">
        <summary>Why this combines cleanly</summary>
        <div class="small" style="margin-top:8px">
          <ul style="margin:6px 0 0 18px;padding:0">
            <li>Uses the same graph‑rewrite framing already in the sandbox tab.</li>
            <li>Supplies concrete DOT artifacts for deterministic “before → after” diffs.</li>
            <li>Extends the narrative from scheduling transforms to typed interface morphisms.</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="tab-pane" data-tab-pane="agents">
      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <strong>Agent‑Based Scenario Explorer</strong>
          <button class="explainer" data-explain="agentsIntro">Why?</button>
        </div>
        <div id="agentsIntro" class="explain">
          Model a swarm of tasks trading scarce resources and time windows, then compare policy receipts before/after tweaks.
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Presets</label>
          <button class="explainer" data-explain="agentsPresets">How?</button>
        </div>
        <div id="agentsPresets" class="explain">
          Load a preset, toggle the policy, and review where buffers collapse or swaps fail.
        </div>
        <div class="row">
          <select id="agentPreset" style="flex:1">
            <option value="permit">Permit drift</option>
            <option value="crane">Shared crane</option>
            <option value="design">Late design</option>
          </select>
          <button class="btn" id="loadPreset">Load</button>
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Policy</label>
          <button class="explainer" data-explain="agentsPolicy">What changes?</button>
        </div>
        <div id="agentsPolicy" class="explain">
          Strict keeps start windows fixed, liberal flexes by buffer, priority‑weighted favors tight‑buffer tasks first.
        </div>
        <div class="row">
          <select id="policyMode" style="flex:1">
            <option value="strict">Strict (no early starts)</option>
            <option value="liberal">Liberal (window flex)</option>
            <option value="priority">Priority‑weighted</option>
          </select>
          <button class="btn primary" id="runAgents">Run swaps</button>
        </div>
      </div>

      <div class="panel">
        <div class="row" style="align-items:center;gap:8px">
          <label>Task input</label>
          <button class="explainer" data-explain="agentsInput">Format?</button>
        </div>
        <div id="agentsInput" class="explain">
          tasks:[{id, window:[start,end], buffer, needs:[…], offers:[…]}], resources:[{id, cap, calendar}]
        </div>
        <textarea id="agentInput" spellcheck="false" class="mono"></textarea>
      </div>

      <details class="panel">
        <summary>Reuse notes (why this fits)</summary>
        <div class="small" style="margin-top:8px">
          <ul style="margin:6px 0 0 18px;padding:0">
            <li>Three demo presets: Permit drift, Shared crane, Late design.</li>
            <li>Outputs JSON trades + deficits + slack deltas; CSV for P6 constraints import.</li>
            <li>Governance strip: rule, conflicts, mitigations, lineage hash.</li>
          </ul>
        </div>
      </details>
    </div>
  </aside>

  <main class="panel" style="padding:8px">
    <div class="tab-pane active" data-tab-pane="rescheduler">
      <div id="cy"></div>
    </div>

    <div class="tab-pane" data-tab-pane="sandbox">
      <div class="pane">
        <div class="row"><strong>Network graph</strong><span class="small">Baseline / transformed view</span></div>
        <div id="sandboxCy" aria-label="Sandbox network graph"></div>
      </div>
      <div class="split">
        <div class="pane">
          <div class="row"><strong>Before</strong><span class="small">Baseline graph</span></div>
          <pre id="sandboxBefore" class="mono">Load or paste JSON to begin.</pre>
        </div>
        <div class="pane">
          <div class="row"><strong>After</strong><span class="small">Filtered + transformed</span></div>
          <pre id="sandboxAfter" class="mono">Apply transforms to see output.</pre>
        </div>
      </div>
      <div class="pane audit-rail">
        <div class="row">
          <strong>Audit rail</strong>
          <span class="small">Undo/redo keeps receipts of each transform run.</span>
        </div>
        <ol id="sandboxAudit"></ol>
      </div>
      <div class="pane">
        <div class="row"><strong>Export preview</strong><span class="small">JSON/CSV/DOT snapshots</span></div>
        <div class="split">
          <pre id="sandboxExportJson" class="mono"></pre>
          <pre id="sandboxExportDot" class="mono"></pre>
        </div>
        <pre id="sandboxExportCsv" class="mono"></pre>
      </div>
    </div>

    <div class="tab-pane" data-tab-pane="scaffold">
      <div class="pane">
        <div class="row">
          <strong>Graph Transforms Roadmap</strong>
          <span class="small">DAGs + fibrations → working scaffold</span>
        </div>
        <div class="small">
          <p><strong>Goal.</strong> Package three minimal DAG transforms for project control: dependency pruning, interface braiding, and variance‑aware critical path.</p>
          <p><strong>Why DAGs + fibrations?</strong> DAG = tasks & precedence. Fibrations are structured projections (tasks over lanes) that preserve interface morphisms.</p>
          <p><strong>MVP path.</strong> M0 sample pairs → M1 CLI → M2 PNG diffs → M3 fibration schema.</p>
        </div>
      </div>

      <div class="pane">
        <div class="row"><strong>Canonical transforms (Graphviz)</strong><span class="small">Input → expected output</span></div>
        <details class="panel" style="margin-top:8px">
          <summary>1) Dependency pruning</summary>
          <div class="split" style="margin-top:8px">
            <pre class="mono">digraph G {\n  // Keep only edges that affect target T\n  A -&gt; B; B -&gt; C; C -&gt; T;\n  A -&gt; D; D -&gt; E; // should be pruned if E !-&gt; T\n  X -&gt; Y;         // isolated component, prune\n  // cosmetic attrs:\n  node [shape=box];\n}</pre>
            <pre class="mono">digraph G {\n  node [shape=box];\n  A -&gt; B; B -&gt; C; C -&gt; T;\n  // Removed: A-&gt;D, D-&gt;E, X-&gt;Y\n}</pre>
          </div>
        </details>

        <details class="panel" style="margin-top:8px">
          <summary>2) Interface braiding</summary>
          <div class="split" style="margin-top:8px">
            <pre class="mono">digraph G {\n  // Teams (fibred lanes): Eng:{A,B,C}, Ops:{D,E}, Finance:{F}\n  // Interfaces are cross-lane edges that create churn.\n  subgraph cluster_Eng { label=&quot;Eng&quot;; A; B; C; }\n  subgraph cluster_Ops { label=&quot;Ops&quot;; D; E; }\n  subgraph cluster_Fin { label=&quot;Finance&quot;; F; }\n\n  A -&gt; B; B -&gt; C;           // intra-lane\n  C -&gt; D [label=&quot;handoff&quot;]; // cross-lane\n  D -&gt; E; E -&gt; F [label=&quot;cost&quot;]; // cross-lane\n}</pre>
            <pre class="mono">digraph G {\n  // Collapse cross-lane spans into typed interface nodes,\n  // preserving topological order but reducing inter-team degree.\n  subgraph cluster_Eng { label=&quot;Eng&quot;; A; B; C; }\n  subgraph cluster_Ops { label=&quot;Ops&quot;; D; E; }\n  subgraph cluster_Fin { label=&quot;Finance&quot;; F; }\n\n  A -&gt; B; B -&gt; C;\n  // Introduce braided interface nodes (type=handoff, type=cost)\n  I1 [shape=diamond, label=&quot;interface: handoff&quot;];\n  I2 [shape=diamond, label=&quot;interface: cost&quot;];\n\n  C -&gt; I1; I1 -&gt; D;\n  E -&gt; I2; I2 -&gt; F;\n}</pre>
          </div>
        </details>

        <details class="panel" style="margin-top:8px">
          <summary>3) Variance‑aware critical path</summary>
          <div class="split" style="margin-top:8px">
            <pre class="mono">digraph G {\n  // Durations (mean, variance). Use attrs: mean, var\n  A [mean=2, var=0.2];\n  B [mean=4, var=1.4];\n  C [mean=3, var=0.3];\n  D [mean=1, var=0.1];\n  T [mean=0, var=0.0, shape=doublecircle];\n\n  A -&gt; B; A -&gt; C; B -&gt; D; C -&gt; D; D -&gt; T;\n}</pre>
            <pre class="mono">digraph G {\n  // Highlight critical path by highest probability of maximal finish time.\n  // Here we choose the A-&gt;B-&gt;D-&gt;T branch (illustrative).\n  A [mean=2, var=0.2, penwidth=3];\n  B [mean=4, var=1.4, penwidth=3];\n  C [mean=3, var=0.3];\n  D [mean=1, var=0.1, penwidth=3];\n  T [mean=0, var=0.0, shape=doublecircle, penwidth=3];\n\n  A -&gt; B [penwidth=3];\n  A -&gt; C;\n  B -&gt; D [penwidth=3];\n  C -&gt; D;\n  D -&gt; T [penwidth=3];\n}</pre>
          </div>
        </details>
      </div>

      <div class="pane">
        <div class="row"><strong>Agent note: diffing transforms + proposing tests</strong></div>
        <div class="small">
          <ol style="margin:6px 0 0 18px;padding:0">
            <li>Parse DOT into nodes, edges, and attributes.</li>
            <li>Normalize: drop comments, sort identifiers, strip non-essential attrs.</li>
            <li>Compare node/edge multisets, then attribute deltas (e.g., <code>penwidth</code> mismatches).</li>
            <li>Optional render: <code>dot -Tpng</code> for visual diffs.</li>
          </ol>
          <p style="margin-top:8px">Edge cases to propose: multiple targets, chained cross‑lane edges, variance ties with equal means.</p>
        </div>
      </div>
    </div>

    <div class="tab-pane" data-tab-pane="agents">
      <div class="pane">
        <div class="row"><strong>Scenario outputs</strong><span class="small">Trades + deficits + slack deltas</span></div>
        <pre id="agentOutput" class="mono">Load a preset and run swaps.</pre>
      </div>
      <div class="split">
        <div class="pane">
          <div class="row"><strong>Temporal‑coupling hotspots</strong></div>
          <div id="agentHotspots" class="rail small">None yet.</div>
        </div>
        <div class="pane">
          <div class="row"><strong>Rule receipts (before → after)</strong></div>
          <div id="agentReceipts" class="rail small">No receipts yet.</div>
        </div>
      </div>
      <div class="pane">
        <div class="row"><strong>Governance strip</strong></div>
        <div id="agentStrip" class="strip small"></div>
      </div>
      <div class="pane">
        <div class="row"><strong>P6 constraints CSV</strong></div>
        <pre id="agentCsv" class="mono"></pre>
      </div>
    </div>
  </main>
</div>

<div class="modal" id="explainerModal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="explainerTitle">
  <div class="card">
    <div class="head">
      <div>
        <h2 id="explainerTitle">Explainer</h2>
        <div class="meta" id="explainerSubtitle"></div>
      </div>
      <button class="close" id="closeExplainer" aria-label="Close">×</button>
    </div>
    <div class="body" id="explainerBody"></div>
  </div>
</div>

<!-- D3.js -->
<script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>

<script>
(function(){
  // -----------------------------
  // Sample multi‑tier milestone graph (change freely)
  // -----------------------------
  const NODES = [
    { id:'A', label:'A: Concept Freeze', tier:1, dur:3 },
    { id:'B', label:'B: Design Gate',   tier:2, dur:4 },
    { id:'C', label:'C: Procurement',   tier:2, dur:5 },
    { id:'D', label:'D: Site Ready',    tier:3, dur:3 },
    { id:'E', label:'E: Install',       tier:3, dur:4 },
    { id:'F', label:'F: Commission',    tier:3, dur:2 },
    { id:'G', label:'G: Handover',      tier:4, dur:1 }
  ];

  // Edges with baseline lag0 (initial), and mutable lag (current).
  // Added B->C so the prototype's B→C rewrite button is real in this graph.
  const EDGES0 = [
    ['A','B'], ['A','C'], ['B','C'],
    ['B','D'], ['C','E'],
    ['D','F'], ['E','F'],
    ['F','G']
  ];

  // -----------------------------
  // State
  // -----------------------------
  const state = {
    view: 'schedule',       // 'slip' | 'schedule' | 'both'
    rule: 'max',            // 'max' | 'sum' | 'mean'
    animate: true,

    selectedNode: null,
    selectedEdge: null,

    localSlip: Object.fromEntries(NODES.map(n => [n.id, 0])),

    baseline: {
      rule: null,
      es: {},
      ef: {},
      makespan: 0
    },

    last: {
      slipToy: {},          // previous slip-propagation values
      schedule: { es:{}, ef:{} } // previous ES/EF values
    }
  };

  const nodes = NODES.map(n => ({
    ...n,
    color: baseFill(n.tier),
    renderLabel: n.label
  }));
  const edges = EDGES0.map(([s,t]) => ({
    id: `${s}->${t}`,
    source: s,
    target: t,
    lag0: 0,
    lag: 0,
    w: 2,
    renderLabel: 'lag 0d'
  }));
  const nodeById = new Map(nodes.map(n => [n.id, n]));
  const edgeById = new Map(edges.map(e => [e.id, e]));

  function edgeSourceId(edge){
    return typeof edge.source === 'object' ? edge.source.id : edge.source;
  }
  function edgeTargetId(edge){
    return typeof edge.target === 'object' ? edge.target.id : edge.target;
  }

  function createGraphRenderer({ container, nodeRadius = 24, linkDistance = 160, fontSize = 12, showEdgeLabels = true, onNodeClick, onEdgeClick, onBackgroundClick } = {}){
    const handlers = {
      onNodeClick: onNodeClick || null,
      onEdgeClick: onEdgeClick || null,
      onBackgroundClick: onBackgroundClick || null
    };
    const selection = d3.select(container);
    const svg = selection.append('svg').attr('class', 'graph-surface');
    const background = svg.append('rect').attr('class', 'graph-bg');
    const defs = svg.append('defs');
    const markerId = `arrow-${Math.random().toString(36).slice(2, 8)}`;
    defs.append('marker')
      .attr('id', markerId)
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', nodeRadius + 10)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#2b3757');

    const zoomGroup = svg.append('g').attr('class', 'graph-layer');
    const linkLayer = zoomGroup.append('g').attr('class', 'graph-links');
    const labelLayer = zoomGroup.append('g').attr('class', 'graph-link-labels');
    const nodeLayer = zoomGroup.append('g').attr('class', 'graph-nodes');

    if(!showEdgeLabels){
      labelLayer.style('display', 'none');
    }

    let width = 0;
    let height = 0;
    let dataNodes = [];
    let dataEdges = [];

    const zoom = d3.zoom()
      .scaleExtent([0.4, 2.5])
      .on('zoom', (event) => {
        zoomGroup.attr('transform', event.transform);
      });
    svg.call(zoom);

    const simulation = d3.forceSimulation()
      .force('link', d3.forceLink().id(d => d.id).distance(linkDistance).strength(0.12))
      .force('charge', d3.forceManyBody().strength(-420))
      .force('center', d3.forceCenter(0, 0))
      .force('collision', d3.forceCollide(nodeRadius + 8));

    let linkSel = linkLayer.selectAll('line');
    let labelSel = labelLayer.selectAll('text');
    let nodeSel = nodeLayer.selectAll('g');

    function resize(){
      const bounds = container.getBoundingClientRect();
      width = bounds.width || 800;
      height = bounds.height || 400;
      svg.attr('width', width).attr('height', height);
      background.attr('width', width).attr('height', height);
      simulation.force('center', d3.forceCenter(width / 2, height / 2));
      simulation.alpha(0.2).restart();
    }

    function updateNodeLabels(selection){
      selection.each(function(d){
        const textSel = d3.select(this).select('text');
        const lines = String(d.renderLabel || d.label || d.id).split('\n');
        textSel
          .attr('y', -(lines.length - 1) * (fontSize * 0.55))
          .selectAll('tspan')
          .data(lines, (line, i) => `${d.id}-${i}`)
          .join(
            enter => enter.append('tspan'),
            update => update,
            exit => exit.remove()
          )
          .attr('x', 0)
          .attr('dy', (line, i) => (i === 0 ? 0 : fontSize * 1.1))
          .text(line => line);
      });
    }

    function updateEdges(){
      linkSel
        .classed('edgeSelected', d => !!d.isSelected)
        .classed('critical', d => !!d.isCritical)
        .attr('stroke-width', d => d.isSelected ? 4 : (d.w || 2))
        .attr('stroke', d => d.isSelected ? '#7dd3fc' : (d.isCritical ? '#fb7185' : '#2b3757'))
        .attr('marker-end', d => d.isSelected ? `url(#${markerId})` : `url(#${markerId})`);
      labelSel.text(d => d.renderLabel || '');
    }

    function updateNodes(nodesSubset){
      const selection = nodesSubset ? nodeSel.filter(d => nodesSubset.includes(d)) : nodeSel;
      selection
        .classed('selected', d => !!d.isSelected)
        .classed('stepping', d => !!d.isStepping);
      selection.select('circle').attr('fill', d => d.color || '#1b2440');
      updateNodeLabels(selection);
    }

    function ticked(){
      linkSel
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);
      labelSel
        .attr('x', d => (d.source.x + d.target.x) / 2)
        .attr('y', d => (d.source.y + d.target.y) / 2);
      nodeSel.attr('transform', d => `translate(${d.x},${d.y})`);
    }

    function setData(nodesData, edgesData){
      dataNodes = nodesData || [];
      dataEdges = edgesData || [];

      linkSel = linkLayer.selectAll('line')
        .data(dataEdges, d => d.id)
        .join(enter => (
          enter.append('line')
            .attr('class', 'graph-edge')
            .attr('marker-end', `url(#${markerId})`)
            .on('click', (event, d) => {
              event.stopPropagation();
              if(handlers.onEdgeClick) handlers.onEdgeClick(d);
            })
        ));

      labelSel = labelLayer.selectAll('text')
        .data(dataEdges, d => d.id)
        .join(enter => (
          enter.append('text')
            .attr('class', 'edge-label')
        ));

      nodeSel = nodeLayer.selectAll('g')
        .data(dataNodes, d => d.id)
        .join(enter => {
          const gNode = enter.append('g').attr('class', 'graph-node');
          gNode.append('circle').attr('r', nodeRadius);
          gNode.append('text').attr('class', 'node-label');
          gNode.call(
            d3.drag()
              .on('start', (event, d) => {
                if(!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
              })
              .on('drag', (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
              })
              .on('end', (event, d) => {
                if(!event.active) simulation.alphaTarget(0);
                d.fx = event.x;
                d.fy = event.y;
              })
          );
          gNode.on('click', (event, d) => {
            event.stopPropagation();
            if(handlers.onNodeClick) handlers.onNodeClick(d);
          });
          return gNode;
        });

      simulation.nodes(dataNodes).on('tick', ticked);
      simulation.force('link').links(dataEdges);
      simulation.alpha(1).restart();
      updateEdges();
      updateNodes();
    }

    function centerOn(id){
      const node = typeof id === 'string' ? dataNodes.find(n => n.id === id) : id;
      if(!node || !Number.isFinite(node.x) || !Number.isFinite(node.y)) return;
      const transform = d3.zoomIdentity.translate(width / 2 - node.x, height / 2 - node.y);
      svg.transition().duration(500).call(zoom.transform, transform);
    }

    function fit(padding = 40){
      if(!dataNodes.length) return;
      const xs = dataNodes.map(n => n.x || 0);
      const ys = dataNodes.map(n => n.y || 0);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const dx = maxX - minX || 1;
      const dy = maxY - minY || 1;
      const scale = Math.min(width / (dx + padding * 2), height / (dy + padding * 2), 2.2);
      const translateX = width / 2 - scale * (minX + maxX) / 2;
      const translateY = height / 2 - scale * (minY + maxY) / 2;
      const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
      svg.transition().duration(400).call(zoom.transform, transform);
    }

    function clear(){
      setData([], []);
    }

    background.on('click', () => {
      if(handlers.onBackgroundClick) handlers.onBackgroundClick();
    });

    resize();

    return {
      setData,
      updateEdges,
      updateNodes,
      resize,
      centerOn,
      fit,
      clear,
      setHandlers: (nextHandlers = {}) => {
        handlers.onNodeClick = nextHandlers.onNodeClick || handlers.onNodeClick;
        handlers.onEdgeClick = nextHandlers.onEdgeClick || handlers.onEdgeClick;
        handlers.onBackgroundClick = nextHandlers.onBackgroundClick || handlers.onBackgroundClick;
      }
    };
  }

  const mainGraph = createGraphRenderer({
    container: document.getElementById('cy'),
    nodeRadius: 26,
    linkDistance: 170,
    onNodeClick: selectNode,
    onEdgeClick: selectEdge,
    onBackgroundClick: () => {
      selectNode(null);
      selectEdge(null);
    }
  });
  mainGraph.setData(nodes, edges);

  // -----------------------------
  // UI
  // -----------------------------
  const selEl       = document.getElementById('sel');
  const delayInput  = document.getElementById('delay');
  const delayVal    = document.getElementById('delayVal');
  const applyBtn    = document.getElementById('apply');
  const clearBtn    = document.getElementById('clear');

  const selEdgeEl   = document.getElementById('selEdge');
  const lagNowEl    = document.getElementById('lagNow');
  const lagDeltaInp = document.getElementById('lagDelta');
  const lagDeltaVal = document.getElementById('lagDeltaVal');
  const applyLagBtn = document.getElementById('applyLag');
  const resetAllBtn = document.getElementById('resetAll');

  const delayABBtn  = document.getElementById('delayAB');
  const delayBCBtn  = document.getElementById('delayBC');

  const ruleSel     = document.getElementById('rule');
  const viewSel     = document.getElementById('view');
  const animChk     = document.getElementById('animate');

  const logEl       = document.getElementById('log');
  const msBaseEl    = document.getElementById('msBase');
  const msNowEl     = document.getElementById('msNow');
  const maxSlipEl   = document.getElementById('maxSlip');

  const explainerModal = document.getElementById('explainerModal');
  const explainerTitle = document.getElementById('explainerTitle');
  const explainerSubtitle = document.getElementById('explainerSubtitle');
  const explainerBody = document.getElementById('explainerBody');
  const closeExplainer = document.getElementById('closeExplainer');
  const explainerButtons = document.querySelectorAll('[data-explainer]');

  const EXPLAINERS = {
    primer: {
      title: 'Primer (plain terms)',
      subtitle: 'Reversible graph rewrite system for a digital twin.',
      body: `
        <p>Here’s a compact idea you can use right away: treat your digital twin as a <strong>reversible graph‑rewrite system</strong>, so every change is a proof object.</p>
        <p><strong>Graph:</strong> nodes = assets/actors/artifacts; edges = relationships (flows, dependencies, contracts).</p>
        <p><strong>Rewrite rule:</strong> a small pattern you match and replace (e.g., “Split WorkPackage A into A1/A2; redirect dependencies”).</p>
        <p><strong>Reversible:</strong> every rule has an inverse; applying inverse + forward nets identity. This gives you lineage + provable diffs.</p>
        <p><strong>Rule receipt:</strong> every edge/node rewrite emits a receipt (who/what/why/when), so the audit trail is natively visual—not a spreadsheet.</p>
        <div class="small" style="margin-top:10px">
          Think of each change as a tiny, explainable move rather than a single opaque reschedule.
        </div>
      `
    },
    why: {
      title: 'Why this beats logs',
      subtitle: 'Diff-as-morphism governance + deterministic replay.',
      body: `
        <ul>
          <li><strong>Diff as morphism:</strong> a twin’s change is the composition of rule receipts; governance = checking that composition against policy.</li>
          <li><strong>Lineage first:</strong> any element shows its ancestry (which rule chain created it) and obligations (which policies were consulted).</li>
          <li><strong>Deterministic replay:</strong> “What happened?” becomes a click-through movie, not narrative notes.</li>
        </ul>
      `
    },
    model: {
      title: 'Minimal data model',
      subtitle: 'The smallest set of objects to support receipts + replay.',
      body: `
        <ul>
          <li><strong>Graph:</strong> typed nodes/edges, versioned.</li>
          <li><strong>Rule:</strong> LHS pattern, RHS construction, pre/post-conditions, policy hooks.</li>
          <li><strong>Receipt:</strong> RuleID, actor, timestamp, inputs, outputs, policy decisions, hash of LHS/RHS.</li>
          <li><strong>Trace:</strong> ordered list of Receipts; <code>State_t = apply(Trace[0..t], State_0)</code>.</li>
        </ul>
      `
    },
    governance: {
      title: 'Governance hooks (where compliance lives)',
      subtitle: 'Pre-conditions, obligations, and stakeholder projections.',
      body: `
        <ul>
          <li><strong>Pre-conditions:</strong> “H&amp;S review present”, “RACI owner exists”, “contractual cap not exceeded”.</li>
          <li><strong>Obligation tags:</strong> attach obligations to receipts (e.g., CDM, NEC clause, data-retention class).</li>
          <li><strong>Selective projection:</strong> produce stakeholder views (risk, commercial, H&amp;S) by filtering receipts + subgraphs.</li>
        </ul>
      `
    },
    ux: {
      title: 'Digital twin diff UX',
      subtitle: 'Timeline scrub, edge diffs, and explain-this-node.',
      body: `
        <ul>
          <li><strong>Timeline scrubber:</strong> drag to any <em>t</em> to materialize <code>State_t</code>.</li>
          <li><strong>Edge-diff overlay:</strong> green = added, red = removed, amber = rewired; click opens receipt card.</li>
          <li><strong>Explain this node:</strong> show proof-of-change chain (receipts as a path).</li>
          <li><strong>Policy pane:</strong> show satisfied/failed checks with links to documents.</li>
        </ul>
      `
    },
    rules: {
      title: 'Rule design pattern (sketch)',
      subtitle: 'Small, invertible rewrites with pre/post checks.',
      body: `
        <pre class="mini" style="white-space:pre-wrap">rule SplitWorkPackage(A):
  match: Node(A:type=WP) with edges deps_in, deps_out
  require: approvals.contains("PM"); risk_register(A).status != "red"
  rewrite:
    create A1,A2:type=WP; partition scope(A) -> (A1,A2)
    rewire deps_out based on new WBS split
  post: baseline.delta.cost <= threshold
  inverse: MergeWorkPackage(A1,A2)  // generated automatically</pre>
        <p class="small">Inverse rules can be generated automatically so replay and undo are provably correct.</p>
      `
    },
    storage: {
      title: 'Storage & verification',
      subtitle: 'Receipts that are content-addressed, signed, and replayable.',
      body: `
        <ul>
          <li><strong>Content-address receipts:</strong> hash of LHS/RHS + metadata.</li>
          <li><strong>Sign receipts:</strong> actor key; append to immutable trace (Merkle-linked).</li>
          <li><strong>Determinism:</strong> rules are pure; graph state is the only input, so replay is exact.</li>
        </ul>
      `
    },
    pilot: {
      title: 'How to pilot in your stack',
      subtitle: 'A staged plan that doesn’t disrupt existing features.',
      body: `
        <ol>
          <li><strong>Scope:</strong> pick 3–5 rules (Split/Merge WP, Retire Asset, Reroute Dependency, Change Contractor).</li>
          <li><strong>Adapter:</strong> map SharpCloud/yFiles/Graphistry items to a typed graph; keep canonical state in a small graph store.</li>
          <li><strong>Receipts first:</strong> implement receipt logger before UI; assert invertibility and replay on CI.</li>
          <li><strong>Projections:</strong> build one “Risk” and one “Commercial” projection from the same receipts.</li>
          <li><strong>Policy stubs:</strong> start with boolean checks; upgrade to policy DB callouts later.</li>
        </ol>
      `
    },
    deliverables: {
      title: 'Deliverables you can show next week',
      subtitle: 'Minimal demo scope with maximum clarity.',
      body: `
        <ul>
          <li>A tiny graph demo with timeline scrubber, node “explain”, and a rule-receipt JSON export.</li>
          <li>A 1-page “Rule Receipt Spec” + 3 sample receipts (split, reroute, retire) forming a composed diff.</li>
        </ul>
      `
    },
    coda: {
      title: 'Tangential coda',
      subtitle: 'Category-theoretic framing in one line.',
      body: `
        <p>This reframes the program as a category of states and reversible morphisms. Auditing becomes functorial.</p>
      `
    }
  };
  const tabButtons = document.querySelectorAll('.tab-btn');
  const tabPanes = document.querySelectorAll('[data-tab-pane]');
  const explainButtons = document.querySelectorAll('.explainer');

  const sandboxInput = document.getElementById('sandboxInput');
  const sandboxSampleBtn = document.getElementById('sandboxSample');
  const sandboxParseBtn = document.getElementById('sandboxParse');
  const sandboxDrop = document.getElementById('sandboxDrop');
  const sandboxApplyBtn = document.getElementById('sandboxApply');
  const sandboxUndoBtn = document.getElementById('sandboxUndo');
  const sandboxRedoBtn = document.getElementById('sandboxRedo');
  const sandboxSummary = document.getElementById('sandboxSummary');
  const sandboxBefore = document.getElementById('sandboxBefore');
  const sandboxAfter = document.getElementById('sandboxAfter');
  const sandboxAudit = document.getElementById('sandboxAudit');
  const exportJsonBtn = document.getElementById('exportJson');
  const exportCsvBtn = document.getElementById('exportCsv');
  const exportDotBtn = document.getElementById('exportDot');
  const sandboxExportJson = document.getElementById('sandboxExportJson');
  const sandboxExportCsv = document.getElementById('sandboxExportCsv');
  const sandboxExportDot = document.getElementById('sandboxExportDot');
  const sandboxCyEl = document.getElementById('sandboxCy');
  const filterType = document.getElementById('filterType');
  const filterTag = document.getElementById('filterTag');
  const filterOwner = document.getElementById('filterOwner');
  const filterStart = document.getElementById('filterStart');
  const filterEnd = document.getElementById('filterEnd');
  const contractMode = document.getElementById('contractMode');
  const contractTag = document.getElementById('contractTag');

  const agentPreset = document.getElementById('agentPreset');
  const loadPresetBtn = document.getElementById('loadPreset');
  const policyMode = document.getElementById('policyMode');
  const runAgentsBtn = document.getElementById('runAgents');
  const agentInput = document.getElementById('agentInput');
  const agentOutput = document.getElementById('agentOutput');
  const agentHotspots = document.getElementById('agentHotspots');
  const agentReceipts = document.getElementById('agentReceipts');
  const agentStrip = document.getElementById('agentStrip');
  const agentCsv = document.getElementById('agentCsv');

  function logLine(msg){
    const t = new Date();
    const stamp = t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    const div = document.createElement('div');
    div.textContent = `[${stamp}] ${msg}`;
    logEl.prepend(div);
  }

  function openExplainer(key){
    const item = EXPLAINERS[key];
    if(!item) return;
    explainerTitle.textContent = item.title;
    explainerSubtitle.textContent = item.subtitle;
    explainerBody.innerHTML = item.body;
    explainerModal.style.display = 'flex';
    explainerModal.setAttribute('aria-hidden', 'false');
  }

  function closeExplainerModal(){
    explainerModal.style.display = 'none';
    explainerModal.setAttribute('aria-hidden', 'true');
  }

  explainerButtons.forEach(btn => {
    btn.addEventListener('click', () => openExplainer(btn.dataset.explainer));
  });
  closeExplainer.addEventListener('click', closeExplainerModal);
  explainerModal.addEventListener('click', (event) => {
    if(event.target === explainerModal){
      closeExplainerModal();
    }
  });
  function setActiveTab(tab){
    tabButtons.forEach(btn => {
      const active = btn.dataset.tab === tab;
      btn.classList.toggle('active', active);
      btn.setAttribute('aria-selected', active ? 'true' : 'false');
    });
    tabPanes.forEach(pane => {
      pane.classList.toggle('active', pane.dataset.tabPane === tab);
    });
    if(tab === 'sandbox'){
      requestAnimationFrame(() => {
        sandboxGraph.resize();
        sandboxGraph.fit();
      });
    }
  }

  tabButtons.forEach(btn => {
    btn.addEventListener('click', () => setActiveTab(btn.dataset.tab));
  });

  explainButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const targetId = btn.dataset.explain;
      const el = document.getElementById(targetId);
      if(el){
        el.classList.toggle('show');
      }
    });
  });

  // -----------------------------
  // Selection handlers
  // -----------------------------
  function selectNode(n){
    if(state.selectedNode){
      state.selectedNode.isSelected = false;
    }
    state.selectedNode = n || null;

    if(state.selectedNode){
      state.selectedNode.isSelected = true;
      const id = state.selectedNode.id;
      selEl.textContent = `${id} (${state.selectedNode.label})`;
      delayInput.value = state.localSlip[id] || 0;
      delayVal.textContent = `${delayInput.value}d`;
    }else{
      selEl.textContent = '—';
    }
    mainGraph.updateNodes();
  }

  function selectEdge(e){
    if(state.selectedEdge){
      state.selectedEdge.isSelected = false;
    }
    state.selectedEdge = e || null;

    if(state.selectedEdge){
      state.selectedEdge.isSelected = true;
      const id = state.selectedEdge.id;
      selEdgeEl.textContent = id;
      const lag = state.selectedEdge.lag || 0;
      const lag0 = state.selectedEdge.lag0 || 0;
      const deltaFromBase = lag - lag0;
      lagNowEl.textContent = `${lag}d (base ${lag0}d, Δ ${deltaFromBase>=0?'+':''}${deltaFromBase}d)`;
    }else{
      selEdgeEl.textContent = '—';
      lagNowEl.textContent = '—';
    }
    mainGraph.updateEdges();
  }

  mainGraph.setData(nodes, edges);
  mainGraph.resize();
  mainGraph.updateNodes();
  mainGraph.updateEdges();

  delayInput.addEventListener('input', () => {
    delayVal.textContent = `${delayInput.value}d`;
  });

  lagDeltaInp.addEventListener('input', () => {
    const v = parseInt(lagDeltaInp.value, 10) || 0;
    lagDeltaVal.textContent = `${v>=0?'+':''}${v}d`;
  });

  animChk.addEventListener('change', () => {
    state.animate = !!animChk.checked;
  });

  viewSel.addEventListener('change', () => {
    state.view = viewSel.value;
    // no rule application here; just re-render with current computed values
    recomputeAndRender({ logUpdates:false, stepwise:false });
  });

  ruleSel.addEventListener('change', () => {
    state.rule = ruleSel.value;
    // rule affects both propagation and baseline schedule
    ensureBaseline();
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });
  });

  // -----------------------------
  // Rewrite rules: node slip (existing feature kept) + edge lag (new)
  // -----------------------------
  applyBtn.addEventListener('click', () => {
    if(!state.selectedNode) return;
    const id = state.selectedNode.id;
    const v = parseInt(delayInput.value, 10) || 0;
    state.localSlip[id] = v;

    logLine(`Rule: SetLocalSlip(${id}, ${v}d) applied.`);
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });
  });

  clearBtn.addEventListener('click', () => {
    Object.keys(state.localSlip).forEach(k => state.localSlip[k] = 0);
    logLine('Rule: ClearAllLocalSlips() applied.');
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });

    if(state.selectedNode){
      delayInput.value = 0;
      delayVal.textContent = '0d';
    }
  });

  applyLagBtn.addEventListener('click', () => {
    if(!state.selectedEdge) return;
    const delta = parseInt(lagDeltaInp.value, 10) || 0;
    if(delta === 0) return;

    applyDelayEdge(state.selectedEdge.id, delta, { label: `DelayEdge(${state.selectedEdge.id}, ${delta>=0?'+':''}${delta}d)` });
    // reset delta UI back to 0 for convenience
    lagDeltaInp.value = 0;
    lagDeltaVal.textContent = '+0d';
  });

  resetAllBtn.addEventListener('click', () => {
    // Reset lags to baseline and local slips to 0, clear log.
    logEl.innerHTML = '';
    edges.forEach(e => { e.lag = e.lag0 || 0; });
    Object.keys(state.localSlip).forEach(k => state.localSlip[k] = 0);

    logLine('Rule: ResetAll(slips + lags + log) applied.');
    ensureBaseline(true); // recompute baseline from lag0 and current rule
    recomputeAndRender({ logUpdates:true, stepwise:false });

    if(state.selectedNode){
      delayInput.value = 0;
      delayVal.textContent = '0d';
    }
    if(state.selectedEdge){
      selectEdge(state.selectedEdge); // refresh lag display
    }
  });

  delayABBtn.addEventListener('click', () => {
    applyDelayEdge('A->B', +2, { label: 'DelayEdge(A→B, +2d)' });
  });

  delayBCBtn.addEventListener('click', () => {
    applyDelayEdge('B->C', +1, { label: 'DelayEdge(B→C, +1d)' });
  });

  function applyDelayEdge(edgeId, delta, {label} = {}){
    const e = edgeById.get(edgeId);
    if(!e){
      logLine(`Rule: DelayEdge(${edgeId}) failed (edge not found).`);
      return;
    }
    const prev = e.lag || 0;
    e.lag = prev + delta;

    logLine(`Rule: ${label || `DelayEdge(${edgeId}, ${delta}d)`} applied.`);
    // Update edge selection panel if this is selected
    if(state.selectedEdge && state.selectedEdge.id === edgeId){
      selectEdge(state.selectedEdge);
    }
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });
  }

  // -----------------------------
  // Graph‑Transform Sandbox
  // -----------------------------
  const SANDBOX_SAMPLE = {
    nodes: [
      { id:'S1', label:'Scope draft', tags:['scope'], owner:'PMO', type:'scope', date:'2025-02-01' },
      { id:'S2', label:'Permit check', tags:['permit','risk'], owner:'Reg', type:'permit', date:'2025-02-05' },
      { id:'S3', label:'Contract gate', tags:['contract'], owner:'Legal', type:'contract', date:'2025-02-10' },
      { id:'S4', label:'Power interface', tags:['power','interface'], owner:'Utilities', type:'power', date:'2025-02-12' },
      { id:'S5', label:'Design pack', tags:['design'], owner:'Eng', type:'scope', date:'2025-02-15' }
    ],
    edges: [
      { source:'S1', target:'S2', duration:2, lag:1 },
      { source:'S2', target:'S3', duration:3, lag:0 },
      { source:'S3', target:'S4', duration:4, lag:1 },
      { source:'S3', target:'S5', duration:2, lag:0 },
      { source:'S5', target:'S4', duration:1, lag:0 }
    ]
  };

  const sandboxGraph = createGraphRenderer({
    container: sandboxCyEl,
    nodeRadius: 20,
    linkDistance: 140,
    fontSize: 11
  });

  function renderSandboxGraph(graph, critical){
    if(!graph){
      sandboxGraph.clear();
      return;
    }
    const sandboxNodes = graph.nodes.map(node => ({
      id: node.id,
      label: node.label || node.id,
      renderLabel: node.label || node.id,
      color: '#1b2440'
    }));
    const sandboxEdges = graph.edges.map(edge => {
      const id = `${edge.source}->${edge.target}`;
      return {
        id,
        source: edge.source,
        target: edge.target,
        lag: edge.lag || 0,
        duration: edge.duration || 0,
        w: critical && critical.criticalEdges.has(id) ? 3 : 2,
        renderLabel: `lag ${edge.lag || 0}d, dur ${edge.duration || 0}d`,
        isCritical: critical && critical.criticalEdges.has(id)
      };
    });
    sandboxGraph.setData(sandboxNodes, sandboxEdges);
    setTimeout(() => sandboxGraph.fit(), 250);
  }

  const sandboxState = {
    original: null,
    current: null,
    history: [],
    historyIndex: -1,
    lastSummary: null,
    lastCritical: null
  };

  function normalizeGraph(raw){
    if(!raw || !Array.isArray(raw.nodes) || !Array.isArray(raw.edges)){
      throw new Error('Invalid graph JSON: expected {nodes:[], edges:[]}');
    }
    const nodes = raw.nodes.map(n => ({
      id: String(n.id),
      label: n.label || String(n.id),
      tags: Array.isArray(n.tags) ? n.tags.map(t => String(t)) : [],
      owner: n.owner ? String(n.owner) : '',
      type: n.type ? String(n.type) : '',
      date: n.date ? String(n.date) : ''
    }));
    const edges = raw.edges.map(e => ({
      source: String(e.source),
      target: String(e.target),
      lag: Number.isFinite(+e.lag) ? +e.lag : 0,
      duration: Number.isFinite(+e.duration) ? +e.duration : 0
    }));
    return { nodes, edges };
  }

  function parseSandboxInput(text){
    const parsed = JSON.parse(text);
    return normalizeGraph(parsed);
  }

  function buildGraphIndex(graph){
    const nodeIds = graph.nodes.map(n => n.id);
    const preds = Object.fromEntries(nodeIds.map(id => [id, []]));
    const succs = Object.fromEntries(nodeIds.map(id => [id, []]));
    graph.edges.forEach(e => {
      if(preds[e.target]){
        preds[e.target].push(e);
      }
      if(succs[e.source]){
        succs[e.source].push(e);
      }
    });
    const inDeg = Object.fromEntries(nodeIds.map(id => [id, preds[id].length]));
    const queue = nodeIds.filter(id => inDeg[id] === 0);
    const order = [];
    while(queue.length){
      const u = queue.shift();
      order.push(u);
      succs[u].forEach(edge => {
        const v = edge.target;
        inDeg[v]--;
        if(inDeg[v] === 0) queue.push(v);
      });
    }
    return { nodeIds, preds, succs, order, hasCycle: order.length !== nodeIds.length };
  }

  function applyFilters(graph){
    const typeVal = filterType.value.trim().toLowerCase();
    const tagVal = filterTag.value.trim().toLowerCase();
    const ownerVal = filterOwner.value.trim().toLowerCase();
    const startVal = filterStart.value ? new Date(filterStart.value) : null;
    const endVal = filterEnd.value ? new Date(filterEnd.value) : null;

    const nodes = graph.nodes.filter(n => {
      if(typeVal && (n.type || '').toLowerCase() !== typeVal) return false;
      if(tagVal && !(n.tags || []).some(t => t.toLowerCase().includes(tagVal))) return false;
      if(ownerVal && (n.owner || '').toLowerCase() !== ownerVal) return false;
      if(startVal || endVal){
        if(!n.date) return false;
        const d = new Date(n.date);
        if(startVal && d < startVal) return false;
        if(endVal && d > endVal) return false;
      }
      return true;
    });
    const nodeIds = new Set(nodes.map(n => n.id));
    const edges = graph.edges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));
    return { nodes, edges };
  }

  function contractGraph(graph){
    const mode = contractMode.value;
    const tagName = contractTag.value.trim();
    if(mode === 'none'){
      return { graph, note:'No contraction' };
    }

    const mapping = {};
    const groups = new Map();
    const tagLower = tagName.toLowerCase();

    graph.nodes.forEach(node => {
      let key = node.id;
      if(mode === 'owner' && node.owner){
        key = `owner:${node.owner}`;
      } else if(mode === 'type' && node.type){
        key = `type:${node.type}`;
      } else if(mode === 'tag' && tagLower && node.tags.some(t => t.toLowerCase() === tagLower)){
        key = `tag:${tagName}`;
      }
      mapping[node.id] = key;
      if(!groups.has(key)){
        groups.set(key, []);
      }
      groups.get(key).push(node);
    });

    const mergedNodes = [];
    groups.forEach((nodes, key) => {
      if(nodes.length === 1 && nodes[0].id === key){
        mergedNodes.push(nodes[0]);
        return;
      }
      const tags = [...new Set(nodes.flatMap(n => n.tags || []))];
      const owners = [...new Set(nodes.map(n => n.owner).filter(Boolean))];
      const types = [...new Set(nodes.map(n => n.type).filter(Boolean))];
      mergedNodes.push({
        id: key,
        label: `${key} (${nodes.length})`,
        tags,
        owner: owners.join(','),
        type: types.join(','),
        members: nodes.map(n => n.id)
      });
    });

    const edgeMap = new Map();
    graph.edges.forEach(e => {
      const source = mapping[e.source] || e.source;
      const target = mapping[e.target] || e.target;
      if(source === target) return;
      const id = `${source}->${target}`;
      if(!edgeMap.has(id)){
        edgeMap.set(id, { source, target, lag: 0, duration: 0, count: 0 });
      }
      const entry = edgeMap.get(id);
      entry.lag += e.lag || 0;
      entry.duration += e.duration || 0;
      entry.count += 1;
    });

    return { graph: { nodes: mergedNodes, edges: [...edgeMap.values()] }, note:`Contracted by ${mode}` };
  }

  function computeCriticalPath(graph){
    const idx = buildGraphIndex(graph);
    const dist = Object.fromEntries(idx.nodeIds.map(id => [id, 0]));
    const prevEdge = {};

    idx.order.forEach(id => {
      (idx.succs[id] || []).forEach(edge => {
        const weight = (edge.duration || 0) + (edge.lag || 0);
        const cand = dist[id] + weight;
        if(cand >= dist[edge.target]){
          dist[edge.target] = cand;
          prevEdge[edge.target] = edge;
        }
      });
    });

    const endNode = idx.nodeIds.reduce((maxId, id) => dist[id] > dist[maxId] ? id : maxId, idx.nodeIds[0] || '');
    const criticalEdges = new Set();
    let cursor = endNode;
    while(prevEdge[cursor]){
      const edge = prevEdge[cursor];
      criticalEdges.add(`${edge.source}->${edge.target}`);
      cursor = edge.source;
    }

    return { criticalEdges, criticalLength: dist[endNode] || 0, order: idx.order, hasCycle: idx.hasCycle };
  }

  function buildSandboxSummary(graph, critical){
    if(!graph){
      return 'No graph loaded.';
    }
    const summary = `${graph.nodes.length} nodes, ${graph.edges.length} edges, topo order ${critical.order.length} nodes`;
    const cycleNote = critical.hasCycle ? ' (cycle detected)' : '';
    const orderPreview = critical.order.slice(0, 6).join(' → ');
    const orderNote = orderPreview ? ` • topo ${orderPreview}${critical.order.length > 6 ? ' …' : ''}` : '';
    return `${summary}${cycleNote} • critical path ${critical.criticalLength}d${orderNote}`;
  }

  function buildExports(graph, critical){
    if(!graph){
      return { json:'', csv:'', dot:'' };
    }
    const json = JSON.stringify(graph, null, 2);
    const csvLines = ['activity_id,pred_id,lag,duration,critical'];
    graph.edges.forEach(edge => {
      const id = `${edge.source}->${edge.target}`;
      csvLines.push(`${edge.target},${edge.source},${edge.lag || 0},${edge.duration || 0},${critical.criticalEdges.has(id) ? 'yes' : 'no'}`);
    });
    const dotLines = ['digraph G {', '  rankdir=LR;'];
    graph.nodes.forEach(node => {
      dotLines.push(`  "${node.id}" [label="${node.label}"];`);
    });
    graph.edges.forEach(edge => {
      const id = `${edge.source}->${edge.target}`;
      const criticalFlag = critical.criticalEdges.has(id);
      const color = criticalFlag ? 'color="red", penwidth=2' : '';
      const label = `label="lag ${edge.lag || 0}d, dur ${edge.duration || 0}d"`;
      dotLines.push(`  "${edge.source}" -> "${edge.target}" [${label}${color ? ', ' + color : ''}];`);
    });
    dotLines.push('}');

    return { json, csv: csvLines.join('\n'), dot: dotLines.join('\n') };
  }

  function pushSandboxHistory(entry){
    if(sandboxState.historyIndex < sandboxState.history.length - 1){
      sandboxState.history = sandboxState.history.slice(0, sandboxState.historyIndex + 1);
    }
    sandboxState.history.push(entry);
    sandboxState.historyIndex = sandboxState.history.length - 1;
  }

  function updateSandboxUI(){
    if(!sandboxState.current){
      sandboxBefore.textContent = 'Load or paste JSON to begin.';
      sandboxAfter.textContent = 'Apply transforms to see output.';
      sandboxSummary.textContent = 'No graph loaded.';
      sandboxAudit.innerHTML = '';
      sandboxExportJson.textContent = '';
      sandboxExportCsv.textContent = '';
      sandboxExportDot.textContent = '';
      renderSandboxGraph(null, null);
      return;
    }
    sandboxBefore.textContent = JSON.stringify(sandboxState.original, null, 2);
    sandboxAfter.textContent = JSON.stringify(sandboxState.current, null, 2);
    sandboxSummary.textContent = sandboxState.lastSummary || 'Transforms applied.';
    sandboxAudit.innerHTML = '';
    sandboxState.history.forEach((entry, index) => {
      const li = document.createElement('li');
      li.textContent = `${entry.label} ${index === sandboxState.historyIndex ? '• current' : ''}`;
      sandboxAudit.appendChild(li);
    });
    if(sandboxState.lastExports){
      sandboxExportJson.textContent = sandboxState.lastExports.json;
      sandboxExportCsv.textContent = sandboxState.lastExports.csv;
      sandboxExportDot.textContent = sandboxState.lastExports.dot;
    }
    renderSandboxGraph(sandboxState.current, sandboxState.lastCritical);
  }

  function applySandboxTransforms(){
    if(!sandboxState.original){
      sandboxSummary.textContent = 'Parse a graph first.';
      return;
    }
    const filtered = applyFilters(sandboxState.original);
    const { graph: contracted, note } = contractGraph(filtered);
    const critical = computeCriticalPath(contracted);
    const summary = buildSandboxSummary(contracted, critical);
    const exports = buildExports(contracted, critical);

    sandboxState.current = contracted;
    sandboxState.lastSummary = summary;
    sandboxState.lastExports = exports;
    sandboxState.lastCritical = critical;
    pushSandboxHistory({
      label: `Transform: ${note} + filters + critical path`,
      graph: contracted
    });
    updateSandboxUI();
  }

  function resetSandboxFromHistory(){
    const entry = sandboxState.history[sandboxState.historyIndex];
    if(entry){
      sandboxState.current = entry.graph;
      const critical = computeCriticalPath(entry.graph);
      sandboxState.lastSummary = buildSandboxSummary(entry.graph, critical);
      sandboxState.lastExports = buildExports(entry.graph, critical);
      sandboxState.lastCritical = critical;
      updateSandboxUI();
    }
  }

  sandboxSampleBtn.addEventListener('click', () => {
    sandboxInput.value = JSON.stringify(SANDBOX_SAMPLE, null, 2);
  });

  sandboxParseBtn.addEventListener('click', () => {
    try{
      const graph = parseSandboxInput(sandboxInput.value);
      sandboxState.original = graph;
      sandboxState.current = graph;
      const critical = computeCriticalPath(graph);
      sandboxState.lastSummary = buildSandboxSummary(graph, critical);
      sandboxState.lastExports = buildExports(graph, critical);
      sandboxState.lastCritical = critical;
      sandboxState.history = [];
      pushSandboxHistory({ label:'Baseline loaded', graph });
      updateSandboxUI();
    }catch(err){
      sandboxSummary.textContent = err.message;
    }
  });

  sandboxApplyBtn.addEventListener('click', applySandboxTransforms);
  sandboxUndoBtn.addEventListener('click', () => {
    if(sandboxState.historyIndex > 0){
      sandboxState.historyIndex -= 1;
      resetSandboxFromHistory();
    }
  });
  sandboxRedoBtn.addEventListener('click', () => {
    if(sandboxState.historyIndex < sandboxState.history.length - 1){
      sandboxState.historyIndex += 1;
      resetSandboxFromHistory();
    }
  });

  [exportJsonBtn, exportCsvBtn, exportDotBtn].forEach((btn, idx) => {
    btn.addEventListener('click', async () => {
      if(!sandboxState.lastExports) return;
      const payloads = [sandboxState.lastExports.json, sandboxState.lastExports.csv, sandboxState.lastExports.dot];
      const text = payloads[idx];
      if(navigator.clipboard && text){
        try{
          await navigator.clipboard.writeText(text);
          sandboxSummary.textContent = 'Copied export to clipboard.';
        }catch(err){
          sandboxSummary.textContent = 'Clipboard copy blocked. Use manual copy from the preview.';
        }
      }else if(text){
        sandboxSummary.textContent = 'Clipboard unavailable. Use manual copy from the preview.';
      }
    });
  });

  sandboxDrop.addEventListener('dragover', evt => {
    evt.preventDefault();
    sandboxDrop.classList.add('dragover');
  });
  sandboxDrop.addEventListener('dragleave', () => sandboxDrop.classList.remove('dragover'));
  sandboxDrop.addEventListener('drop', evt => {
    evt.preventDefault();
    sandboxDrop.classList.remove('dragover');
    const file = evt.dataTransfer.files[0];
    if(file){
      const reader = new FileReader();
      reader.onload = () => {
        sandboxInput.value = reader.result;
      };
      reader.readAsText(file);
    }
  });

  // -----------------------------
  // Agent‑Based Scenario Explorer
  // -----------------------------
  const AGENT_PRESETS = {
    permit: {
      tasks: [
        { id:'A1', window:[1,6], buffer:2, needs:['permit'], offers:['design'] },
        { id:'A2', window:[4,9], buffer:1, needs:['design'], offers:['permit'] },
        { id:'A3', window:[6,10], buffer:2, needs:['permit'], offers:[] }
      ],
      resources: [{ id:'permit', cap:1, calendar:'weekdays' }, { id:'design', cap:1, calendar:'weekdays' }]
    },
    crane: {
      tasks: [
        { id:'C1', window:[2,7], buffer:1, needs:['crane'], offers:['lift'] },
        { id:'C2', window:[5,9], buffer:1, needs:['lift'], offers:['crane'] },
        { id:'C3', window:[3,8], buffer:0, needs:['crane'], offers:[] }
      ],
      resources: [{ id:'crane', cap:1, calendar:'shift' }, { id:'lift', cap:1, calendar:'shift' }]
    },
    design: {
      tasks: [
        { id:'D1', window:[1,5], buffer:1, needs:['design'], offers:['review'] },
        { id:'D2', window:[4,10], buffer:2, needs:['review'], offers:['design'] },
        { id:'D3', window:[6,12], buffer:1, needs:['design'], offers:[] }
      ],
      resources: [{ id:'design', cap:1, calendar:'weekdays' }, { id:'review', cap:1, calendar:'weekdays' }]
    }
  };

  function parseAgentInput(text){
    const parsed = JSON.parse(text);
    if(!Array.isArray(parsed.tasks) || !Array.isArray(parsed.resources)){
      throw new Error('Invalid input: expected tasks[] and resources[].');
    }
    return parsed;
  }

  function effectiveWindow(task, policy){
    const [start, end] = task.window;
    const buffer = task.buffer || 0;
    if(policy === 'liberal'){
      return [start - buffer, end + buffer];
    }
    if(policy === 'priority'){
      return [start - Math.floor(buffer * 0.5), end + Math.floor(buffer * 0.5)];
    }
    return [start, end];
  }

  function overlapWindow(a, b){
    return Math.max(0, Math.min(a[1], b[1]) - Math.max(a[0], b[0]));
  }

  function simulateAgents(input, policy){
    const tasks = input.tasks.map(t => ({ ...t }));
    const trades = [];
    const deficits = [];
    const slackDeltas = {};
    const offerUsed = new Set();

    const ordered = [...tasks].sort((a, b) => (policy === 'priority' ? (a.buffer || 0) - (b.buffer || 0) : 0));

    ordered.forEach(task => {
      const windowEff = effectiveWindow(task, policy);
      const baseSlack = (task.window[1] - task.window[0]);
      const effSlack = (windowEff[1] - windowEff[0]);
      slackDeltas[task.id] = effSlack - baseSlack;

      (task.needs || []).forEach(need => {
        const match = ordered.find(other => other.id !== task.id && (other.offers || []).includes(need) && !offerUsed.has(`${other.id}:${need}`) && overlapWindow(windowEff, effectiveWindow(other, policy)) > 0);
        if(match){
          offerUsed.add(`${match.id}:${need}`);
          trades.push({
            from: match.id,
            to: task.id,
            resource: need,
            overlap: overlapWindow(windowEff, effectiveWindow(match, policy))
          });
        }else{
          deficits.push({ task: task.id, resource: need, window: windowEff });
        }
      });
    });

    return { trades, deficits, slackDeltas };
  }

  function buildReceipts(baseline, current, policy){
    return [
      `Baseline (strict): trades ${baseline.trades.length}, deficits ${baseline.deficits.length}`,
      `Policy (${policy}): trades ${current.trades.length}, deficits ${current.deficits.length}`
    ];
  }

  function buildHotspots(deficits){
    if(!deficits.length) return ['No hotspots detected.'];
    return deficits.map(d => `Task ${d.task} lacks ${d.resource} in window ${d.window[0]}–${d.window[1]}`);
  }

  function hashString(str){
    let hash = 0;
    for(let i = 0; i < str.length; i++){
      hash = (hash << 5) - hash + str.charCodeAt(i);
      hash |= 0;
    }
    return `hx${Math.abs(hash)}`;
  }

  function updateAgentUI(output, baseline, policy){
    agentOutput.textContent = JSON.stringify({
      policy,
      trades: output.trades,
      residual_deficits: output.deficits,
      slack_deltas: output.slackDeltas
    }, null, 2);

    agentHotspots.innerHTML = '';
    buildHotspots(output.deficits).forEach(line => {
      const div = document.createElement('div');
      div.textContent = line;
      if(output.deficits.length){
        div.classList.add('hotspot');
      }
      agentHotspots.appendChild(div);
    });

    agentReceipts.innerHTML = '';
    buildReceipts(baseline, output, policy).forEach(line => {
      const div = document.createElement('div');
      div.textContent = line;
      agentReceipts.appendChild(div);
    });

    const lineage = hashString(agentOutput.textContent);
    agentStrip.innerHTML = '';
    [
      `Rule: ${policy}`,
      `Conflicts surfaced: ${output.deficits.length}`,
      `Mitigations chosen: ${output.trades.length}`,
      `Lineage hash: ${lineage}`
    ].forEach(item => {
      const span = document.createElement('span');
      span.className = 'badge';
      span.textContent = item;
      agentStrip.appendChild(span);
    });
  }

  function buildAgentCsv(output){
    const lines = ['activity_id,constraint_type,constraint_date,slack_delta'];
    Object.entries(output.slackDeltas).forEach(([taskId, delta]) => {
      lines.push(`${taskId},WINDOW,0,${delta}`);
    });
    output.deficits.forEach(def => {
      lines.push(`${def.task},NEEDS_${def.resource},${def.window[1]},-1`);
    });
    return lines.join('\n');
  }

  function loadPreset(name){
    const preset = AGENT_PRESETS[name];
    if(preset){
      agentInput.value = JSON.stringify(preset, null, 2);
    }
  }

  loadPreset(agentPreset.value);

  loadPresetBtn.addEventListener('click', () => loadPreset(agentPreset.value));
  runAgentsBtn.addEventListener('click', () => {
    try{
      const input = parseAgentInput(agentInput.value);
      const policy = policyMode.value;
      const baseline = simulateAgents(input, 'strict');
      const output = simulateAgents(input, policy);
      updateAgentUI(output, baseline, policy);
      agentCsv.textContent = buildAgentCsv(output);
    }catch(err){
      agentOutput.textContent = err.message;
    }
  });

  // -----------------------------
  // GraphTransforms core utilities
  // -----------------------------
  function buildIndex(){
    const nodeIds = nodes.map(n => n.id);
    const preds = {};
    const predsIds = {};
    const succs = {};
    nodeIds.forEach(id => { preds[id]=[]; predsIds[id]=[]; succs[id]=[]; });

    edges.forEach(e => {
      const s = edgeSourceId(e);
      const t = edgeTargetId(e);
      if(!preds[t] || !succs[s]) return;
      preds[t].push({ p:s, edge:e });
      predsIds[t].push(s);
      succs[s].push(t);
    });

    // Kahn topo sort
    const inDeg = {};
    nodeIds.forEach(id => inDeg[id] = predsIds[id].length);
    const Q = [];
    nodeIds.forEach(id => { if(inDeg[id] === 0) Q.push(id); });

    const order = [];
    while(Q.length){
      const u = Q.shift();
      order.push(u);
      succs[u].forEach(v => {
        inDeg[v]--;
        if(inDeg[v] === 0) Q.push(v);
      });
    }

    const hasCycle = order.length !== nodeIds.length;
    return { nodeIds, preds, predsIds, succs, order, hasCycle };
  }

  function aggregate(values, rule){
    if(!values.length) return 0;
    if(rule === 'max')  return Math.max(...values);
    if(rule === 'sum')  return values.reduce((a,b)=>a+b,0);
    if(rule === 'mean') return Math.round(values.reduce((a,b)=>a+b,0) / values.length);
    return 0;
  }

  // Colors
  function baseFill(tier){
    return tier===1 ? '#7dd3fc' : '#a78bfa';
  }
  function riskFill(tier, slip){
    const base = baseFill(tier);
    if(slip <= 3)  return mix(base, '#6ee7b7', 0.35); // ok tint
    if(slip <= 10) return mix(base, '#fbbf24', 0.35); // warn
    return mix(base, '#fb7185', 0.35);                // bad
  }
  function mix(aHex, bHex, t){
    const a = hexToRgb(aHex), b = hexToRgb(bHex);
    const c = { r:lerp(a.r,b.r,t), g:lerp(a.g,b.g,t), b:lerp(a.b,b.b,t) };
    return `rgb(${c.r|0},${c.g|0},${c.b|0})`;
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function hexToRgb(h){
    if(h[0] === '#') h = h.slice(1);
    if(h.length === 3) h = h.split('').map(x=>x+x).join('');
    const n = parseInt(h,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }

  // -----------------------------
  // Baseline schedule (for lateness = EF - baselineEF)
  // -----------------------------
  function ensureBaseline(force=false){
    if(!force && state.baseline.rule === state.rule) return;

    const idx = buildIndex();
    if(idx.hasCycle){
      logLine('Baseline warning: graph has a cycle; baseline ES/EF may be incomplete.');
    }

    const baseES = {};
    const baseEF = {};
    idx.order.forEach(id => {
      const dur = (nodeById.get(id)?.dur || 0);
      const candidates = idx.preds[id].map(({p, edge}) => (baseEF[p] || 0) + (edge.lag0 || 0));
      const es = aggregate(candidates, state.rule);
      baseES[id] = es;
      baseEF[id] = es + dur;
    });

    const baseMs = Math.max(0, ...Object.values(baseEF));
    state.baseline = { rule: state.rule, es: baseES, ef: baseEF, makespan: baseMs };
  }

  // -----------------------------
  // Compute + render
  // -----------------------------
  function recomputeAndRender({logUpdates=false, stepwise=false} = {}){
    ensureBaseline();

    const idx = buildIndex();
    if(idx.hasCycle){
      logLine('Warning: graph has a cycle; propagation order is partial.');
    }

    // 1) Original slip propagation (kept)
    const slipToy = {};
    idx.order.forEach(id => {
      const incoming = idx.predsIds[id].map(p => slipToy[p] ?? 0);
      const agg = aggregate(incoming, state.rule);
      slipToy[id] = (state.localSlip[id] || 0) + agg;
    });

    // 2) Schedule ES/EF with durations + edge lags (ports the toy prototype's ES/EF idea)
    const es = {};
    const ef = {};
    idx.order.forEach(id => {
      const dur = (nodeById.get(id)?.dur || 0);
      const candidates = idx.preds[id].map(({p, edge}) => (ef[p] || 0) + (edge.lag || 0));
      const start = aggregate(candidates, state.rule) + (state.localSlip[id] || 0);
      es[id] = start;
      ef[id] = start + dur;
    });
    const msNow = Math.max(0, ...Object.values(ef));

    // lateness in schedule mode is EF - baselineEF
    const slipSched = {};
    idx.order.forEach(id => slipSched[id] = (ef[id] || 0) - (state.baseline.ef[id] || 0));

    // choose what drives coloring
    const slipForColorById = (state.view === 'slip')
      ? slipToy
      : slipSched;

    const maxSlip = Math.max(0, ...idx.nodeIds.map(id => slipForColorById[id] || 0));

    // prepare log messages for "stepwise rewrite" feel
    const scheduleUpdateMsgById = {};
    if(logUpdates){
      idx.order.forEach(id => {
        const prevES = state.last.schedule.es[id];
        const prevEF = state.last.schedule.ef[id];
        if(prevES !== es[id] || prevEF !== ef[id]){
          scheduleUpdateMsgById[id] = `Rewrite: updated ${id} -> ES ${es[id]}  EF ${ef[id]}`;
        }
      });
    }

    // edge render data (lag labels + widths)
    edges.forEach(e => {
      const lag = e.lag || 0;
      const lag0 = e.lag0 || 0;
      const delta = lag - lag0;
      const deltaStr = delta === 0 ? '' : ` (Δ ${delta>=0?'+':''}${delta}d)`;
      e.renderLabel = `lag ${lag}d${deltaStr}`;

      // edge thickness by downstream slip gradient (kept concept, adapted)
      const s = slipForColorById[edgeSourceId(e)] || 0;
      const t = slipForColorById[edgeTargetId(e)] || 0;
      const w = 1.5 + Math.max(0, t - s) * 0.15;
      e.w = w;
    });
    mainGraph.updateEdges();

    // update makespan / slip readouts
    msBaseEl.textContent = `${state.baseline.makespan || 0}`;
    msNowEl.textContent = `${msNow}`;
    maxSlipEl.textContent = `${maxSlip}`;

    // Render nodes either instantly or stepwise (animation frames)
    if(stepwise){
      renderNodesStepwise(idx.order, {
        slipToy, es, ef, slipSched, slipForColorById, scheduleUpdateMsgById
      });
    }else{
      renderNodesInstant(idx.nodeIds, {
        slipToy, es, ef, slipSched, slipForColorById
      });
      // dump log updates in one shot (still ordered)
      if(logUpdates){
        idx.order.forEach(id => {
          if(scheduleUpdateMsgById[id]) logLine(scheduleUpdateMsgById[id]);
        });
      }
    }

    // persist "previous" snapshots for next diff
    state.last.slipToy = {...slipToy};
    state.last.schedule = { es:{...es}, ef:{...ef} };

    // refresh edge panel readout if an edge is selected
    if(state.selectedEdge){
      selectEdge(state.selectedEdge);
    }
  }

  function renderNodesInstant(nodeIds, ctx){
    nodeIds.forEach(id => applyNodeRender(id, ctx));
    mainGraph.updateNodes();
  }

  function renderNodesStepwise(order, ctx){
    // clear any prior stepping highlight
    nodes.forEach(n => { n.isStepping = false; });
    mainGraph.updateNodes();

    const delayMs = 140;
    let i = 0;

    function step(){
      // finished
      if(i >= order.length){
        // remove highlight shortly after end
        setTimeout(() => {
          nodes.forEach(node => { node.isStepping = false; });
          mainGraph.updateNodes();
        }, 300);
        return;
      }

      const id = order[i];
      const n = nodeById.get(id);

      // log in causal/topo order as the animation proceeds
      if(ctx.scheduleUpdateMsgById && ctx.scheduleUpdateMsgById[id]){
        logLine(ctx.scheduleUpdateMsgById[id]);
      }

      // apply node render and pulse highlight
      nodes.forEach(node => { node.isStepping = false; });
      applyNodeRender(id, ctx);
      if(n){
        n.isStepping = true;
      }
      mainGraph.updateNodes();

      i++;
      setTimeout(step, delayMs);
    }
    step();
  }

  function applyNodeRender(id, {slipToy, es, ef, slipSched, slipForColorById}){
    const n = nodeById.get(id);
    if(!n) return;
    const tier = n.tier;
    const dur  = n.dur || 0;

    const slipColorVal = slipForColorById[id] || 0;
    n.color = riskFill(tier, slipColorVal);

    const local = state.localSlip[id] || 0;

    let label;
    if(state.view === 'slip'){
      const s = slipToy[id] || 0;
      label = `${n.label}\n+${s}d`;
    } else if(state.view === 'schedule'){
      const s = slipSched[id] || 0;
      label = `${n.label}\n` +
              `dur ${dur}d | ES ${es[id]||0} EF ${ef[id]||0}\n` +
              `local +${local}d | late +${s}d`;
    } else { // both
      const sToy = slipToy[id] || 0;
      const sSch = slipSched[id] || 0;
      label = `${n.label}\n` +
              `dur ${dur}d | ES ${es[id]||0} EF ${ef[id]||0}\n` +
              `slipToy +${sToy}d | late +${sSch}d`;
    }

    n.renderLabel = label;
  }

  // -----------------------------
  // Initial compute + baseline + first focus
  // -----------------------------
  ensureBaseline(true);
  recomputeAndRender({ logUpdates:false, stepwise:false });

  // quality‑of‑life: pick a node to start
  mainGraph.updateNodes();
  mainGraph.updateEdges();
  mainGraph.fit();

  mainGraph.onNodeClick = selectNode;
  mainGraph.onEdgeClick = selectEdge;
  mainGraph.onBackgroundClick = () => {
    selectNode(null);
    selectEdge(null);
  };

  setTimeout(() => {
    mainGraph.centerOn('A');
    selectNode(nodeById.get('A'));
  }, 450);

  window.addEventListener('resize', () => {
    mainGraph.resize();
    sandboxGraph.resize();
  });
})();
</script>
</body>
</html>
