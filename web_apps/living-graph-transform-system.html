<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GraphTransforms — Living Graph‑Transform Rescheduler (Cytoscape demo)</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  :root{
    --bg:#0b0f1a; --panel:#111726; --ink:#e6f1ff;
    --muted:#a9b7d3; --ok:#6ee7b7; --warn:#fbbf24; --bad:#fb7185; --edge:#2b3757;
    --accent:#7dd3fc; --accent2:#a78bfa;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0f1a 0%, #0d1324 100%);color:var(--ink);font:16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell}
  #app{display:grid;grid-template-columns:340px 1fr;grid-template-rows:auto 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
  header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:10px 14px}
  header h1{font-size:16px;margin:0}
  header .caps{opacity:.75;font-size:12px;letter-spacing:.06em}
  aside{
    background:rgba(255,255,255,0.04);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;
    padding:12px 12px 6px;
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:auto; /* so we never lose panels */
  }
  .panel{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.07);border-radius:10px;padding:10px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:6px 0}
  .row label{font-size:13px;color:var(--muted)}
  .btn{cursor:pointer;border:1px solid rgba(255,255,255,0.14);background:transparent;border-radius:10px;padding:8px 10px;color:var(--ink)}
  .btn:hover{border-color:var(--accent)}
  .btn.primary{border-color:var(--accent);box-shadow:0 0 0 1px inset rgba(125,211,252,.25)}
  .btn.danger:hover{border-color:var(--bad)}
  .legend{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 6px;border-radius:999px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08)}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.ok{background:var(--ok)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--bad)}
  .dot.base{background:var(--accent2)} .dot.root{background:var(--accent)}
  #cy{height:100%;width:100%;background:radial-gradient(ellipse at 50% -10%, #15203a 0%, #0b0f1a 60%);border:1px solid rgba(255,255,255,0.08);border-radius:12px}
  .small{font-size:12px;color:var(--muted)}
  details{border:1px dashed rgba(255,255,255,0.12);border-radius:10px;padding:8px}
  summary{cursor:pointer;color:var(--accent)}
  input[type="range"]{width:100%}
  input[type="checkbox"]{transform: translateY(1px);}
  code{background:rgba(255,255,255,0.06);padding:2px 6px;border-radius:6px}

  /* Log */
  .log{
    max-height:180px;
    overflow:auto;
    border:1px solid rgba(255,255,255,0.09);
    padding:8px;
    background:rgba(0,0,0,0.15);
    border-radius:10px;
    font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  /* Cytoscape selection styling handled via classes */
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>GraphTransforms — living graph‑transform rescheduler (Cytoscape)</h1>
    <div class="caps small">Drag nodes • Click a node or edge • Apply rewrite rules • Watch ripple + log</div>
  </header>

  <aside>
    <!-- View / mode -->
    <div class="panel">
      <div class="row small">
        <span>View:</span>
        <select id="view" class="btn" style="flex:1">
          <option value="slip">Slip propagation (original)</option>
          <option value="schedule" selected>Schedule ES/EF (durations + lags)</option>
          <option value="both">Both (verbose)</option>
        </select>
      </div>
      <div class="row small">
        <span>Propagation rule:</span>
        <select id="rule" class="btn" style="flex:1">
          <option value="max">Finish‑to‑Start (max predecessor)</option>
          <option value="sum">Cumulative (sum of predecessors)</option>
          <option value="mean">Averaging (toy)</option>
        </select>
      </div>
      <div class="row small" style="justify-content:flex-start;gap:10px">
        <label style="margin:0;color:var(--muted)">
          <input id="animate" type="checkbox" checked />
          Animate rewrites (stepwise)
        </label>
      </div>
    </div>

    <!-- Node slip panel (kept from base app) -->
    <div class="panel">
      <div class="row"><label>Selected node:</label><strong id="sel">—</strong></div>
      <div class="row"><label>Slip days on selected</label></div>
      <div class="row">
        <input id="delay" type="range" min="0" max="30" step="1" value="0" />
        <span><strong id="delayVal">0d</strong></span>
      </div>
      <div class="row">
        <button class="btn primary" id="apply">Apply slip (rewrite)</button>
        <button class="btn" id="clear">Clear all slips</button>
      </div>
      <div class="row small">
        <span class="small">
          Tip: In schedule mode, slip is treated as a local start delay on that task/milestone.
        </span>
      </div>
    </div>

    <!-- Edge lag (rewrite rule) panel (new: ports the toy prototype's DelayEdge rules) -->
    <div class="panel">
      <div class="row"><label>Selected edge:</label><strong id="selEdge">—</strong></div>
      <div class="row small"><span>Current lag:</span><strong id="lagNow">—</strong></div>

      <div class="row"><label>Lag delta on selected edge</label></div>
      <div class="row">
        <input id="lagDelta" type="range" min="-10" max="10" step="1" value="0" />
        <span><strong id="lagDeltaVal">+0d</strong></span>
      </div>

      <div class="row">
        <button class="btn primary" id="applyLag">Apply DelayEdge (rewrite)</button>
        <button class="btn" id="resetAll">Reset all (slips + lags + log)</button>
      </div>

      <!-- Keep the toy prototype's "quick demo" rewrite buttons (adapted to this graph) -->
      <div class="row" style="flex-wrap:wrap;justify-content:flex-start">
        <button class="btn" id="delayAB">Rewrite: Delay edge A→B by +2d</button>
        <button class="btn" id="delayBC">Rewrite: Delay edge B→C by +1d</button>
      </div>

      <div class="row small">
        <span>
          These match the minimal prototype idea: apply a local delay on an edge and watch stepwise propagation.
        </span>
      </div>
    </div>

    <!-- Makespan + Log (ports the toy prototype's log + makespan readout) -->
    <div class="panel">
      <div class="row small">
        <span>Baseline makespan:</span><strong><span id="msBase">0</span>d</strong>
      </div>
      <div class="row small">
        <span>Current makespan:</span><strong><span id="msNow">0</span>d</strong>
      </div>
      <div class="row small">
        <span>Max lateness (colored):</span><strong><span id="maxSlip">0</span>d</strong>
      </div>
      <div class="row" style="margin-top:10px"><label>Rewrite log</label></div>
      <div id="log" class="log" aria-label="Rewrite log"></div>
    </div>

    <!-- Legend (kept) -->
    <div class="panel">
      <div class="legend">
        <span class="pill"><span class="dot root"></span> Entry / Tier‑1</span>
        <span class="pill"><span class="dot base"></span> Tier‑2/3/4</span>
        <span class="pill"><span class="dot ok"></span> On track (≤3d)</span>
        <span class="pill"><span class="dot warn"></span> Risk (4–10d)</span>
        <span class="pill"><span class="dot bad"></span> Late (>10d)</span>
      </div>
    </div>

    <!-- Explanations (kept + expanded; includes ALL explanation content from the toy prototype) -->
    <details class="panel">
      <summary>What you’re seeing</summary>
      <div class="small" style="margin-top:8px">
        <div style="margin-bottom:8px">
          Each node is a milestone/task with a <code>duration</code> and an optional local slip (start delay).
          Edges encode dependencies and can carry a <code>lag</code> (edge delay).
        </div>
        <div style="margin-bottom:8px">
          <strong>Slip propagation view (original):</strong><br/>
          We compute each node’s <code>effectiveSlip</code> as a transform of predecessor slips
          (<code>max | sum | mean</code>), add the local slip, and recolor nodes by lateness.
          This is a tiny “graph of transforms” you can swap for your project rules later.
        </div>
        <div style="margin-bottom:8px">
          <strong>Schedule ES/EF view (new):</strong><br/>
          We do a forward pass to compute <code>ES</code> (early start) and <code>EF</code> (early finish):
          <code>ES = aggregate(predecessor EF + edge lag)</code>, then <code>EF = ES + duration</code>,
          plus any local slip as a start delay. “Lateness” is shown as <code>EF − baselineEF</code>.
        </div>
        <div>
          <strong>Rewrite rules:</strong><br/>
          Applying a change (e.g., <code>DelayEdge</code> or a node slip) is treated as a graph rewrite.
          Instead of one opaque reschedule, you see a sequence of small, causal updates logged in topological order.
        </div>
      </div>
    </details>

    <details class="panel">
      <summary>Living graph‑transform framing (from the minimal prototype)</summary>
      <div class="small" style="margin-top:8px">
        <div style="margin-bottom:10px">
          Here’s a compact, practical way to think about project delivery as a <strong>living graph‑transform system</strong>:
          model your plan as a graph (tasks = nodes; dependencies/resources/interfaces = edges).
          Any change—design tweak, reallocation, delay—acts like a <strong>rewrite rule</strong> applied to a local neighborhood of that graph.
          Instead of one opaque reschedule, you see a <strong>sequence of small, causal updates</strong> that propagate only as far as they must.
        </div>
        <div style="margin-bottom:10px">
          <strong>Why this helps (plain English)</strong>
          <ul style="margin:6px 0 0 18px;padding:0">
            <li><strong>Local causes, visible effects:</strong> A change at node/edge X triggers only the dependent neighborhood; you can watch the ripple step by step.</li>
            <li><strong>What‑if as animation:</strong> Each rewrite is one animation “frame” (apply rule, then recompute downstream, then settle).</li>
            <li><strong>Governance receipts:</strong> Every rewrite is a signed event (rule used, scope touched, deltas produced), which is great for audit and explaining “why the dates moved.”</li>
          </ul>
        </div>
        <div>
          <strong>Minimal prototype idea (now embedded here):</strong>
          Click the “Rewrite: Delay edge …” buttons to see how a local delay on an edge propagates as a short rewrite sequence rather than a big jump.
        </div>
      </div>
    </details>

    <details class="panel">
      <summary>How you’d harden this for real projects</summary>
      <div class="small" style="margin-top:8px">
        <ul style="margin:6px 0 0 18px;padding:0">
          <li><strong>Rules library:</strong> <code>DelayEdge</code>, <code>AccelerateTask</code>, <code>ReassignResource</code>, <code>SplitTask</code>, <code>InsertBuffer</code>—each with explicit preconditions + postconditions.</li>
          <li><strong>Locality guarantees:</strong> limit propagation by <em>k</em> hops or by time window, then surface boundary conditions for human review.</li>
          <li><strong>Artifacts for governance:</strong> store each rewrite as a verifiable event (timestamp, author/agent, rationale, span), plus a “before/after” diff and a causal subgraph.</li>
          <li><strong>Visualization:</strong> animate the rewrite sequence and highlight only touched nodes/edges.</li>
          <li><strong>Interfaces‑aware:</strong> treat interfaces as typed edges; rules can target specific interface types (data handoff vs. permit vs. physical possession, etc.).</li>
        </ul>
      </div>
    </details>
  </aside>

  <main class="panel" style="padding:8px">
    <div id="cy"></div>
  </main>
</div>

<!-- Cytoscape.js -->
<script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.umd.js"></script>

<script>
(function(){
  // -----------------------------
  // Sample multi‑tier milestone graph (change freely)
  // -----------------------------
  const NODES = [
    { id:'A', label:'A: Concept Freeze', tier:1, dur:3 },
    { id:'B', label:'B: Design Gate',   tier:2, dur:4 },
    { id:'C', label:'C: Procurement',   tier:2, dur:5 },
    { id:'D', label:'D: Site Ready',    tier:3, dur:3 },
    { id:'E', label:'E: Install',       tier:3, dur:4 },
    { id:'F', label:'F: Commission',    tier:3, dur:2 },
    { id:'G', label:'G: Handover',      tier:4, dur:1 }
  ];

  // Edges with baseline lag0 (initial), and mutable lag (current).
  // Added B->C so the prototype's B→C rewrite button is real in this graph.
  const EDGES0 = [
    ['A','B'], ['A','C'], ['B','C'],
    ['B','D'], ['C','E'],
    ['D','F'], ['E','F'],
    ['F','G']
  ];

  // -----------------------------
  // State
  // -----------------------------
  const state = {
    view: 'schedule',       // 'slip' | 'schedule' | 'both'
    rule: 'max',            // 'max' | 'sum' | 'mean'
    animate: true,

    selectedNode: null,
    selectedEdge: null,

    localSlip: Object.fromEntries(NODES.map(n => [n.id, 0])),

    baseline: {
      rule: null,
      es: {},
      ef: {},
      makespan: 0
    },

    last: {
      slipToy: {},          // previous slip-propagation values
      schedule: { es:{}, ef:{} } // previous ES/EF values
    }
  };

  // -----------------------------
  // Cytoscape init
  // -----------------------------
  const cy = cytoscape({
    container: document.getElementById('cy'),
    wheelSensitivity: 0.3,
    layout: { name:'cose', animate:true, randomize:false },
    style: [
      {
        selector:'node',
        style:{
          'background-color': 'data(color)',
          'border-width':2,
          'border-color':'#2b3757',
          'label':'data(renderLabel)',
          'color':'#e6f1ff',
          'font-size':12,
          'text-wrap':'wrap',
          'text-max-width': 170,
          'text-valign':'center',
          'text-halign':'center',
          'width': 44, 'height': 44,
          'overlay-opacity':0
        }
      },
      {
        selector:'node.selected',
        style:{
          'border-color':'#7dd3fc',
          'border-width':3,
          'shadow-blur':12,
          'shadow-color':'#7dd3fc'
        }
      },
      {
        selector:'node.stepping',
        style:{
          'shadow-blur':18,
          'shadow-color':'#fbbf24'
        }
      },
      {
        selector:'edge',
        style:{
          'curve-style':'bezier',
          'width':'data(w)',
          'line-color':'#2b3757',
          'target-arrow-shape':'triangle',
          'target-arrow-color':'#2b3757',
          'label':'data(renderLabel)',
          'font-size':10,
          'color':'rgba(230,241,255,0.75)',
          'text-background-color':'rgba(0,0,0,0.35)',
          'text-background-opacity':1,
          'text-background-padding':'2px',
          'text-rotation':'autorotate'
        }
      },
      {
        selector:'edge.edgeSelected',
        style:{
          'line-color':'#7dd3fc',
          'target-arrow-color':'#7dd3fc',
          'width': 4
        }
      }
    ],
    elements: {
      nodes: NODES.map(n => ({
        data: {
          ...n,
          color: baseFill(n.tier),
          renderLabel: n.label
        }
      })),
      edges: EDGES0.map(([s,t]) => ({
        data:{
          id:`${s}->${t}`,
          source:s,
          target:t,
          lag0: 0,
          lag:  0,
          w: 2,
          renderLabel: 'lag 0d'
        }
      }))
    }
  });

  // allow manual dragging
  cy.nodes().grabify();

  // -----------------------------
  // UI
  // -----------------------------
  const selEl       = document.getElementById('sel');
  const delayInput  = document.getElementById('delay');
  const delayVal    = document.getElementById('delayVal');
  const applyBtn    = document.getElementById('apply');
  const clearBtn    = document.getElementById('clear');

  const selEdgeEl   = document.getElementById('selEdge');
  const lagNowEl    = document.getElementById('lagNow');
  const lagDeltaInp = document.getElementById('lagDelta');
  const lagDeltaVal = document.getElementById('lagDeltaVal');
  const applyLagBtn = document.getElementById('applyLag');
  const resetAllBtn = document.getElementById('resetAll');

  const delayABBtn  = document.getElementById('delayAB');
  const delayBCBtn  = document.getElementById('delayBC');

  const ruleSel     = document.getElementById('rule');
  const viewSel     = document.getElementById('view');
  const animChk     = document.getElementById('animate');

  const logEl       = document.getElementById('log');
  const msBaseEl    = document.getElementById('msBase');
  const msNowEl     = document.getElementById('msNow');
  const maxSlipEl   = document.getElementById('maxSlip');

  function logLine(msg){
    const t = new Date();
    const stamp = t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    const div = document.createElement('div');
    div.textContent = `[${stamp}] ${msg}`;
    logEl.prepend(div);
  }

  // -----------------------------
  // Selection handlers
  // -----------------------------
  function selectNode(n){
    if(state.selectedNode) state.selectedNode.removeClass('selected');
    state.selectedNode = n || null;

    if(state.selectedNode){
      state.selectedNode.addClass('selected');
      const id = state.selectedNode.id();
      selEl.textContent = `${id} (${state.selectedNode.data('label')})`;
      delayInput.value = state.localSlip[id] || 0;
      delayVal.textContent = `${delayInput.value}d`;
    }else{
      selEl.textContent = '—';
    }
  }

  function selectEdge(e){
    if(state.selectedEdge) state.selectedEdge.removeClass('edgeSelected');
    state.selectedEdge = e || null;

    if(state.selectedEdge){
      state.selectedEdge.addClass('edgeSelected');
      const id = state.selectedEdge.id();
      selEdgeEl.textContent = id;
      const lag = state.selectedEdge.data('lag') || 0;
      const lag0 = state.selectedEdge.data('lag0') || 0;
      const deltaFromBase = lag - lag0;
      lagNowEl.textContent = `${lag}d (base ${lag0}d, Δ ${deltaFromBase>=0?'+':''}${deltaFromBase}d)`;
    }else{
      selEdgeEl.textContent = '—';
      lagNowEl.textContent = '—';
    }
  }

  cy.on('tap', 'node', evt => selectNode(evt.target));
  cy.on('tap', 'edge', evt => selectEdge(evt.target));

  // Tap background to clear selections
  cy.on('tap', evt => {
    if(evt.target === cy){
      selectNode(null);
      selectEdge(null);
    }
  });

  delayInput.addEventListener('input', () => {
    delayVal.textContent = `${delayInput.value}d`;
  });

  lagDeltaInp.addEventListener('input', () => {
    const v = parseInt(lagDeltaInp.value, 10) || 0;
    lagDeltaVal.textContent = `${v>=0?'+':''}${v}d`;
  });

  animChk.addEventListener('change', () => {
    state.animate = !!animChk.checked;
  });

  viewSel.addEventListener('change', () => {
    state.view = viewSel.value;
    // no rule application here; just re-render with current computed values
    recomputeAndRender({ logUpdates:false, stepwise:false });
  });

  ruleSel.addEventListener('change', () => {
    state.rule = ruleSel.value;
    // rule affects both propagation and baseline schedule
    ensureBaseline();
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });
  });

  // -----------------------------
  // Rewrite rules: node slip (existing feature kept) + edge lag (new)
  // -----------------------------
  applyBtn.addEventListener('click', () => {
    if(!state.selectedNode) return;
    const id = state.selectedNode.id();
    const v = parseInt(delayInput.value, 10) || 0;
    state.localSlip[id] = v;

    logLine(`Rule: SetLocalSlip(${id}, ${v}d) applied.`);
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });
  });

  clearBtn.addEventListener('click', () => {
    Object.keys(state.localSlip).forEach(k => state.localSlip[k] = 0);
    logLine('Rule: ClearAllLocalSlips() applied.');
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });

    if(state.selectedNode){
      delayInput.value = 0;
      delayVal.textContent = '0d';
    }
  });

  applyLagBtn.addEventListener('click', () => {
    if(!state.selectedEdge) return;
    const delta = parseInt(lagDeltaInp.value, 10) || 0;
    if(delta === 0) return;

    applyDelayEdge(state.selectedEdge.id(), delta, { label: `DelayEdge(${state.selectedEdge.id()}, ${delta>=0?'+':''}${delta}d)` });
    // reset delta UI back to 0 for convenience
    lagDeltaInp.value = 0;
    lagDeltaVal.textContent = '+0d';
  });

  resetAllBtn.addEventListener('click', () => {
    // Reset lags to baseline and local slips to 0, clear log.
    logEl.innerHTML = '';
    cy.edges().forEach(e => e.data('lag', e.data('lag0') || 0));
    Object.keys(state.localSlip).forEach(k => state.localSlip[k] = 0);

    logLine('Rule: ResetAll(slips + lags + log) applied.');
    ensureBaseline(true); // recompute baseline from lag0 and current rule
    recomputeAndRender({ logUpdates:true, stepwise:false });

    if(state.selectedNode){
      delayInput.value = 0;
      delayVal.textContent = '0d';
    }
    if(state.selectedEdge){
      selectEdge(state.selectedEdge); // refresh lag display
    }
  });

  delayABBtn.addEventListener('click', () => {
    applyDelayEdge('A->B', +2, { label: 'DelayEdge(A→B, +2d)' });
  });

  delayBCBtn.addEventListener('click', () => {
    applyDelayEdge('B->C', +1, { label: 'DelayEdge(B→C, +1d)' });
  });

  function applyDelayEdge(edgeId, delta, {label} = {}){
    const e = cy.$id(edgeId);
    if(!e || e.empty()){
      logLine(`Rule: DelayEdge(${edgeId}) failed (edge not found).`);
      return;
    }
    const prev = e.data('lag') || 0;
    e.data('lag', prev + delta);

    logLine(`Rule: ${label || `DelayEdge(${edgeId}, ${delta}d)`} applied.`);
    // Update edge selection panel if this is selected
    if(state.selectedEdge && state.selectedEdge.id() === edgeId){
      selectEdge(state.selectedEdge);
    }
    recomputeAndRender({ logUpdates:true, stepwise: state.animate });
  }

  // -----------------------------
  // GraphTransforms core utilities
  // -----------------------------
  function buildIndex(){
    const nodeIds = cy.nodes().map(n => n.id());
    const preds = {};      // id -> [{p, edge}]
    const predsIds = {};   // id -> [pId]
    const succs = {};      // id -> [vId]
    nodeIds.forEach(id => { preds[id]=[]; predsIds[id]=[]; succs[id]=[]; });

    cy.edges().forEach(e => {
      const s = e.data('source');
      const t = e.data('target');
      preds[t].push({ p:s, edge:e });
      predsIds[t].push(s);
      succs[s].push(t);
    });

    // Kahn topo sort
    const inDeg = {};
    nodeIds.forEach(id => inDeg[id] = predsIds[id].length);
    const Q = [];
    nodeIds.forEach(id => { if(inDeg[id] === 0) Q.push(id); });

    const order = [];
    while(Q.length){
      const u = Q.shift();
      order.push(u);
      succs[u].forEach(v => {
        inDeg[v]--;
        if(inDeg[v] === 0) Q.push(v);
      });
    }

    const hasCycle = order.length !== nodeIds.length;
    return { nodeIds, preds, predsIds, succs, order, hasCycle };
  }

  function aggregate(values, rule){
    if(!values.length) return 0;
    if(rule === 'max')  return Math.max(...values);
    if(rule === 'sum')  return values.reduce((a,b)=>a+b,0);
    if(rule === 'mean') return Math.round(values.reduce((a,b)=>a+b,0) / values.length);
    return 0;
  }

  // Colors
  function baseFill(tier){
    return tier===1 ? '#7dd3fc' : '#a78bfa';
  }
  function riskFill(tier, slip){
    const base = baseFill(tier);
    if(slip <= 3)  return mix(base, '#6ee7b7', 0.35); // ok tint
    if(slip <= 10) return mix(base, '#fbbf24', 0.35); // warn
    return mix(base, '#fb7185', 0.35);                // bad
  }
  function mix(aHex, bHex, t){
    const a = hexToRgb(aHex), b = hexToRgb(bHex);
    const c = { r:lerp(a.r,b.r,t), g:lerp(a.g,b.g,t), b:lerp(a.b,b.b,t) };
    return `rgb(${c.r|0},${c.g|0},${c.b|0})`;
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function hexToRgb(h){
    if(h[0] === '#') h = h.slice(1);
    if(h.length === 3) h = h.split('').map(x=>x+x).join('');
    const n = parseInt(h,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }

  // -----------------------------
  // Baseline schedule (for lateness = EF - baselineEF)
  // -----------------------------
  function ensureBaseline(force=false){
    if(!force && state.baseline.rule === state.rule) return;

    const idx = buildIndex();
    if(idx.hasCycle){
      logLine('Baseline warning: graph has a cycle; baseline ES/EF may be incomplete.');
    }

    const baseES = {};
    const baseEF = {};
    idx.order.forEach(id => {
      const dur = (cy.$id(id).data('dur') || 0);
      const candidates = idx.preds[id].map(({p, edge}) => (baseEF[p] || 0) + (edge.data('lag0') || 0));
      const es = aggregate(candidates, state.rule);
      baseES[id] = es;
      baseEF[id] = es + dur;
    });

    const baseMs = Math.max(0, ...Object.values(baseEF));
    state.baseline = { rule: state.rule, es: baseES, ef: baseEF, makespan: baseMs };
  }

  // -----------------------------
  // Compute + render
  // -----------------------------
  function recomputeAndRender({logUpdates=false, stepwise=false} = {}){
    ensureBaseline();

    const idx = buildIndex();
    if(idx.hasCycle){
      logLine('Warning: graph has a cycle; propagation order is partial.');
    }

    // 1) Original slip propagation (kept)
    const slipToy = {};
    idx.order.forEach(id => {
      const incoming = idx.predsIds[id].map(p => slipToy[p] ?? 0);
      const agg = aggregate(incoming, state.rule);
      slipToy[id] = (state.localSlip[id] || 0) + agg;
    });

    // 2) Schedule ES/EF with durations + edge lags (ports the toy prototype's ES/EF idea)
    const es = {};
    const ef = {};
    idx.order.forEach(id => {
      const dur = (cy.$id(id).data('dur') || 0);
      const candidates = idx.preds[id].map(({p, edge}) => (ef[p] || 0) + (edge.data('lag') || 0));
      const start = aggregate(candidates, state.rule) + (state.localSlip[id] || 0);
      es[id] = start;
      ef[id] = start + dur;
    });
    const msNow = Math.max(0, ...Object.values(ef));

    // lateness in schedule mode is EF - baselineEF
    const slipSched = {};
    idx.order.forEach(id => slipSched[id] = (ef[id] || 0) - (state.baseline.ef[id] || 0));

    // choose what drives coloring
    const slipForColorById = (state.view === 'slip')
      ? slipToy
      : slipSched;

    const maxSlip = Math.max(0, ...idx.nodeIds.map(id => slipForColorById[id] || 0));

    // prepare log messages for "stepwise rewrite" feel
    const scheduleUpdateMsgById = {};
    if(logUpdates){
      idx.order.forEach(id => {
        const prevES = state.last.schedule.es[id];
        const prevEF = state.last.schedule.ef[id];
        if(prevES !== es[id] || prevEF !== ef[id]){
          scheduleUpdateMsgById[id] = `Rewrite: updated ${id} -> ES ${es[id]}  EF ${ef[id]}`;
        }
      });
    }

    // edge render data (lag labels + widths)
    cy.edges().forEach(e => {
      const lag = e.data('lag') || 0;
      const lag0 = e.data('lag0') || 0;
      const delta = lag - lag0;
      const deltaStr = delta === 0 ? '' : ` (Δ ${delta>=0?'+':''}${delta}d)`;
      e.data('renderLabel', `lag ${lag}d${deltaStr}`);

      // edge thickness by downstream slip gradient (kept concept, adapted)
      const s = slipForColorById[e.data('source')] || 0;
      const t = slipForColorById[e.data('target')] || 0;
      const w = 1.5 + Math.max(0, t - s) * 0.15;
      e.data('w', w);
    });

    // update makespan / slip readouts
    msBaseEl.textContent = `${state.baseline.makespan || 0}`;
    msNowEl.textContent = `${msNow}`;
    maxSlipEl.textContent = `${maxSlip}`;

    // Render nodes either instantly or stepwise (animation frames)
    if(stepwise){
      renderNodesStepwise(idx.order, {
        slipToy, es, ef, slipSched, slipForColorById, scheduleUpdateMsgById
      });
    }else{
      renderNodesInstant(idx.nodeIds, {
        slipToy, es, ef, slipSched, slipForColorById
      });
      // dump log updates in one shot (still ordered)
      if(logUpdates){
        idx.order.forEach(id => {
          if(scheduleUpdateMsgById[id]) logLine(scheduleUpdateMsgById[id]);
        });
      }
    }

    // persist "previous" snapshots for next diff
    state.last.slipToy = {...slipToy};
    state.last.schedule = { es:{...es}, ef:{...ef} };

    // refresh edge panel readout if an edge is selected
    if(state.selectedEdge){
      selectEdge(state.selectedEdge);
    }
  }

  function renderNodesInstant(nodeIds, ctx){
    cy.batch(() => {
      nodeIds.forEach(id => applyNodeRender(id, ctx));
    });
  }

  function renderNodesStepwise(order, ctx){
    // clear any prior stepping highlight
    cy.nodes().removeClass('stepping');

    const delayMs = 140;
    let i = 0;

    function step(){
      // finished
      if(i >= order.length){
        // remove highlight shortly after end
        setTimeout(() => cy.nodes().removeClass('stepping'), 300);
        return;
      }

      const id = order[i];
      const n = cy.$id(id);

      // log in causal/topo order as the animation proceeds
      if(ctx.scheduleUpdateMsgById && ctx.scheduleUpdateMsgById[id]){
        logLine(ctx.scheduleUpdateMsgById[id]);
      }

      // apply node render and pulse highlight
      cy.batch(() => {
        cy.nodes().removeClass('stepping');
        applyNodeRender(id, ctx);
        n.addClass('stepping');
      });

      i++;
      setTimeout(step, delayMs);
    }
    step();
  }

  function applyNodeRender(id, {slipToy, es, ef, slipSched, slipForColorById}){
    const n = cy.$id(id);
    const tier = n.data('tier');
    const dur  = n.data('dur') || 0;

    const slipColorVal = slipForColorById[id] || 0;
    n.data('color', riskFill(tier, slipColorVal));

    const local = state.localSlip[id] || 0;

    let label;
    if(state.view === 'slip'){
      const s = slipToy[id] || 0;
      label = `${n.data('label')}\n+${s}d`;
    } else if(state.view === 'schedule'){
      const s = slipSched[id] || 0;
      label = `${n.data('label')}\n` +
              `dur ${dur}d | ES ${es[id]||0} EF ${ef[id]||0}\n` +
              `local +${local}d | late +${s}d`;
    } else { // both
      const sToy = slipToy[id] || 0;
      const sSch = slipSched[id] || 0;
      label = `${n.data('label')}\n` +
              `dur ${dur}d | ES ${es[id]||0} EF ${ef[id]||0}\n` +
              `slipToy +${sToy}d | late +${sSch}d`;
    }

    n.data('renderLabel', label);
  }

  // -----------------------------
  // Initial compute + baseline + first focus
  // -----------------------------
  ensureBaseline(true);
  recomputeAndRender({ logUpdates:false, stepwise:false });

  // quality‑of‑life: pick a node to start
  setTimeout(() => {
    const a = cy.$('#A');
    cy.center(a);
    a.emit('tap');
  }, 350);
})();
</script>
</body>
</html>
