<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Monotone Co-Design: Rail Transit Upgrade Demo</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 30px;
      line-height: 1.5;
      background: #f9f9f9;
    }
    h1 {
      color: #005b9a;
    }
    .section {
      margin-bottom: 2em;
      background: #ffffff;
      padding: 1.5em;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .sliderContainer {
      margin-bottom: 1em;
    }
    label {
      display: inline-block;
      width: 200px;
    }
    .info {
      font-size: 0.9em;
      color: #333;
      margin-top: 0.3em;
    }
    .highlight {
      color: #d9534f; /* Red for emphasis */
      font-weight: bold;
    }
    .adjustment {
      color: #5cb85c; /* Green to indicate an automatic adjustment */
      font-weight: bold;
    }
    .cost-indicator {
      margin-top: 1em;
      padding: 0.5em;
      background: #e9f9e9;
      border: 1px solid #a4d3a4;
      border-radius: 5px;
      width: fit-content;
    }
  </style>
</head>

<body>

<div class="section">
  <h1>Monotone Co-Design: Rail Transit Upgrade Demo</h1>
  <p>
    This interactive example demonstrates how incremental expansions
    in different rail subsystems—platform length, signal throughput, and power capacity—must remain
    <strong class="highlight">monotonic</strong> (i.e., never decreasing once raised).
    In real projects, such “no-step-back” expansions reduce redesign costs, avoid regulatory re-approvals,
    and ensure that one upgrade (e.g., a station extension) doesn’t become ineffective
    due to mismatched infrastructure elsewhere (like signals or power grids).
  </p>
  <p>
    Move the sliders below. Notice how raising one slider may force another
    <strong class="adjustment">to auto-increase</strong>.
    If you try to lower a slider <em>below its highest previous</em> or <em>below a cross-constraint</em>,
    it will <span class="highlight">snap back</span>. Once you invest in an infrastructure upgrade,
    you typically can’t reverse it.
  </p>
</div>

<div class="section">
  <h2>Subsystem Sliders</h2>

  <!-- Platform Length -->
  <div class="sliderContainer">
    <label for="platformSlider">Platform Length (m):</label>
    <input type="range" id="platformSlider" min="200" max="300" value="200" step="10" />
    <span id="platformValue">200</span>
    <div id="platformFeedback" class="info"></div>
  </div>

  <!-- Signal Throughput -->
  <div class="sliderContainer">
    <label for="signalSlider">Signal Throughput (%):</label>
    <input type="range" id="signalSlider" min="50" max="100" value="50" step="5" />
    <span id="signalValue">50</span>
    <div id="signalFeedback" class="info"></div>
  </div>

  <!-- Power Capacity -->
  <div class="sliderContainer">
    <label for="powerSlider">Power Capacity (kVA):</label>
    <input type="range" id="powerSlider" min="100" max="200" value="100" step="10" />
    <span id="powerValue">100</span>
    <div id="powerFeedback" class="info"></div>
  </div>
</div>

<div class="section">
  <h2>Monotonicity in Action</h2>
  <p id="constraintMessage" class="info">
    Each subsystem depends on the others:
    <ul>
      <li><em>Longer platforms</em> demand higher <em>signal throughput</em> for safe scheduling.</li>
      <li>Higher <em>signal throughput</em> requires more <em>power capacity</em> to run frequent trains.</li>
    </ul>
    Thus, if you lower a slider too far (either below the highest it’s been before,
    or below the required threshold from other expansions),
    it <span class="highlight">snaps back</span> to the needed minimum.
    Or if you raise one slider, the system may
    <span class="adjustment">auto-increase</span> another.
  </p>
  <!-- Optional Cost Display -->
  <div class="cost-indicator">
    <strong>Total Estimated Cost: $<span id="totalCost">0</span> million</strong>
  </div>
</div>

<script>
  // ---- Cross-subsystem constraints (unchanged) ----
  const minSignalForPlatform = {
    "200": 50, "210": 55, "220": 60, "230": 65,
    "240": 70, "250": 75, "260": 80, "270": 85,
    "280": 90, "290": 95, "300": 100
  };

  const minPowerForSignal = {
    "50": 100, "55": 110, "60": 110, "65": 120,
    "70": 130, "75": 140, "80": 150, "85": 160,
    "90": 170, "95": 180, "100": 200
  };

  // ---- Simple cost model (unchanged) ----
  function estimateCost(platform, signal, power) {
    let platformCost = (platform - 200) / 10 * 1;   // $1M per 10m
    let signalCost   = (signal - 50) / 5 * 0.5;     // $0.5M per 5%
    let powerCost    = (power - 100) / 10 * 0.2;    // $0.2M per 10 kVA
    return (platformCost + signalCost + powerCost).toFixed(1);
  }

  // ---- DOM references ----
  const platformSlider  = document.getElementById("platformSlider");
  const signalSlider    = document.getElementById("signalSlider");
  const powerSlider     = document.getElementById("powerSlider");

  const platformValue   = document.getElementById("platformValue");
  const signalValue     = document.getElementById("signalValue");
  const powerValue      = document.getElementById("powerValue");

  const platformFeedback = document.getElementById("platformFeedback");
  const signalFeedback   = document.getElementById("signalFeedback");
  const powerFeedback    = document.getElementById("powerFeedback");

  const totalCostField   = document.getElementById("totalCost");

  // ---- Track the highest so far for each slider to enforce “never decrease” ----
  let maxPlatformSoFar = parseInt(platformSlider.value);
  let maxSignalSoFar   = parseInt(signalSlider.value);
  let maxPowerSoFar    = parseInt(powerSlider.value);

  function enforceMonotonicDesign() {
    // Current slider reads
    let pVal = parseInt(platformSlider.value);
    let sVal = parseInt(signalSlider.value);
    let powVal = parseInt(powerSlider.value);

    // Step 1: Enforce “cannot go below its own historical max”
    // Platform
    if (pVal < maxPlatformSoFar) {
      pVal = maxPlatformSoFar;
      platformSlider.value = pVal;
      platformFeedback.innerHTML = `<span class="highlight">
        Attempted to reduce below your prior max. Reverted to ${pVal}m.</span>`;
    } else {
      platformFeedback.textContent = '';
    }
    // Signal
    if (sVal < maxSignalSoFar) {
      sVal = maxSignalSoFar;
      signalSlider.value = sVal;
      signalFeedback.innerHTML = `<span class="highlight">
        Attempted to reduce below your prior max. Reverted to ${sVal}%.</span>`;
    } else {
      signalFeedback.textContent = '';
    }
    // Power
    if (powVal < maxPowerSoFar) {
      powVal = maxPowerSoFar;
      powerSlider.value = powVal;
      powerFeedback.innerHTML = `<span class="highlight">
        Attempted to reduce below your prior max. Reverted to ${powVal} kVA.</span>`;
    } else {
      powerFeedback.textContent = '';
    }

    // Step 2: Enforce cross-subsystem constraints
    // (Signal >= minSignalForPlatform[ pVal ])
    let neededSignal = minSignalForPlatform[pVal.toString()];
    if (sVal < neededSignal) {
      sVal = neededSignal;
      signalSlider.value = sVal;
      signalFeedback.innerHTML = `<span class="adjustment">
        Auto-increased to ${sVal}% due to Platform = ${pVal}m</span>`;
    }

    // (Power >= minPowerForSignal[ sVal ])
    let neededPower = minPowerForSignal[sVal.toString()];
    if (powVal < neededPower) {
      powVal = neededPower;
      powerSlider.value = powVal;
      powerFeedback.innerHTML = `<span class="adjustment">
        Auto-increased to ${powVal} kVA due to Signal = ${sVal}%</span>`;
    }

    // Step 3: Update the text readouts
    platformValue.textContent = pVal;
    signalValue.textContent   = sVal;
    powerValue.textContent    = powVal;

    // Step 4: Possibly these new enforced values are now the new historical maxima
    if (pVal > maxPlatformSoFar) maxPlatformSoFar = pVal;
    if (sVal > maxSignalSoFar)   maxSignalSoFar   = sVal;
    if (powVal > maxPowerSoFar)  maxPowerSoFar    = powVal;

    // Step 5: Recompute cost
    totalCostField.textContent = estimateCost(pVal, sVal, powVal);
  }

  // ---- Event listeners: on slider input, call enforceMonotonicDesign() ----
  platformSlider.addEventListener('input', () => {
    enforceMonotonicDesign();
  });
  signalSlider.addEventListener('input', () => {
    enforceMonotonicDesign();
  });
  powerSlider.addEventListener('input', () => {
    enforceMonotonicDesign();
  });

  // ---- Initialize on load ----
  enforceMonotonicDesign();
</script>

</body>
</html>
