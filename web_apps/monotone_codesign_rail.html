<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Monotone Co-Design — Rail Upgrade Staging Simulator (No PyMCDP)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --ink:#e9ecf4;
      --muted:#b7c0dd;
      --subtle:#7f8bb6;
      --accent:#7ee787; /* green-ish */
      --accent2:#ff7b72; /* red-ish */
      --warn:#f2cc60;
      --line:rgba(255,255,255,.12);
      --good:#7ee787;
      --bad:#ff7b72;
      --mid:#a5d6ff;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 30% -10%, rgba(126,231,135,.15), transparent 60%),
                  radial-gradient(900px 600px at 80% 10%, rgba(255,123,114,.12), transparent 60%),
                  radial-gradient(900px 600px at 60% 120%, rgba(165,214,255,.10), transparent 60%),
                  var(--bg);
      color:var(--ink);
      line-height:1.45;
    }
    a{color:var(--mid); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 12px;
      max-width:1180px;
      margin:0 auto;
    }
    h1{
      margin:0 0 8px;
      font-weight:760;
      letter-spacing:.2px;
      font-size: clamp(22px, 3vw, 34px);
    }
    .subtitle{
      color:var(--muted);
      max-width:950px;
      font-size: 14.8px;
    }
    .grid{
      max-width:1180px;
      margin:0 auto;
      padding:14px 18px 42px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
    }
    .card{
      background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.92));
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      font-size:15px;
      font-weight:750;
      letter-spacing:.2px;
    }
    .card .hd{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .card .bd{padding:14px 16px;}
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--muted);
      background: rgba(0,0,0,.15);
      white-space:nowrap;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .col{display:flex; flex-direction:column; gap:10px}
    .ctrl{
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      background: rgba(0,0,0,.18);
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size:12.5px;
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    input[type="number"], select{
      width:100%;
      box-sizing:border-box;
      background: rgba(0,0,0,.30);
      border:1px solid var(--line);
      color:var(--ink);
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
      outline:none;
    }
    input[type="number"]:focus, select:focus{border-color: rgba(165,214,255,.65)}
    .hint{color:var(--subtle); font-size:12.2px; margin-top:8px}
    .mini{font-size:11.8px; color:var(--subtle)}
    .btnbar{display:flex; gap:10px; flex-wrap:wrap}
    button{
      background: linear-gradient(180deg, rgba(165,214,255,.12), rgba(0,0,0,.25));
      color:var(--ink);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      font-weight:650;
      cursor:pointer;
      transition: transform .04s ease, border-color .15s ease, background .15s ease;
    }
    button:hover{border-color: rgba(165,214,255,.55)}
    button:active{transform: translateY(1px)}
    button.primary{
      background: linear-gradient(180deg, rgba(126,231,135,.18), rgba(0,0,0,.25));
      border-color: rgba(126,231,135,.38);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,123,114,.16), rgba(0,0,0,.25));
      border-color: rgba(255,123,114,.38);
    }
    details{
      border:1px solid var(--line);
      border-radius:12px;
      background: rgba(0,0,0,.15);
      overflow:hidden;
    }
    details summary{
      cursor:pointer;
      padding:10px 12px;
      color:var(--muted);
      font-weight:700;
      list-style:none;
    }
    details summary::-webkit-details-marker{display:none}
    details .inner{padding:0 12px 12px}
    pre{
      margin:0;
      padding:12px;
      background: rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:12px;
      overflow:auto;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      color: #e9ecf4;
    }
    code{font-family:var(--mono)}
    .k{color:var(--accent)}
    .r{color:var(--accent2)}
    .u{color:var(--warn)}
    .m{color:var(--mid)}
    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      .two{grid-template-columns: 1fr;}
    }
    .hr{height:1px; background:var(--line); margin:12px 0}
    .tbl{width:100%; border-collapse: collapse; font-size:12.4px}
    .tbl th,.tbl td{border-bottom:1px solid var(--line); padding:8px 6px; text-align:left; vertical-align:top}
    .tbl th{color:var(--muted); font-weight:750; font-size:12px}
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      border:1px solid var(--line);
      border-radius:999px;
      padding:3px 8px;
      font-size:11.6px;
      color:var(--muted);
      background: rgba(0,0,0,.18);
    }
    .dot{width:8px; height:8px; border-radius:50%}
    .ok{background:var(--good)}
    .no{background:var(--bad)}
    .maybe{background:var(--warn)}
    .canvaswrap{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.15);
      overflow:hidden;
    }
    canvas{display:block; width:100%; height:320px}
    .gantt{width:100%; height:190px}
    .callout{
      border:1px dashed rgba(126,231,135,.45);
      background: rgba(126,231,135,.08);
      border-radius:12px;
      padding:10px 12px;
      color:var(--muted);
      font-size:12.6px;
    }
    .callout b{color:var(--ink)}
    .warnout{
      border:1px dashed rgba(255,123,114,.45);
      background: rgba(255,123,114,.08);
      border-radius:12px;
      padding:10px 12px;
      color:var(--muted);
      font-size:12.6px;
    }
    .smallcaps{font-variant: all-small-caps; letter-spacing:.7px; color:var(--subtle)}
    .foot{
      color:var(--subtle);
      font-size:12px;
      padding:12px 18px 26px;
      max-width:1180px;
      margin:0 auto;
    }
    .legend{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      color:var(--muted);
      font-size:12.2px;
    }
    .legend .sw{display:inline-block; width:14px; height:3px; border-radius:999px; background:var(--line)}
  </style>
</head>

<body>
<header>
  <h1>Monotone Co-Design: Rail Upgrade Staging Simulator</h1>
  <div class="subtitle">
    A director-level “portfolio cockpit” that treats <span class="k">platform length</span>, <span class="k">signalling headway</span>, and <span class="k">traction power</span> as a <i>single</i> monotone co-design problem: move the sliders, and the tool returns the <span class="m">antichain</span> (Pareto set) of minimal <code>&lt;capex, schedule, political-risk&gt;</code> plans plus an optional monotone feedback loop for “integration rework blow‑up” when tiers drift.
  </div>
  <p><a href="../index.html">Back to Card Index</a></p>
</header>

<div class="grid">
  <!-- LEFT: CONTROLS -->
  <section class="card">
    <div class="hd">
      <h2>1) Set the task (functionality) &amp; hard constraints</h2>
      <span class="pill">task → minimal resources</span>
    </div>
    <div class="bd col">
      <div class="ctrl">
        <label>
          <span>Peak demand (pphpd: passengers/hour/peak direction)</span>
          <span id="demandLabel" class="badge"><span class="dot maybe"></span><span id="demandOut"></span></span>
        </label>
        <input id="demand" type="range" min="9000" max="42000" step="500" value="24000"/>
        <div class="hint">We meet demand by choosing train length (cars) and service frequency (tph): <code>pphpd ≈ cars × tph × pax/car</code>.</div>
      </div>

      <div class="two">
        <div class="ctrl">
          <label><span>Assumed pax per car</span><span class="mini"><span id="paxOut"></span> pax</span></label>
          <input id="paxPerCar" type="number" min="60" max="160" step="1" value="110"/>
          <div class="hint">Keep it a knob: estimates vary by rolling stock, crush load policy, dwell-time management.</div>
        </div>
        <div class="ctrl">
          <label><span>Max operational tph (soft boundary)</span><span class="mini"><span id="maxTphOut"></span> tph</span></label>
          <input id="maxTph" type="number" min="18" max="34" step="1" value="28"/>
          <div class="hint">Acts like a policy/operations constraint (crew, turnback, dwell, perturbation tolerance).</div>
        </div>
      </div>

      <div class="two">
        <div class="ctrl">
          <label><span>Capex ceiling (optional)</span><span class="mini">£<span id="capexCapOut"></span>M</span></label>
          <input id="capexCap" type="number" min="0" max="3000" step="25" value="0"/>
          <div class="hint">0 = no ceiling. Think: affordability envelope / spending review limit.</div>
        </div>
        <div class="ctrl">
          <label><span>Political risk ceiling (optional)</span><span class="mini"><span id="riskCapOut"></span>/200</span></label>
          <input id="riskCap" type="number" min="0" max="200" step="5" value="0"/>
          <div class="hint">0 = no ceiling. A synthetic index bundling disruption, stakeholder veto power, safety-case volatility.</div>
        </div>
      </div>

      <div class="ctrl">
        <label><span>Governance / contracting mode (a “choose” / coproduct)</span><span class="mini" id="govSummary"></span></label>
        <select id="governance"></select>
        <div class="hint">This is where the director “codesigns the organisation”: it shapes interface drift, rework, and political failure modes.</div>
      </div>

      <div class="ctrl">
        <label>
          <span>Include monotone feedback loop (integration rework ↔ political risk)</span>
          <span class="mini"><input id="feedback" type="checkbox" checked/> enabled</span>
        </label>
        <div class="hint">When enabled, schedule &amp; risk are solved by a monotone fixed-point iteration (starting from 0 gives the least fixed point).</div>
      </div>

      <div class="btnbar">
        <button class="primary" id="solveBtn">Solve &amp; show Pareto set</button>
        <button id="sweepBtn">Sweep demand curve</button>
        <button class="danger" id="resetBtn">Reset</button>
      </div>

      <details>
        <summary>What “monotone co-design” means here (quick)</summary>
        <div class="inner">
          <div class="callout">
            <b>Monotonicity</b>: if the requested functionality increases (higher pphpd), the set of feasible plans can only get worse in resources (you won’t magically need less capex/schedule/risk).<br/>
            <b>Solution concept</b>: for a fixed request, we return the <b>minimal</b> resource tuples under the product order — an <b>antichain</b> (Pareto front). Everything “above” it is feasible but dominated.
          </div>
        </div>
      </details>
    </div>
  </section>

  <!-- RIGHT: OUTPUTS -->
  <section class="card">
    <div class="hd">
      <h2>2) Results: minimal plans (antichain) + explanation</h2>
      <span class="pill">resources ∈ ℝ⁺×ℝ⁺×ℝ⁺</span>
    </div>
    <div class="bd col">
      <div class="two">
        <div class="ctrl">
          <div class="row" style="justify-content:space-between; align-items:flex-start">
            <div>
              <div class="smallcaps">Model lens</div>
              <div style="margin-top:4px;color:var(--muted);font-size:12.8px">
                This is a discrete approximation of an MCDP: subsystems are <i>catalogues</i> of upgrade tiers; governance is a <i>coproduct</i> (choose); integration is composition plus (optional) feedback.
              </div>
            </div>
            <span class="badge" id="feasibleBadge"><span class="dot maybe"></span><span id="feasibleText">Not solved</span></span>
          </div>
          <div class="hr"></div>
          <div id="topline" class="mini">Click “Solve” to compute minimal resource bundles for the chosen demand.</div>
        </div>

        <div class="ctrl">
          <div class="smallcaps">Co-design diagram (stylised)</div>
          <div class="hint" style="margin-top:6px">Green dashed = functionalities; red solid = resources; joins are ≥-type co-design constraints.</div>
          <div class="canvaswrap" style="margin-top:10px">
            <svg viewBox="0 0 900 320" width="100%" height="210" aria-label="codesign diagram">
              <!-- Boxes -->
              <defs>
                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur stdDeviation="2.2" result="blur"/>
                  <feMerge>
                    <feMergeNode in="blur"/>
                    <feMergeNode in="SourceGraphic"/>
                  </feMerge>
                </filter>
                <marker id="arrowG" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#7ee787"/>
                </marker>
                <marker id="arrowR" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#ff7b72"/>
                </marker>
              </defs>
              <rect x="45" y="90" width="200" height="140" rx="16" fill="rgba(0,0,0,.12)" stroke="rgba(255,255,255,.18)"/>
              <rect x="345" y="35" width="220" height="120" rx="16" fill="rgba(0,0,0,.12)" stroke="rgba(255,255,255,.18)"/>
              <rect x="345" y="175" width="220" height="120" rx="16" fill="rgba(0,0,0,.12)" stroke="rgba(255,255,255,.18)"/>
              <rect x="645" y="90" width="210" height="140" rx="16" fill="rgba(0,0,0,.12)" stroke="rgba(255,255,255,.18)"/>

              <text x="145" y="135" text-anchor="middle" fill="#e9ecf4" font-weight="800" font-size="16">Platform</text>
              <text x="145" y="157" text-anchor="middle" fill="#b7c0dd" font-size="12">provides cars</text>
              <text x="145" y="177" text-anchor="middle" fill="#b7c0dd" font-size="12">requires £, months, risk</text>

              <text x="455" y="80" text-anchor="middle" fill="#e9ecf4" font-weight="800" font-size="16">Signalling</text>
              <text x="455" y="102" text-anchor="middle" fill="#b7c0dd" font-size="12">provides tph</text>
              <text x="455" y="122" text-anchor="middle" fill="#b7c0dd" font-size="12">requires £, months, risk</text>

              <text x="455" y="220" text-anchor="middle" fill="#e9ecf4" font-weight="800" font-size="16">Power</text>
              <text x="455" y="242" text-anchor="middle" fill="#b7c0dd" font-size="12">provides MW</text>
              <text x="455" y="262" text-anchor="middle" fill="#b7c0dd" font-size="12">requires £, months, risk</text>

              <text x="750" y="135" text-anchor="middle" fill="#e9ecf4" font-weight="800" font-size="16">Integration</text>
              <text x="750" y="157" text-anchor="middle" fill="#b7c0dd" font-size="12">task: pphpd</text>
              <text x="750" y="177" text-anchor="middle" fill="#b7c0dd" font-size="12">outputs minimal resources</text>

              <!-- Functionality edges (green dashed) -->
              <path d="M 15 140 L 45 140" stroke="#7ee787" stroke-width="3" stroke-dasharray="8 7" marker-end="url(#arrowG)" filter="url(#glow)"/>
              <text x="18" y="128" fill="#7ee787" font-size="11">cars</text>

              <path d="M 245 140 C 285 140, 295 95, 345 95" stroke="#7ee787" stroke-width="3" stroke-dasharray="8 7" marker-end="url(#arrowG)" filter="url(#glow)"/>
              <text x="290" y="88" fill="#7ee787" font-size="11">cars ≥ cars_needed</text>

              <path d="M 245 180 C 285 180, 295 235, 345 235" stroke="#7ee787" stroke-width="3" stroke-dasharray="8 7" marker-end="url(#arrowG)" filter="url(#glow)"/>
              <text x="290" y="252" fill="#7ee787" font-size="11">cars ≥ cars_needed</text>

              <path d="M 565 95 C 610 95, 610 125, 645 125" stroke="#7ee787" stroke-width="3" stroke-dasharray="8 7" marker-end="url(#arrowG)" filter="url(#glow)"/>
              <text x="600" y="84" fill="#7ee787" font-size="11">tph</text>

              <path d="M 565 235 C 610 235, 610 195, 645 195" stroke="#7ee787" stroke-width="3" stroke-dasharray="8 7" marker-end="url(#arrowG)" filter="url(#glow)"/>
              <text x="600" y="256" fill="#7ee787" font-size="11">MW</text>

              <!-- Resource edges (red solid) -->
              <path d="M 855 140 L 890 140" stroke="#ff7b72" stroke-width="3" marker-end="url(#arrowR)" filter="url(#glow)"/>
              <text x="862" y="128" fill="#ff7b72" font-size="11">£, months, risk</text>

              <!-- Grey annotation -->
              <text x="88" y="260" fill="rgba(233,236,244,.65)" font-size="11">Constraint style mirrors MCDPL diagrams: green dashed functionality, red solid resource.</text>
            </svg>
          </div>
        </div>
      </div>

      <div class="two">
        <div class="ctrl">
          <div class="row" style="justify-content:space-between">
            <div>
              <div class="smallcaps">Pareto plot</div>
              <div class="hint" style="margin-top:6px">Each dot is a feasible plan. We highlight the <b>antichain</b> of minimal ⟨capex, schedule, risk⟩.</div>
            </div>
            <div class="legend">
              <span class="badge"><span class="dot ok"></span> Pareto-minimal</span>
              <span class="badge"><span class="dot maybe"></span> feasible</span>
            </div>
          </div>
          <div class="canvaswrap" style="margin-top:10px">
            <canvas id="scatter" width="900" height="320"></canvas>
          </div>
          <div class="hint">Axes: x = capex (£M), y = schedule (months). Bubble = political risk.</div>
        </div>

        <div class="ctrl">
          <div class="row" style="justify-content:space-between; align-items:flex-start">
            <div>
              <div class="smallcaps">Selected plan timeline</div>
              <div class="hint" style="margin-top:6px">Critical path view (max of package durations + integration). Click a row in the table to select.</div>
            </div>
            <span class="badge" id="selBadge"><span class="dot maybe"></span><span id="selText">No selection</span></span>
          </div>
          <div class="canvaswrap" style="margin-top:10px">
            <canvas id="gantt" class="gantt" width="900" height="190"></canvas>
          </div>
          <div id="iterBox" class="hint" style="margin-top:10px"></div>
        </div>
      </div>

      <div class="ctrl">
        <div class="row" style="justify-content:space-between;align-items:flex-start">
          <div>
            <div class="smallcaps">Minimal plans table (antichain)</div>
            <div class="hint" style="margin-top:6px">
              A row is minimal if no other plan is ≤ it in all resource dimensions. This is the “you can’t have your cake and eat it” set.
            </div>
          </div>
          <span class="badge" id="countBadge"><span class="dot maybe"></span><span id="countText">0 plans</span></span>
        </div>
        <div style="overflow:auto; margin-top:10px">
          <table class="tbl" id="tbl"></table>
        </div>
      </div>

      <details>
        <summary>Show the “MCDPL mirror” (pseudo-code for this scenario)</summary>
        <div class="inner">
          <div class="hint" style="margin-top:0">
            This is not executed here; it’s a readable skeleton mapping the simulator’s catalogue/choice/composition to MCDPL idioms.
          </div>
          <pre id="mcdpl"></pre>
        </div>
      </details>

      <details>
        <summary>Director’s reading of the Pareto set (why this beats “one plan”)</summary>
        <div class="inner">
          <div class="callout">
            The <b>Pareto set is a governance object</b>: it’s what you can credibly put in front of ministers, safety regulators, operators, and supply chain without pretending their objectives collapse into one scalar “business case”. In Ackoff’s and Churchman’s less-quoted mode, the “problem” is the evolving boundary of the system, not the chosen point — so you manage <i>movement along the frontier</i> as politics and risk appetite shift, rather than defending a single brittle optimum.
          </div>
          <div class="hr"></div>
          <ul style="margin:0; padding-left:16px; color:var(--muted); font-size:12.8px">
            <li><b>Programme pacing</b>: if the frontier is steep in months but shallow in £, you are schedule-constrained (possession windows, approvals), not budget-constrained.</li>
            <li><b>Interface discipline</b>: wide spread between platform, signalling, power tiers indicates “stranded capacity risk” (overbuild) or “safety ceiling risk” (underbuild).</li>
            <li><b>Equity among stakeholders</b>: risk ceilings mimic veto constraints. A plan that is cheap but spikes political risk may be “unimplementable” in Churchman’s sense (violates the client’s real boundary).</li>
          </ul>
        </div>
      </details>

      <details>
        <summary>Limitations (honest, and where you’d plug a real solver)</summary>
        <div class="inner">
          <div class="warnout">
            This is a <b>discrete, enumerative</b> approximation: we use small catalogues and compute the antichain by dominance filtering. A full MCDP toolchain would support richer posets, upper-closures, and scalable fixed-point algorithms — but the structural discipline (monotone relations + compositional wiring) is the point.
          </div>
        </div>
      </details>
    </div>
  </section>
</div>

<div class="foot">
  <div><b>References inside the model:</b> this simulator borrows the terminology and modelling idioms of MCDPL (catalogues, coproduct/choose, composition via co-design constraints) and the MCDP solution idea “minimal resources as an antichain / upper set” — implemented here in plain JavaScript.</div>
  <div style="margin-top:8px">Tip: try setting a tight risk ceiling and switching governance mode to see “feasible vs infeasible” flip via the (optional) feedback loop.</div>
</div>

<script>
/**
 * Rail Upgrade Staging Simulator
 * -----------------------------------------------------------
 * A deliberately small, director-friendly MCDP-like sandbox.
 * We approximate:
 *   - Functionality: demand (pphpd)
 *   - Internal design: choose cars ∈ {6,8,10,12}, tph ∈ {18..32}
 *   - Subsystems: Platform, Signalling, Power as monotone catalogues
 *   - Governance as "choose" (coproduct) affecting interface rework
 *   - Resources: cost (£M), schedule (months), political risk (index)
 *   - Solution: antichain of minimal resources under product order
 * Optional: monotone feedback loop giving least fixed point for risk/schedule.
 *
 * No external libraries; deterministic and transparent.
 */

const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
const fmt = (n, d=0) => Number.isFinite(n) ? n.toFixed(d) : String(n);
const uniqId = (()=>{let i=0; return ()=>++i;})();

function dominates(rA, rB){
  // resource vectors: smaller is better; A dominates B if A <= B componentwise and A != B
  const le = (rA.cost <= rB.cost) && (rA.months <= rB.months) && (rA.risk <= rB.risk);
  const lt = (rA.cost <  rB.cost) ||  (rA.months < rB.months) ||  (rA.risk < rB.risk);
  return le && lt;
}

function paretoMin(solutions){
  // Return antichain (Pareto-minimal solutions) under componentwise order on resources
  const mins = [];
  for (const s of solutions){
    let dominatedByExisting = false;
    // If s dominates something already in mins, remove those.
    for (let i=mins.length-1; i>=0; i--){
      if (dominates(mins[i].res, s.res)){
        dominatedByExisting = true;
        break;
      }
      if (dominates(s.res, mins[i].res)){
        mins.splice(i, 1);
      }
    }
    if (!dominatedByExisting) mins.push(s);
  }
  // stable sort: cheaper then faster then lower risk (doesn't change minimality)
  mins.sort((a,b)=> (a.res.cost-b.res.cost) || (a.res.months-b.res.months) || (a.res.risk-b.res.risk));
  return mins;
}

/** -----------------------------
 * Catalogues (monotone tier ladders)
 * ------------------------------
 * All "capabilities" are nondecreasing with tier.
 * All resources (cost/time/risk) are nondecreasing with tier, within a tech family.
 *
 * You can treat this as a "catalogue { provides ... requires ... }" in MCDPL terms.
 */

const platformTiers = [
  {tier:0, cars:6,  cost:  0, months:  0, baseRisk: 10, disruption: 2, label:"Keep 6-car platforms"},
  {tier:1, cars:8,  cost:150, months: 12, baseRisk: 18, disruption: 5, label:"Extend to 8 cars (selective)"},
  {tier:2, cars:10, cost:320, months: 18, baseRisk: 28, disruption: 8, label:"Extend to 10 cars (major civils)"},
  {tier:3, cars:12, cost:550, months: 26, baseRisk: 42, disruption:12, label:"Extend to 12 cars (network-wide)"}
];

const signallingTechs = {
  "ETCS-L2+": {
    label: "ETCS L2+ overlay (incremental)",
    tiers: [
      {tier:0, tph:18, cost:  0, months:  0, baseRisk: 12, label:"Baseline fixed-block"},
      {tier:1, tph:22, cost:120, months: 10, baseRisk: 18, label:"Optimise blocks, upgrade interlockings"},
      {tier:2, tph:26, cost:260, months: 16, baseRisk: 26, label:"ETCS L2+ overlay & junction remodelling"},
      {tier:3, tph:30, cost:480, months: 24, baseRisk: 40, label:"High-density ETCS + ATO in core"}
    ]
  },
  "CBTC": {
    label: "CBTC / moving-block (higher disruption)",
    tiers: [
      {tier:0, tph:18, cost:  0, months:  0, baseRisk: 12, label:"Baseline fixed-block"},
      {tier:1, tph:24, cost:210, months: 14, baseRisk: 22, label:"CBTC segment pilots"},
      {tier:2, tph:28, cost:380, months: 20, baseRisk: 30, label:"CBTC core rollout"},
      {tier:3, tph:32, cost:650, months: 28, baseRisk: 44, label:"Full CBTC + ATO, fleet retrofits"}
    ]
  }
};

const powerTechs = {
  "Substations": {
    label: "Grid + substation uprating",
    tiers: [
      {tier:0, mwIndex:1.0, cost:  0, months:  0, baseRisk: 10, label:"Baseline feeders/substations"},
      {tier:1, mwIndex:1.25,cost: 80, months:  8, baseRisk: 14, label:"Feeder reinforcement (targeted)"},
      {tier:2, mwIndex:1.55,cost:210, months: 14, baseRisk: 22, label:"Substation uprate + rectifiers"},
      {tier:3, mwIndex:1.90,cost:420, months: 20, baseRisk: 35, label:"Major grid connection + redundancy"}
    ]
  },
  "Storage+Regen": {
    label: "Wayside storage + regenerative capture",
    tiers: [
      {tier:0, mwIndex:1.0, cost:  0, months:  0, baseRisk: 10, label:"Baseline feeders/substations"},
      {tier:1, mwIndex:1.30,cost:120, months: 10, baseRisk: 16, label:"Pilot storage at hotspots"},
      {tier:2, mwIndex:1.70,cost:260, months: 16, baseRisk: 24, label:"Networked storage + timetable smoothing"},
      {tier:3, mwIndex:2.10,cost:520, months: 22, baseRisk: 34, label:"Storage-heavy strategy (ops coupling)"}
    ]
  }
};

const governanceModes = [
  {
    id:"Alliance",
    label:"Alliance / integrated delivery (shared pain-gain)",
    note:"Lower interface drift; earlier systems integration; higher up-front overhead.",
    costFactor: 1.05,
    baseReworkMonths: 2.0,
    mismatchFactor: 0.80,
    riskOffset: -8
  },
  {
    id:"MultiPrime",
    label:"Multi-contract / fixed interfaces (classic)",
    note:"Cheaper per-package bids; higher integration churn; more claims risk.",
    costFactor: 0.98,
    baseReworkMonths: 6.0,
    mismatchFactor: 1.70,
    riskOffset: +6
  },
  {
    id:"Incremental",
    label:"Incremental staging / 'thin slices' with early benefits",
    note:"Moderate integration risk; spreads disruption; may constrain ultimate performance.",
    costFactor: 1.00,
    baseReworkMonths: 3.0,
    mismatchFactor: 1.25,
    riskOffset: +0
  }
];

/** -----------------------------
 * Requirement mapping (monotone couplings)
 * ------------------------------
 * These encode the scenario statement:
 * each increment of platform extension triggers knock-on requirements in signalling and power.
 *
 * We'll compute required min tiers as monotone functions of the chosen cars/tph.
 */

function reqPlatformTierForCars(cars){
  for (const t of platformTiers){
    if (t.cars >= cars) return t.tier;
  }
  return platformTiers.at(-1).tier;
}

function reqSignalTierFor(cars, tph, techKey){
  const tech = signallingTechs[techKey];
  // base: meet tph
  let tierTph = 0;
  for (const t of tech.tiers){
    if (t.tph >= tph) { tierTph = t.tier; break; }
    tierTph = t.tier;
  }
  // knock-on: longer trains require revalidation, overlaps, platform-train interface changes
  const tierCars = Math.max(0, Math.floor((cars - 6)/2)); // 6->0, 8->1, 10->2, 12->3
  return clamp(Math.max(tierTph, tierCars), 0, tech.tiers.at(-1).tier);
}

function reqPowerTierFor(cars, tph, techKey){
  const tech = powerTechs[techKey];
  // crude monotone index of required traction+aux capacity
  // normalize at baseline: 6 cars @ 18 tph => index 1.0
  const loadIndex = (cars/6) * (tph/18);
  // find smallest tier with mwIndex >= loadIndex
  let tier = 0;
  for (const t of tech.tiers){
    if (t.mwIndex >= loadIndex) { tier = t.tier; break; }
    tier = t.tier;
  }
  return clamp(tier, 0, tech.tiers.at(-1).tier);
}

function pickTierByNum(techTiers, tierNum){
  const found = techTiers.find(t=>t.tier===tierNum);
  return found ?? techTiers.at(-1);
}

/** -----------------------------
 * Co-design enumeration
 * ------------------------------
 * We enumerate candidate internal choices (cars, tph, technologies),
 * compute subsystem tiers and resources, and then filter by feasibility and Pareto minimality.
 */

function enumerateDesigns({demand, paxPerCar, maxTph, capexCap, riskCap, govId, feedback}){
  // Candidate decision spaces (small but nontrivial)
  const carsChoices = [6,8,10,12];
  const tphChoices = [];
  for (let t=18; t<=32; t+=2) tphChoices.push(t);

  const gov = governanceModes.find(g=>g.id===govId) ?? governanceModes[0];

  const designs = [];
  for (const cars of carsChoices){
    for (const tph of tphChoices){
      if (tph > maxTph) continue;
      const pphpd = cars * tph * paxPerCar;
      if (pphpd < demand) continue;

      const platTier = reqPlatformTierForCars(cars);
      const plat = platformTiers.find(t=>t.tier===platTier);

      // Technologies
      for (const sigKey of Object.keys(signallingTechs)){
        for (const pwrKey of Object.keys(powerTechs)){
          const sigTier = reqSignalTierFor(cars, tph, sigKey);
          const pwrTier = reqPowerTierFor(cars, tph, pwrKey);

          const sig = pickTierByNum(signallingTechs[sigKey].tiers, sigTier);
          const pwr = pickTierByNum(powerTechs[pwrKey].tiers, pwrTier);

          // staging mismatch: spread among tiers (stranded capacity, interface churn)
          const tiers = [platTier, sigTier, pwrTier];
          const mismatch = (Math.max(...tiers) - Math.min(...tiers));

          // base resources (before feedback)
          let cost = (plat.cost + sig.cost + pwr.cost) * gov.costFactor;
          // critical path approximation: mostly parallel packages + integration
          let baseMonths = Math.max(plat.months, sig.months, pwr.months);
          const rework = gov.baseReworkMonths + gov.mismatchFactor * (mismatch ** 1.3);
          let months = baseMonths + rework;

          // risk is an additive-ish index with governance offsets; disruption treated as political load
          const baseRisk = (plat.baseRisk + sig.baseRisk + pwr.baseRisk) + (plat.disruption * 2.2) + gov.riskOffset + (mismatch * 6.0);

          let risk = baseRisk;

          let iterationTrace = null;
          let infeasibleReason = null;

          if (feedback){
            // Monotone fixed-point iteration.
            // Idea: higher risk reduces access windows and increases approvals burden, lengthening schedule,
            // which in turn raises political risk. Starting at 0 returns the least fixed point.
            // If it blows up beyond thresholds, treat as "Top" (infeasible) in the spirit of divergence.
            const alpha = 0.010; // schedule inflation per risk point (1% per 100 risk)
            const beta  = 0.45;  // risk sensitivity to schedule extension
            const gamma = 3.0;   // risk sensitivity to mismatch
            const maxIter = 60;
            const tol = 0.05;
            let r = 0.0;
            iterationTrace = [];
            let converged = false;
            let m = months; // carry schedule too
            for (let k=0; k<maxIter; k++){
              // update schedule based on current risk (access window tightening & approvals burden)
              const inflatedBase = baseMonths * (1 + alpha * r);
              m = inflatedBase + rework;

              // update risk based on schedule stretch and mismatch
              const rNew = baseRisk + beta * Math.max(0, (m - baseMonths)) + gamma * mismatch;

              iterationTrace.push({k, r: rNew, months: m});

              if (!Number.isFinite(rNew) || rNew > 220 || m > 120){
                infeasibleReason = "Feedback loop diverged (risk/schedule blew past tolerances) → treat as ⊤ / infeasible.";
                r = Infinity;
                m = Infinity;
                break;
              }
              if (Math.abs(rNew - r) < tol){
                r = rNew;
                months = m;
                risk = r;
                converged = true;
                break;
              }
              r = rNew;
            }
            if (!converged && Number.isFinite(r) && r !== Infinity){
              // If it didn't converge, still take last iterate (approximate).
              const last = iterationTrace.at(-1);
              months = last.months;
              risk = last.r;
              iterationTrace.push({k:"~", r:last.r, months:last.months, note:"max-iter reached; using last iterate"});
            }
          }

          if (capexCap > 0 && cost > capexCap) continue;
          if (riskCap  > 0 && risk > riskCap) continue;
          if (!Number.isFinite(cost) || !Number.isFinite(months) || !Number.isFinite(risk)){
            continue;
          }

          designs.push({
            id: uniqId(),
            demand,
            paxPerCar,
            cars,
            tph,
            pphpd,
            gov,
            sigKey,
            pwrKey,
            tiers: {platform:platTier, signalling:sigTier, power:pwrTier},
            parts: {platform:plat, signalling:sig, power:pwr},
            mismatch,
            res: {cost, months, risk},
            trace: iterationTrace,
            infeasibleReason
          });
        }
      }
    }
  }

  return designs;
}

/** -----------------------------
 * Rendering helpers
 * ------------------------------
 */

function drawScatter(canvas, all, pareto, selectedId){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  ctx.clearRect(0,0,W,H);
  ctx.save();

  const pad = 42;
  const plotW = W - pad*2;
  const plotH = H - pad*2;

  // compute scales
  const xs = all.map(s=>s.res.cost);
  const ys = all.map(s=>s.res.months);
  const rs = all.map(s=>s.res.risk);

  const minX = Math.min(...xs, 0), maxX = Math.max(...xs, 1);
  const minY = Math.min(...ys, 0), maxY = Math.max(...ys, 1);
  const minR = Math.min(...rs, 0), maxR = Math.max(...rs, 1);

  const x = (v)=> pad + ( (v - minX) / (maxX - minX || 1) ) * plotW;
  const y = (v)=> pad + plotH - ( (v - minY) / (maxY - minY || 1) ) * plotH;

  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  for (let i=0;i<=4;i++){
    const gx = pad + (plotW*i/4);
    const gy = pad + (plotH*i/4);
    ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, pad+plotH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(pad, gy); ctx.lineTo(pad+plotW, gy); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 1.4;
  ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, pad+plotH); ctx.lineTo(pad+plotW, pad+plotH); ctx.stroke();

  // labels
  ctx.fillStyle = "rgba(233,236,244,0.80)";
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.fillText("Schedule (months)", 8, pad-14);
  ctx.fillText("Capex (£M)", pad+plotW-80, pad+plotH+28);

  // draw all points (feasible)
  for (const s of all){
    const px = x(s.res.cost), py = y(s.res.months);
    const rr = 4 + 10 * ((s.res.risk - minR)/(maxR-minR || 1));
    ctx.beginPath();
    ctx.fillStyle = "rgba(242,204,96,0.18)";
    ctx.arc(px, py, rr, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "rgba(242,204,96,0.35)";
    ctx.stroke();
  }

  // draw Pareto-minimal points
  for (const s of pareto){
    const px = x(s.res.cost), py = y(s.res.months);
    const rr = 4 + 10 * ((s.res.risk - minR)/(maxR-minR || 1));
    ctx.beginPath();
    ctx.fillStyle = "rgba(126,231,135,0.20)";
    ctx.arc(px, py, rr, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "rgba(126,231,135,0.75)";
    ctx.lineWidth = 1.4;
    ctx.stroke();
  }

  // highlight selected
  if (selectedId){
    const s = all.find(s=>s.id===selectedId);
    if (s){
      const px = x(s.res.cost), py = y(s.res.months);
      ctx.beginPath();
      ctx.strokeStyle = "rgba(165,214,255,0.95)";
      ctx.lineWidth = 2.4;
      ctx.arc(px, py, 16, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  ctx.restore();
}

function drawGantt(canvas, plan){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.save();

  const padL=120, padR=18, padT=18, rowH=34;
  const plotW = W - padL - padR;
  const labels = ["Platform", "Signalling", "Power", "Integration"];
  const colors = ["rgba(126,231,135,0.25)", "rgba(165,214,255,0.18)", "rgba(242,204,96,0.18)", "rgba(255,123,114,0.18)"];
  const strokes = ["rgba(126,231,135,0.70)", "rgba(165,214,255,0.65)", "rgba(242,204,96,0.60)", "rgba(255,123,114,0.65)"];

  ctx.fillStyle = "rgba(233,236,244,0.85)";
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.fillText("Months", padL + plotW - 44, padT-4);

  const platM = plan.parts.platform.months;
  const sigM  = plan.parts.signalling.months;
  const pwrM  = plan.parts.power.months;
  const baseMonths = Math.max(platM, sigM, pwrM);
  const rework = plan.gov.baseReworkMonths + plan.gov.mismatchFactor * (plan.mismatch ** 1.3);
  const integM = rework; // integration+rework as a block
  const total = plan.res.months; // includes feedback if enabled

  const maxSpan = Math.max(total, baseMonths + integM, 1);

  const x = (m)=> padL + (m/maxSpan)*plotW;

  // grid
  ctx.strokeStyle="rgba(255,255,255,0.10)";
  for (let i=0;i<=5;i++){
    const gx = padL + plotW*(i/5);
    ctx.beginPath(); ctx.moveTo(gx, padT); ctx.lineTo(gx, padT + rowH*labels.length); ctx.stroke();
    ctx.fillStyle="rgba(183,192,221,0.65)";
    ctx.fillText(String(Math.round(maxSpan*(i/5))), gx-8, padT + rowH*labels.length + 14);
  }

  const bars = [platM, sigM, pwrM, integM];
  for (let i=0; i<labels.length; i++){
    const y0 = padT + i*rowH;
    // label
    ctx.fillStyle="rgba(183,192,221,0.85)";
    ctx.fillText(labels[i], 18, y0+20);

    // bar
    const w = x(bars[i]) - padL;
    ctx.fillStyle = colors[i];
    ctx.strokeStyle = strokes[i];
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.roundRect(padL, y0+8, w, 18, 8);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(233,236,244,0.88)";
    ctx.fillText(fmt(bars[i],1), padL + w + 6, y0+22);
  }

  // total marker
  const xt = x(total);
  ctx.strokeStyle="rgba(255,255,255,0.75)";
  ctx.lineWidth=1.2;
  ctx.beginPath(); ctx.moveTo(xt, padT-4); ctx.lineTo(xt, padT + rowH*labels.length + 6); ctx.stroke();
  ctx.fillStyle="rgba(233,236,244,0.9)";
  ctx.fillText("total", xt+6, padT+12);
  ctx.fillText(fmt(total,1), xt+6, padT+26);

  ctx.restore();
}

function buildTable(el, plans, onSelect, selectedId){
  const headers = [
    "cars", "tph", "pphpd", "platform tier", "signalling tech/tier", "power tech/tier",
    "capex £M", "months", "risk", "notes"
  ];
  let html = "<thead><tr>" + headers.map(h=>`<th>${h}</th>`).join("") + "</tr></thead><tbody>";

  for (const p of plans){
    const sel = p.id===selectedId;
    const notes = [
      `${p.gov.id}`,
      `mismatch=${p.mismatch}`
    ].join(", ");
    html += `<tr data-id="${p.id}" style="cursor:pointer; background:${sel ? 'rgba(165,214,255,0.08)' : 'transparent'}">`;
    html += `<td><span class="badge"><span class="dot ${sel?'ok':'maybe'}"></span>${p.cars}</span></td>`;
    html += `<td>${p.tph}</td>`;
    html += `<td>${fmt(p.pphpd,0)}</td>`;
    html += `<td>${p.tiers.platform}</td>`;
    html += `<td>${p.sigKey} / ${p.tiers.signalling}</td>`;
    html += `<td>${p.pwrKey} / ${p.tiers.power}</td>`;
    html += `<td>${fmt(p.res.cost,1)}</td>`;
    html += `<td>${fmt(p.res.months,1)}</td>`;
    html += `<td>${fmt(p.res.risk,1)}</td>`;
    html += `<td class="mini">${notes}</td>`;
    html += "</tr>";
  }
  html += "</tbody>";
  el.innerHTML = html;

  el.querySelectorAll("tbody tr").forEach(tr=>{
    tr.addEventListener("click", ()=>{
      const id = Number(tr.dataset.id);
      onSelect(id);
    });
  });
}

function buildMcdplMirror(plan, opts){
  // A readable pseudo-MCDPL skeleton matching this simulator’s structure.
  const gov = plan ? plan.gov : governanceModes.find(g=>g.id===opts.govId) ?? governanceModes[0];

  const lines = [];
  lines.push("mcdp {");
  lines.push("  '''");
  lines.push("  Rail upgrade (platform + signalling + power) as an MCDP-like model.");
  lines.push("  Discrete catalogues for each subsystem; governance as choose(...).");
  lines.push("  This is a readable mirror, not executed in this HTML.");
  lines.push("  '''");
  lines.push("");
  lines.push("  # --- External functionality (task specification) ---");
  lines.push("  provides demand [pphpd]");
  lines.push("  pax_per_car = " + opts.paxPerCar + "  # assumed");
  lines.push("");
  lines.push("  # --- Internal design variables (here enumerated in JS) ---");
  lines.push("  # cars ∈ {6,8,10,12}, tph ∈ {18..32 step 2}");
  lines.push("  # capacity constraint: cars * tph * pax_per_car ≥ demand");
  lines.push("");
  lines.push("  # --- Subsystems as catalogues (upgrade tiers) ---");
  lines.push("  platform = instance `PlatformCatalogue");
  lines.push("  signalling = instance `SignallingCatalogue");
  lines.push("  power = instance `PowerCatalogue");
  lines.push("");
  lines.push("  # --- Co-design constraints (monotone couplings) ---");
  lines.push("  # Longer trains force non-decreasing signalling & power capability.");
  lines.push("  cars provided by platform ≽ cars_needed");
  lines.push("  tph provided by signalling ≽ tph_needed");
  lines.push("  MW  provided by power ≽ MW_needed");
  lines.push("");
  lines.push("  # Knock-on constraints (stylised):");
  lines.push("  signalling_tier_needed = max(tier_from_tph, tier_from_cars)");
  lines.push("  power_tier_needed = tier_from( (cars/6) * (tph/18) )");
  lines.push("");
  lines.push("  # --- Governance as coproduct / choose ---");
  lines.push(`  governance = choose(`);
  lines.push(`    Alliance: \`Gov_Alliance,`);
  lines.push(`    MultiPrime: \`Gov_MultiPrime,`);
  lines.push(`    Incremental: \`Gov_Incremental`);
  lines.push("  )");
  lines.push(`  # (selected: ${gov.id})`);
  lines.push("");
  lines.push("  # --- Integration / rework / (optional) feedback ---");
  lines.push("  rework_months = base_rework(governance) + mismatch_factor(governance) * mismatch^1.3");
  lines.push("  months_base = max( months required by platform, signalling, power ) + rework_months");
  lines.push("");
  lines.push("  # Optional feedback (least fixed point):");
  lines.push("  # risk = base_risk + β * max(0, months - months_base) + γ * mismatch");
  lines.push("  # months = months_base * (1 + α * risk)");
  lines.push("");
  lines.push("  # --- Resources (to minimize) ---");
  lines.push("  requires capex [GBP_M]");
  lines.push("  requires months [month]");
  lines.push("  requires risk [index]");
  lines.push("  capex  ≽ (capex required by platform) + (capex required by signalling) + (capex required by power)");
  lines.push("  months ≽ months_base");
  lines.push("  risk   ≽ risk_total");
  lines.push("}");
  return lines.join("\n");
}

/** -----------------------------
 * UI wiring
 * ------------------------------
 */

const els = {
  demand: document.getElementById("demand"),
  demandOut: document.getElementById("demandOut"),
  demandLabel: document.getElementById("demandLabel"),
  paxPerCar: document.getElementById("paxPerCar"),
  paxOut: document.getElementById("paxOut"),
  maxTph: document.getElementById("maxTph"),
  maxTphOut: document.getElementById("maxTphOut"),
  capexCap: document.getElementById("capexCap"),
  capexCapOut: document.getElementById("capexCapOut"),
  riskCap: document.getElementById("riskCap"),
  riskCapOut: document.getElementById("riskCapOut"),
  governance: document.getElementById("governance"),
  govSummary: document.getElementById("govSummary"),
  feedback: document.getElementById("feedback"),
  solveBtn: document.getElementById("solveBtn"),
  sweepBtn: document.getElementById("sweepBtn"),
  resetBtn: document.getElementById("resetBtn"),
  feasibleBadge: document.getElementById("feasibleBadge"),
  feasibleText: document.getElementById("feasibleText"),
  topline: document.getElementById("topline"),
  scatter: document.getElementById("scatter"),
  gantt: document.getElementById("gantt"),
  tbl: document.getElementById("tbl"),
  countText: document.getElementById("countText"),
  countBadge: document.getElementById("countBadge"),
  selText: document.getElementById("selText"),
  selBadge: document.getElementById("selBadge"),
  iterBox: document.getElementById("iterBox"),
  mcdpl: document.getElementById("mcdpl")
};

function initGovernanceSelect(){
  els.governance.innerHTML = governanceModes.map(g=>`<option value="${g.id}">${g.label}</option>`).join("");
  els.governance.value = "Alliance";
  updateGovSummary();
}

function updateGovSummary(){
  const govId = els.governance.value;
  const gov = governanceModes.find(g=>g.id===govId) ?? governanceModes[0];
  els.govSummary.textContent = `cost×${fmt(gov.costFactor,2)}, base rework ${fmt(gov.baseReworkMonths,1)} mo, mismatch×${fmt(gov.mismatchFactor,2)}`;
}

function readInputs(){
  return {
    demand: Number(els.demand.value),
    paxPerCar: clamp(Number(els.paxPerCar.value), 60, 160),
    maxTph: clamp(Number(els.maxTph.value), 18, 34),
    capexCap: Math.max(0, Number(els.capexCap.value)),
    riskCap: Math.max(0, Number(els.riskCap.value)),
    govId: els.governance.value,
    feedback: els.feedback.checked
  };
}

function updateLabels(){
  const d = Number(els.demand.value);
  els.demandOut.textContent = d.toLocaleString();
  els.paxOut.textContent = clamp(Number(els.paxPerCar.value), 60, 160);
  els.maxTphOut.textContent = clamp(Number(els.maxTph.value), 18, 34);
  els.capexCapOut.textContent = Math.max(0, Number(els.capexCap.value)).toLocaleString();
  els.riskCapOut.textContent = Math.max(0, Number(els.riskCap.value)).toLocaleString();

  // Demand badge heuristic vs baseline (6 cars * 18 tph)
  const base = 6 * 18 * clamp(Number(els.paxPerCar.value), 60, 160);
  const dot = els.demandLabel.querySelector(".dot");
  if (d <= base) dot.className = "dot ok";
  else if (d <= base*1.3) dot.className = "dot maybe";
  else dot.className = "dot no";
}

let state = {
  all: [],
  pareto: [],
  selectedId: null,
  lastInputs: null
};

function setFeasibleBadge(kind, text){
  const dot = els.feasibleBadge.querySelector(".dot");
  if (kind==="ok") dot.className="dot ok";
  else if (kind==="no") dot.className="dot no";
  else dot.className="dot maybe";
  els.feasibleText.textContent = text;
}

function setCountBadge(n){
  const dot = els.countBadge.querySelector(".dot");
  dot.className = n>0 ? "dot ok" : "dot no";
  els.countText.textContent = `${n} plan${n===1?'':'s'}`;
}

function setSelectedBadge(plan){
  const dot = els.selBadge.querySelector(".dot");
  if (!plan){
    dot.className="dot maybe";
    els.selText.textContent="No selection";
  } else {
    dot.className="dot ok";
    els.selText.textContent = `${plan.cars} cars @ ${plan.tph} tph (${plan.sigKey}, ${plan.pwrKey}, ${plan.gov.id})`;
  }
}

function renderIterationTrace(plan){
  if (!plan || !plan.trace || !plan.trace.length){
    els.iterBox.innerHTML = "<span class='mini'>Feedback loop disabled (or no iteration trace).</span>";
    return;
  }
  const last = plan.trace.at(-1);
  const rows = plan.trace.slice(0, 10).map(t=>{
    const k = t.k;
    return `<tr><td>${k}</td><td>${fmt(t.months,2)}</td><td>${fmt(t.r,2)}</td></tr>`;
  }).join("");
  const tail = plan.trace.length > 10 ? `<div class="mini">… ${plan.trace.length-10} more iterations omitted for brevity.</div>` : "";
  els.iterBox.innerHTML = `
    <div class="mini"><b>Fixed-point iteration (first 10):</b> (k, months, risk)</div>
    <table class="tbl" style="margin-top:6px">
      <thead><tr><th>k</th><th>months</th><th>risk</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
    ${tail}
    <div class="mini" style="margin-top:6px">Last iterate: months=${fmt(last.months,2)}, risk=${fmt(last.r,2)}</div>
  `;
}

function solveAndRender(){
  const inputs = readInputs();
  state.lastInputs = inputs;

  const all = enumerateDesigns(inputs);
  const pareto = paretoMin(all);

  state.all = all;
  state.pareto = pareto;

  if (all.length === 0){
    setFeasibleBadge("no", "No feasible designs");
    els.topline.innerHTML = "<span class='warnout'>Infeasible under the current constraints. Try raising max tph, increasing capex/risk ceilings, or changing governance.</span>";
    els.tbl.innerHTML = "";
    setCountBadge(0);
    state.selectedId = null;
    drawScatter(els.scatter, [], [], null);
    drawGantt(els.gantt, {parts:{platform:{months:0},signalling:{months:0},power:{months:0}},gov:{baseReworkMonths:0,mismatchFactor:0}, mismatch:0, res:{months:0}});
    els.mcdpl.textContent = buildMcdplMirror(null, inputs);
    setSelectedBadge(null);
    renderIterationTrace(null);
    return;
  }

  setFeasibleBadge("ok", "Feasible");
  const msg = `Computed ${all.length} feasible candidates, Pareto-minimal set size ${pareto.length}.`;
  els.topline.innerHTML = `<span class="callout"><b>${msg}</b> Click a row to inspect timeline &amp; iteration trace.</span>`;
  setCountBadge(pareto.length);

  // selection: keep previous if still exists, else first Pareto plan
  if (!state.selectedId || !all.some(s=>s.id===state.selectedId)){
    state.selectedId = pareto[0]?.id ?? all[0]?.id ?? null;
  }
  const selected = all.find(s=>s.id===state.selectedId) ?? null;

  drawScatter(els.scatter, all, pareto, state.selectedId);
  drawGantt(els.gantt, selected ?? {parts:{platform:{months:0},signalling:{months:0},power:{months:0}},gov:{baseReworkMonths:0,mismatchFactor:0}, mismatch:0, res:{months:0}});
  buildTable(els.tbl, pareto, (id)=>{ state.selectedId=id; solveAndRender(); }, state.selectedId);
  setSelectedBadge(selected);
  renderIterationTrace(selected);
  els.mcdpl.textContent = buildMcdplMirror(selected ?? pareto[0], inputs);
}

function sweepDemandCurve(){
  const inputs = readInputs();
  // Sweep demand and show how the minimal cost plan changes (one-dimensional slice)
  const demandMin = 9000, demandMax = 42000, step = 1500;
  const points = [];
  for (let d=demandMin; d<=demandMax; d+=step){
    const all = enumerateDesigns({...inputs, demand:d});
    if (all.length===0){
      points.push({d, cost:NaN, months:NaN, risk:NaN});
      continue;
    }
    const pareto = paretoMin(all);
    // pick "cheapest" Pareto plan (a policy, not a truth)
    const best = pareto.reduce((a,b)=> (a.res.cost < b.res.cost ? a : b));
    points.push({d, cost:best.res.cost, months:best.res.months, risk:best.res.risk, cars:best.cars, tph:best.tph});
  }

  // Render a simple summary in topline
  const feasibleCount = points.filter(p=>Number.isFinite(p.cost)).length;
  const infeasibleCount = points.length - feasibleCount;
  let text = `<div class="callout"><b>Sweep:</b> ${feasibleCount}/${points.length} demand points feasible under current constraints.`;
  if (infeasibleCount>0) text += ` <span class="u">(${infeasibleCount} infeasible)</span>`;
  text += `</div>`;
  text += `<div class="hint" style="margin-top:8px">We’re showing the <i>cheapest</i> Pareto plan at each demand (a slice through the antichain); this is deliberately not “the optimum”.</div>`;

  // Add a tiny table
  const rows = points.map(p=>{
    const ok = Number.isFinite(p.cost);
    return `<tr>
      <td>${p.d.toLocaleString()}</td>
      <td>${ok ? fmt(p.cost,1) : "—"}</td>
      <td>${ok ? fmt(p.months,1) : "—"}</td>
      <td>${ok ? fmt(p.risk,1) : "—"}</td>
      <td class="mini">${ok ? `${p.cars} cars @ ${p.tph} tph` : "infeasible"}</td>
    </tr>`;
  }).join("");

  text += `<div style="overflow:auto; margin-top:10px">
    <table class="tbl">
      <thead><tr><th>demand</th><th>£M (cheapest Pareto)</th><th>months</th><th>risk</th><th>plan</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  </div>`;

  els.topline.innerHTML = text;
  setFeasibleBadge("ok", "Sweep shown");
}

function reset(){
  els.demand.value = 24000;
  els.paxPerCar.value = 110;
  els.maxTph.value = 28;
  els.capexCap.value = 0;
  els.riskCap.value = 0;
  els.governance.value = "Alliance";
  els.feedback.checked = true;
  state = {all:[], pareto:[], selectedId:null, lastInputs:null};
  updateGovSummary();
  updateLabels();
  setFeasibleBadge("maybe", "Not solved");
  els.topline.textContent = "Click “Solve” to compute minimal resource bundles for the chosen demand.";
  els.tbl.innerHTML = "";
  setCountBadge(0);
  drawScatter(els.scatter, [], [], null);
  drawGantt(els.gantt, {parts:{platform:{months:0},signalling:{months:0},power:{months:0}},gov:{baseReworkMonths:0,mismatchFactor:0}, mismatch:0, res:{months:0}});
  els.mcdpl.textContent = buildMcdplMirror(null, readInputs());
  setSelectedBadge(null);
  renderIterationTrace(null);
}

/** Polyfill for roundRect in older canvas */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    const radius = typeof r === 'number' ? {tl:r,tr:r,br:r,bl:r} : {tl:r.tl||0,tr:r.tr||0,br:r.br||0,bl:r.bl||0};
    this.beginPath();
    this.moveTo(x + radius.tl, y);
    this.lineTo(x + w - radius.tr, y);
    this.quadraticCurveTo(x + w, y, x + w, y + radius.tr);
    this.lineTo(x + w, y + h - radius.br);
    this.quadraticCurveTo(x + w, y + h, x + w - radius.br, y + h);
    this.lineTo(x + radius.bl, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - radius.bl);
    this.lineTo(x, y + radius.tl);
    this.quadraticCurveTo(x, y, x + radius.tl, y);
    this.closePath();
    return this;
  };
}

function boot(){
  initGovernanceSelect();
  updateLabels();
  els.mcdpl.textContent = buildMcdplMirror(null, readInputs());

  els.demand.addEventListener("input", updateLabels);
  els.paxPerCar.addEventListener("input", updateLabels);
  els.maxTph.addEventListener("input", updateLabels);
  els.capexCap.addEventListener("input", updateLabels);
  els.riskCap.addEventListener("input", updateLabels);
  els.governance.addEventListener("change", ()=>{ updateGovSummary(); });
  els.solveBtn.addEventListener("click", solveAndRender);
  els.sweepBtn.addEventListener("click", sweepDemandCurve);
  els.resetBtn.addEventListener("click", reset);

  // initial empty render
  drawScatter(els.scatter, [], [], null);
  drawGantt(els.gantt, {parts:{platform:{months:0},signalling:{months:0},power:{months:0}},gov:{baseReworkMonths:0,mismatchFactor:0}, mismatch:0, res:{months:0}});
}
boot();
</script>
</body>
</html>
