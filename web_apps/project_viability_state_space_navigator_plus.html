<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project Viability State-Space Navigator (Plus)</title>

<!-- D3.js -->
<script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>

<style>
  :root{
    --bg:#0f1115;
    --panel:#151924;
    --panel2:#111522;
    --text:#e7e9ee;
    --muted:#aab0bd;
    --accent:#7aa2ff;
    --good:#4caf50;
    --mid:#ff9800;
    --bad:#f44336;
    --line:#2a3146;
  }
  body{
    margin:0; height:100vh; display:flex; flex-direction:column;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:var(--bg); color:var(--text);
  }
  #toolbar{
    display:flex; gap:10px; align-items:center;
    padding:10px 12px; background:var(--panel);
    border-bottom:1px solid var(--line);
    flex-wrap:wrap;
  }
  #main{ flex:1; min-height:0; display:flex; }
  #panel{
    width:360px; max-width:45vw; min-width:320px;
    background:var(--panel2); border-right:1px solid var(--line);
    overflow:auto; padding:12px;
  }
  #cy{ flex:1; min-width:0; }
  #cy svg{ width:100%; height:100%; display:block; }
  .node circle{ stroke:#0f1115; }
  .node.start circle{ stroke:var(--accent); stroke-width:5; }
  .node.attractor circle{ stroke-dasharray:4 2; stroke-width:6; }
  .node.selected circle{ stroke:var(--accent); }
  .link{ fill:none; stroke:#667099; stroke-opacity:0.9; }
  .link.selected{ stroke:var(--accent); }
  .edge-label{ font-size:9px; fill:#e7e9ee; paint-order:stroke; stroke:#0f1115; stroke-width:3; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .col{ display:flex; flex-direction:column; gap:6px; }
  .section{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
    background:rgba(255,255,255,0.02);
    margin-bottom:10px;
  }
  .section h3{
    margin:0 0 8px 0; font-size:13px; letter-spacing:0.02em;
    color:var(--muted); font-weight:650;
  }
  label{ font-size:12px; color:var(--muted); }
  input[type="range"]{ width:180px; }
  input[type="number"], input[type="text"], textarea, select{
    background:#0c0f18; color:var(--text);
    border:1px solid var(--line);
    border-radius:8px; padding:8px;
    font-size:13px;
    outline:none;
  }
  textarea{ min-height:70px; resize:vertical; }
  button{
    background:#1b2236; color:var(--text);
    border:1px solid var(--line);
    border-radius:10px;
    padding:8px 10px;
    font-size:13px;
    cursor:pointer;
  }
  button:hover{ border-color:#3a4567; }
  button.primary{ background:#203057; border-color:#2f3d67; }
  button.danger{ background:#3b1f25; border-color:#5a2b35; }
  .pill{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px;
    border:1px solid var(--line);
    background:rgba(255,255,255,0.03);
    font-size:12px; color:var(--muted);
  }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
  .dot.good{ background:var(--good); }
  .dot.mid{ background:var(--mid); }
  .dot.bad{ background:var(--bad); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
  #history{ display:flex; flex-direction:column; gap:6px; }
  .histItem{
    border:1px solid var(--line);
    border-radius:10px;
    padding:8px;
    background:rgba(0,0,0,0.15);
    color:var(--muted);
    font-size:12px;
    line-height:1.25;
  }
  .small{ font-size:12px; color:var(--muted); }
  .rightSpacer{ margin-left:auto; }
</style>
</head>

<body>
  <div id="toolbar">
    <div class="row">
      <span class="pill"><span class="dot good"></span>stable</span>
      <span class="pill"><span class="dot mid"></span>marginal</span>
      <span class="pill"><span class="dot bad"></span>non-viable</span>
    </div>

    <div class="row">
      <label>Viability threshold <span id="thrLabel" class="mono">0.50</span></label>
      <input id="thr" type="range" min="0" max="1" step="0.01" value="0.50"/>
    </div>

    <div class="row">
      <label>Edge cutoff p ≥ <span id="pCutLabel" class="mono">0.00</span></label>
      <input id="pCut" type="range" min="0" max="1" step="0.01" value="0.00"/>
    </div>

    <button id="probeBtn" class="primary">Safe-to-fail probe</button>
    <button id="walkBtn">Walk</button>
    <input id="walkSteps" type="number" min="1" max="50000" value="250" style="width:90px" title="Walk steps"/>

    <button id="relayoutBtn">Relayout</button>
    <button id="undoBtn">Undo</button>
    <button id="resetBtn" class="danger">Reset</button>

    <div class="rightSpacer"></div>

    <button id="pngBtn">PNG</button>
    <button id="exportBtn">Export JSON</button>
    <label class="pill" style="cursor:pointer;">
      Import JSON
      <input id="importFile" type="file" accept=".json,application/json" style="display:none"/>
    </label>
  </div>

  <div id="main">
    <div id="panel">
      <div class="section">
        <h3>Model + simulation controls</h3>
        <div class="row">
          <div class="col" style="flex:1;">
            <label>Start state</label>
            <select id="startSelect"></select>
          </div>
          <div class="col" style="flex:1;">
            <label>RNG seed (repeatable probes)</label>
            <input id="seed" type="text" value="rowland41" placeholder="any string"/>
          </div>
        </div>

        <div class="row">
          <div class="col">
            <label>Probe amplitude (viability Δ)</label>
            <input id="amp" type="range" min="0" max="0.5" step="0.01" value="0.20"/>
            <div class="small">Current: <span id="ampLabel" class="mono">0.20</span></div>
          </div>
          <div class="col">
            <label>Probability nudge (p Δ)</label>
            <input id="pAmp" type="range" min="0" max="0.5" step="0.01" value="0.15"/>
            <div class="small">Current: <span id="pAmpLabel" class="mono">0.15</span></div>
          </div>
        </div>

        <div class="row">
          <label class="pill" style="cursor:pointer;">
            <input id="applyDv" type="checkbox" />
            Apply dv impacts during walk
          </label>
          <label class="pill" style="cursor:pointer;">
            <input id="showEdgeLabels" type="checkbox" />
            Show edge labels
          </label>
          <label class="pill" style="cursor:pointer;">
            <input id="autoRelayout" type="checkbox" checked/>
            Auto-relayout on structural probe
          </label>
        </div>

        <div class="row">
          <div class="col" style="flex:1;">
            <label>Probe palette (enabled probe types)</label>
            <div class="row">
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="v" checked/> viability nudge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="p" checked/> p nudge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="add" checked/> add edge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="rm" checked/> remove edge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="rew" checked/> rewire edge</label>
            </div>
          </div>
        </div>

        <div class="row">
          <button id="clearHeatBtn">Clear heat</button>
          <button id="focusAttractorsBtn">Focus attractors</button>
        </div>

        <div class="small">
          <span class="mono">JSON schema</span> (minimal):<br/>
          <span class="mono">{"states":[{"id":"S1","label":"...","viability":0.7}],"transitions":[{"from":"S1","to":"S2","p":0.4,"dv":-0.05,"label":"..."}],"meta":{"start":"S1"}}</span>
        </div>
      </div>

      <div class="section">
        <h3>System diagnostics</h3>
        <div id="stats" class="mono"></div>
      </div>

      <div class="section">
        <h3>Inspector (click a node or edge)</h3>
        <div id="inspector" class="small">Nothing selected.</div>
      </div>

      <div class="section">
        <h3>History</h3>
        <div id="history"></div>
      </div>
    </div>

    <div id="cy"></div>
  </div>

<script>
/* ---------------------------
   Utility: cloning + RNG
---------------------------- */
function deepClone(obj){
  if (typeof structuredClone === "function") return structuredClone(obj);
  return JSON.parse(JSON.stringify(obj));
}

// Seeded RNG (mulberry32) + string hashing.
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
let rng = Math.random;
function setSeedFromString(s){
  const seedGen = xmur3(String(s ?? ""));
  const seed = seedGen();
  rng = mulberry32(seed);
  return seed;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  if (total <= 0) return items[Math.floor(rng()*items.length)];
  let r = rng() * total;
  for (let i=0;i<items.length;i++){
    r -= weights[i];
    if (r <= 0) return items[i];
  }
  return items[items.length-1];
}

/* ---------------------------
   Default model
---------------------------- */
const baseline = {
  meta: { title: "Steel-mill-esque toy model", start: "S1" },
  states: [
    { id:"S1", label:"Baseline Ops", viability:0.72, notes:"Normal throughput; manageable variance." },
    { id:"S2", label:"New Vendor", viability:0.55, notes:"Interface churn; paperwork + integration debt." },
    { id:"S3", label:"Automation", viability:0.83, notes:"Higher throughput; brittleness if skills decay." },
    { id:"S4", label:"Industrial Action", viability:0.32, notes:"Coordination cost spikes; governance stress." },
    { id:"S5", label:"Market Shock", viability:0.18, notes:"Demand collapse; cash constraints dominate." }
  ],
  transitions: [
    { from:"S1", to:"S2", p:0.35, dv:-0.02, label:"vendor swap" },
    { from:"S2", to:"S3", p:0.55, dv:+0.04, label:"stabilise + automate" },
    { from:"S1", to:"S4", p:0.15, dv:-0.08, label:"labour dispute" },
    { from:"S4", to:"S5", p:0.60, dv:-0.10, label:"strike + shock" },
    { from:"S3", to:"S5", p:0.10, dv:-0.12, label:"automation backlash" },
    { from:"S5", to:"S1", p:0.25, dv:+0.06, label:"restructure" },
    { from:"S3", to:"S1", p:0.30, dv:-0.03, label:"reversion" }
  ]
};

let model = deepClone(baseline);
let thr = 0.50;
let pCut = 0.00;
let startId = model?.meta?.start || (model.states[0]?.id ?? "S1");
let heat = { node:{}, edge:{} }; // counts from walks

/* ---------------------------
   D3 graph state
---------------------------- */
let svg = null;
let g = null;
let linkGroup = null;
let labelGroup = null;
let nodeGroup = null;
let simulation = null;
let zoom = null;
let width = 800;
let height = 600;
let graphNodes = [];
let graphLinks = [];
let nodeById = new Map();

function nodeRadius(d){
  return 22 + clamp01(d.v ?? 0.5) * 22;
}

function initD3(){
  const container = document.getElementById("cy");
  container.innerHTML = "";

  const rect = container.getBoundingClientRect();
  width = rect.width || 800;
  height = rect.height || 600;

  svg = d3.select(container)
    .append("svg")
    .attr("width", "100%")
    .attr("height", "100%")
    .attr("viewBox", `0 0 ${width} ${height}`)
    .attr("role", "img")
    .attr("aria-label", "Project viability state-space graph");

  const defs = svg.append("defs");
  defs.append("marker")
    .attr("id", "arrow")
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 12)
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", "#667099");

  g = svg.append("g").attr("class", "graph-layer");
  linkGroup = g.append("g").attr("class", "links");
  labelGroup = g.append("g").attr("class", "labels");
  nodeGroup = g.append("g").attr("class", "nodes");

  zoom = d3.zoom()
    .scaleExtent([0.2, 4])
    .on("zoom", (event) => g.attr("transform", event.transform));

  svg.call(zoom);
  svg.on("click", (event) => {
    if (event.target === svg.node()) clearSelection();
  });

  simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(d => d.id).distance(140).strength(0.2))
    .force("charge", d3.forceManyBody().strength(-420))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(d => nodeRadius(d) + 6));

  simulation.on("tick", ticked);

  const resizeObserver = new ResizeObserver(() => {
    const next = container.getBoundingClientRect();
    width = next.width || width;
    height = next.height || height;
    svg.attr("viewBox", `0 0 ${width} ${height}`);
    simulation.force("center", d3.forceCenter(width / 2, height / 2));
    simulation.alpha(0.3).restart();
  });
  resizeObserver.observe(container);
}

function ticked(){
  linkGroup.selectAll("path")
    .attr("d", d => {
      const s = d.source;
      const t = d.target;
      if (!s || !t) return "";
      return `M${s.x},${s.y} L${t.x},${t.y}`;
    });

  labelGroup.selectAll("text")
    .attr("x", d => (d.source?.x + d.target?.x) / 2)
    .attr("y", d => (d.source?.y + d.target?.y) / 2);

  nodeGroup.selectAll("g.node")
    .attr("transform", d => `translate(${d.x},${d.y})`);
}

function updateSimulationLinks(){
  const visibleLinks = graphLinks.filter(l => l.visible);
  simulation.force("link").links(visibleLinks);
  simulation.force("collision", d3.forceCollide().radius(d => nodeRadius(d) + 6));
  simulation.alpha(0.6).restart();
}

function updateGraph(){
  nodeById = new Map(graphNodes.map(n => [n.id, n]));
  graphLinks.forEach(l => {
    l.source = nodeById.get(l.sourceId);
    l.target = nodeById.get(l.targetId);
  });

  simulation.nodes(graphNodes);

  const linkSel = linkGroup.selectAll("path").data(graphLinks, d => d.id);
  linkSel.exit().remove();
  linkSel.enter()
    .append("path")
    .attr("class", "link")
    .attr("marker-end", "url(#arrow)")
    .on("click", (event, d) => {
      event.stopPropagation();
      selectEdge(d);
    });

  const labelSel = labelGroup.selectAll("text").data(graphLinks, d => d.id);
  labelSel.exit().remove();
  labelSel.enter()
    .append("text")
    .attr("class", "edge-label")
    .attr("text-anchor", "middle")
    .style("pointer-events", "none");

  const nodeSel = nodeGroup.selectAll("g.node").data(graphNodes, d => d.id);
  nodeSel.exit().remove();
  const nodeEnter = nodeSel.enter()
    .append("g")
    .attr("class", "node")
    .on("click", (event, d) => {
      event.stopPropagation();
      selectNode(d);
    })
    .call(d3.drag()
      .on("start", (event, d) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", (event, d) => {
        d.fx = event.x;
        d.fy = event.y;
      })
      .on("end", (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = event.x;
        d.fy = event.y;
      })
    );

  nodeEnter.append("circle");
  nodeEnter.append("text")
    .attr("class", "node-label")
    .attr("text-anchor", "middle")
    .attr("dy", "0.35em");

  updateGraphStyles();
  updateSimulationLinks();
}

function updateGraphStyles(){
  nodeGroup.selectAll("g.node")
    .classed("start", d => d.isStart)
    .classed("attractor", d => d.isAttractor)
    .classed("selected", d => selected.kind === "node" && selected.id === d.id)
    .select("circle")
    .attr("r", d => nodeRadius(d))
    .attr("fill", d => colourForViability(d.v))
    .attr("stroke-width", d => {
      const base = 1 + 7 * (d.h ?? 0);
      if (selected.kind === "node" && selected.id === d.id) return Math.max(base, 5);
      if (d.isStart) return Math.max(base, 5);
      if (d.isAttractor) return Math.max(base, 6);
      return base;
    })
    .attr("stroke-dasharray", d => (d.isAttractor ? "4 2" : null))
    .attr("stroke", d => {
      if (selected.kind === "node" && selected.id === d.id) return "#7aa2ff";
      if (d.isStart) return "#7aa2ff";
      return "#0f1115";
    });

  nodeGroup.selectAll("g.node text")
    .text(d => d.label)
    .attr("font-size", 10)
    .attr("fill", "#e7e9ee");

  linkGroup.selectAll("path")
    .classed("selected", d => selected.kind === "edge" && selected.id === d.id)
    .style("display", d => d.visible ? null : "none")
    .attr("stroke", d => (selected.kind === "edge" && selected.id === d.id) ? "#7aa2ff" : "#667099")
    .attr("stroke-width", d => 1 + 6 * (d.w ?? 0));

  labelGroup.selectAll("text")
    .text(d => d.labelText ?? "")
    .style("display", d => (d.visible && d.labelVisible) ? null : "none");

  const marker = svg.select("#arrow path");
  if (!marker.empty()) marker.attr("fill", "#667099");
}

function runLayout(){
  graphNodes.forEach(n => {
    n.fx = null;
    n.fy = null;
  });
  simulation.alpha(1).restart();
}

/* ---------------------------
   Model <-> graph render
---------------------------- */
function normalizeModel(m){
  if (!m || !Array.isArray(m.states) || !Array.isArray(m.transitions)) {
    throw new Error("JSON must contain 'states' and 'transitions' arrays.");
  }

  const ids = new Set();
  m.states = m.states.map(s => {
    if (!s.id) throw new Error("Every state needs an 'id'.");
    if (ids.has(s.id)) throw new Error("Duplicate state id: " + s.id);
    ids.add(s.id);
    return {
      id: String(s.id),
      label: String(s.label ?? s.id),
      viability: clamp01(Number(s.viability ?? 0.5)),
      notes: String(s.notes ?? "")
    };
  });

  const existing = new Set();
  m.transitions = m.transitions
    .filter(t => t && t.from && t.to)
    .map(t => {
      const from = String(t.from), to = String(t.to);
      if (!ids.has(from) || !ids.has(to)) return null;
      const key = from + "->" + to;
      // allow parallel edges? we choose no: collapse duplicates by keeping first
      if (existing.has(key)) return null;
      existing.add(key);
      return {
        from,
        to,
        p: clamp01(Number(t.p ?? 1.0)),
        dv: Number(t.dv ?? 0),
        label: String(t.label ?? "")
      };
    })
    .filter(Boolean);

  if (!m.meta) m.meta = {};
  m.meta.title = String(m.meta.title ?? "Untitled");
  m.meta.start = String(m.meta.start ?? m.states[0]?.id ?? "");
  if (!ids.has(m.meta.start)) m.meta.start = m.states[0]?.id ?? "";

  // layout is optional; pass-through if present
  if (m.layout && Array.isArray(m.layout.positions)) {
    m.layout.positions = m.layout.positions
      .filter(p => p && ids.has(String(p.id)))
      .map(p => ({ id:String(p.id), x:Number(p.x), y:Number(p.y) }));
  } else {
    m.layout = null;
  }

  return m;
}

function buildGraphFromModel(m){
  graphNodes = m.states.map(s => ({
    id: s.id,
    label: s.label,
    v: s.viability,
    notes: s.notes,
    h: 0,
    isStart: false,
    isAttractor: false
  }));

  graphLinks = m.transitions.map(t => ({
    id: `${t.from}->${t.to}`,
    sourceId: t.from,
    targetId: t.to,
    source: t.from,
    target: t.to,
    p: t.p,
    dv: t.dv,
    label: t.label,
    labelText: "",
    labelVisible: false,
    w: 0,
    visible: true
  }));
}

function capturePositions(){
  const pos = new Map();
  graphNodes.forEach(n => {
    if (Number.isFinite(n.x) && Number.isFinite(n.y)) {
      pos.set(n.id, { x:n.x, y:n.y, fx:n.fx, fy:n.fy });
    }
  });
  return pos;
}

function restorePositions(posMap){
  if (!posMap) return;
  graphNodes.forEach(n => {
    const p = posMap.get(n.id);
    if (p) {
      n.x = p.x;
      n.y = p.y;
      n.fx = p.fx ?? p.x;
      n.fy = p.fy ?? p.y;
    }
  });
}

function applyImportedLayout(m){
  if (!m?.layout?.positions) return;
  const posMap = new Map(m.layout.positions.map(p => [p.id, {x:p.x, y:p.y}]));
  graphNodes.forEach(n => {
    const p = posMap.get(n.id);
    if (p) {
      n.x = p.x;
      n.y = p.y;
      n.fx = p.x;
      n.fy = p.y;
    }
  });
}

function renderModel({preservePositions=true, relayout=false} = {}){
  const posMap = preservePositions ? capturePositions() : null;

  buildGraphFromModel(model);

  restorePositions(posMap);
  applyImportedLayout(model);

  ensureStartState();
  updateStartDropdown();
  updateEdgeLabelVisibility();
  applyEdgeFilter();
  recomputeAnalysisAndStyle();

  updateGraph();

  if (relayout) runLayout();
}

/* ---------------------------
   Styling + analysis
---------------------------- */
function colourForViability(v){
  if (v >= thr) return getComputedStyle(document.documentElement).getPropertyValue("--good").trim();
  if (v >= thr * 0.6) return getComputedStyle(document.documentElement).getPropertyValue("--mid").trim();
  return getComputedStyle(document.documentElement).getPropertyValue("--bad").trim();
}

function applyEdgeFilter(){
  graphLinks.forEach(e => {
    e.visible = Number(e.p ?? 1) >= pCut;
  });
}

function updateEdgeLabelVisibility(){
  const show = document.getElementById("showEdgeLabels").checked;
  graphLinks.forEach(e => {
    if (!show) {
      e.labelVisible = false;
      return;
    }
    const p = Number(e.p ?? 1);
    const dv = Number(e.dv ?? 0);
    const label = e.label;
    const composed = (label && label.trim().length)
      ? label
      : `p=${p.toFixed(2)} dv=${dv.toFixed(2)}`;
    e.labelText = composed;
    e.labelVisible = true;
  });
}

function buildAdjacencyFromVisibleEdges(){
  const ids = model.states.map(s => s.id);
  const adj = new Map(ids.map(id => [id, []]));
  graphLinks.filter(e => e.visible).forEach(e => {
    if (adj.has(e.sourceId)) adj.get(e.sourceId).push(e.targetId);
  });
  return adj;
}

// Tarjan SCC for directed graphs
function tarjanSCC(ids, adj){
  let index = 0;
  const stack = [];
  const onStack = new Set();
  const indices = new Map();
  const lowlink = new Map();
  const sccs = [];

  function strongconnect(v){
    indices.set(v, index);
    lowlink.set(v, index);
    index++;
    stack.push(v);
    onStack.add(v);

    for (const w of (adj.get(v) || [])){
      if (!indices.has(w)){
        strongconnect(w);
        lowlink.set(v, Math.min(lowlink.get(v), lowlink.get(w)));
      } else if (onStack.has(w)){
        lowlink.set(v, Math.min(lowlink.get(v), indices.get(w)));
      }
    }

    if (lowlink.get(v) === indices.get(v)){
      const scc = [];
      while (true){
        const w = stack.pop();
        onStack.delete(w);
        scc.push(w);
        if (w === v) break;
      }
      sccs.push(scc);
    }
  }

  for (const v of ids){
    if (!indices.has(v)) strongconnect(v);
  }
  return sccs;
}

function detectAttractors(ids, adj, sccs){
  const nodeToScc = new Map();
  sccs.forEach((scc, i) => scc.forEach(id => nodeToScc.set(id, i)));

  // quick self-loop check
  const hasSelfLoop = new Set();
  for (const [from, tos] of adj.entries()){
    if (tos.includes(from)) hasSelfLoop.add(from);
  }

  const attractorSccIdx = new Set();
  for (let i=0;i<sccs.length;i++){
    const scc = sccs[i];
    const sccSet = new Set(scc);

    let outgoing = false;
    for (const v of scc){
      for (const w of (adj.get(v) || [])){
        if (!sccSet.has(w)) { outgoing = true; break; }
      }
      if (outgoing) break;
    }

    const isCycle = (scc.length > 1) || (scc.length === 1 && hasSelfLoop.has(scc[0]));
    if (!outgoing && isCycle) attractorSccIdx.add(i);
  }

  const attractorNodes = new Set();
  attractorSccIdx.forEach(i => sccs[i].forEach(n => attractorNodes.add(n)));

  return { attractorNodes, attractorSccIdx };
}

function recomputeAnalysisAndStyle(){
  const maxNodeHeat = Math.max(1, ...Object.values(heat.node));
  const maxEdgeHeat = Math.max(1, ...Object.values(heat.edge));

  graphNodes.forEach(n => {
    const st = model.states.find(s => s.id === n.id);
    if (st) {
      n.v = st.viability;
      n.label = st.label;
      n.notes = st.notes;
    }

    const h = (heat.node[n.id] ?? 0) / maxNodeHeat;
    n.h = clamp01(h);

    n.isStart = n.id === startId;
    n.isAttractor = false;
  });

  graphLinks.forEach(e => {
    const h = (heat.edge[e.id] ?? 0) / maxEdgeHeat;
    const p = Number(e.p ?? 1);
    const w = clamp01(0.15 + 0.85 * p) * 0.65 + clamp01(h) * 0.35;
    e.w = clamp01(w);
  });

  const ids = model.states.map(s => s.id);
  const adj = buildAdjacencyFromVisibleEdges();
  const sccs = tarjanSCC(ids, adj);
  const { attractorNodes, attractorSccIdx } = detectAttractors(ids, adj, sccs);

  graphNodes.forEach(n => {
    if (attractorNodes.has(n.id)) n.isAttractor = true;
  });

  updateStats({ ids, adj, sccs, attractorNodes, attractorSccIdx });
  updateHistoryUI();
  updateGraphStyles();
}

function updateStats({ ids, adj, sccs, attractorNodes }){
  const vs = graphNodes.map(n => Number(n.v ?? 0.5));
  const avgV = vs.reduce((a,b)=>a+b,0) / Math.max(1, vs.length);

  let stable=0, marginal=0, bad=0;
  for (const v of vs){
    if (v >= thr) stable++;
    else if (v >= thr*0.6) marginal++;
    else bad++;
  }

  const degreeMap = new Map(graphNodes.map(n => [n.id, { in:0, out:0 }]));
  graphLinks.forEach(e => {
    const source = degreeMap.get(e.sourceId);
    const target = degreeMap.get(e.targetId);
    if (source) source.out += 1;
    if (target) target.in += 1;
  });

  const risk = graphNodes.map(n => {
    const v = Number(n.v ?? 0.5);
    const deg = (degreeMap.get(n.id)?.in ?? 0) + (degreeMap.get(n.id)?.out ?? 0);
    const score = (deg + 1) * (1 - v);
    return { id:n.id, label:n.label, v, deg, score };
  }).sort((a,b)=>b.score-a.score).slice(0,5);

  const attractorList = [];
  if (attractorNodes.size){
    attractorList.push([...attractorNodes].join(", "));
  }

  const visibleEdges = graphLinks.filter(e => e.visible).length;
  document.getElementById("stats").textContent =
`title: ${model?.meta?.title ?? "Untitled"}
nodes: ${graphNodes.length} | edges: ${graphLinks.length} (visible ${visibleEdges})
avg viability: ${avgV.toFixed(3)} | threshold: ${thr.toFixed(2)}
stable/marginal/bad: ${stable}/${marginal}/${bad}

SCCs (visible graph): ${sccs.length}
attractor nodes: ${attractorNodes.size}${attractorNodes.size ? " -> " + [...attractorNodes].slice(0,12).join(", ") + (attractorNodes.size>12?" …":"") : ""}

top risk (deg*(1-v)):
${risk.map(r => `- ${r.id} "${r.label}" v=${r.v.toFixed(2)} deg=${r.deg} score=${r.score.toFixed(2)}`).join("\n")}
`;
}

/* ---------------------------
   Start state + dropdown
---------------------------- */
function ensureStartState(){
  const ids = new Set(model.states.map(s => s.id));
  if (!ids.has(startId)) startId = model.states[0]?.id ?? "";
  model.meta.start = startId;
}
function updateStartDropdown(){
  const sel = document.getElementById("startSelect");
  const current = startId;

  sel.innerHTML = "";
  for (const s of model.states){
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = `${s.id}: ${s.label}`;
    if (s.id === current) opt.selected = true;
    sel.appendChild(opt);
  }
}

/* ---------------------------
   Undo + history
---------------------------- */
const undoStack = [];
const hist = [];

function pushUndo(label){
  const snapshot = {
    label,
    model: deepClone(model),
    heat: deepClone(heat),
    positions: [...capturePositions().entries()].map(([id,p]) => ({id, x:p.x, y:p.y}))
  };
  undoStack.push(snapshot);
  hist.unshift({ when: new Date().toISOString(), label });
  if (hist.length > 40) hist.pop();
}

function undo(){
  const snap = undoStack.pop();
  if (!snap) return;
  model = normalizeModel(deepClone(snap.model));
  heat = deepClone(snap.heat);

  renderModel({preservePositions:false, relayout:false});

  const posMap = new Map(snap.positions.map(p => [p.id, {x:p.x, y:p.y}]));
  restorePositions(posMap);

  recomputeAnalysisAndStyle();
}

function updateHistoryUI(){
  const el = document.getElementById("history");
  el.innerHTML = "";
  if (!hist.length){
    el.innerHTML = `<div class="histItem">No actions yet.</div>`;
    return;
  }
  for (const h of hist.slice(0,18)){
    const div = document.createElement("div");
    div.className = "histItem";
    div.textContent = `${h.when.replace("T"," ").replace("Z","")} — ${h.label}`;
    el.appendChild(div);
  }
}

/* ---------------------------
   Inspector (node + edge)
---------------------------- */
let selected = { kind:null, id:null };

function clearSelection(){
  selected = {kind:null,id:null};
  updateGraphStyles();
  document.getElementById("inspector").innerHTML = "Nothing selected.";
}

function selectNode(n){
  selected = { kind:"node", id:n.id };
  updateGraphStyles();

  const s = model.states.find(x => x.id === n.id);
  const v = Number(s?.viability ?? n.v ?? 0.5);

  document.getElementById("inspector").innerHTML = `
    <div class="col">
      <div><span class="mono">id</span>: <span class="mono">${n.id}</span></div>

      <label>label</label>
      <input id="i_label" type="text" value="${escapeHtml(s?.label ?? n.label ?? n.id)}"/>

      <label>viability <span class="mono" id="i_vLabel">${v.toFixed(2)}</span></label>
      <input id="i_v" type="range" min="0" max="1" step="0.01" value="${v.toFixed(2)}"/>

      <label>notes</label>
      <textarea id="i_notes">${escapeHtml(s?.notes ?? "")}</textarea>

      <div class="row">
        <button id="i_apply" class="primary">Apply</button>
        <button id="i_setStart">Set start</button>
      </div>
      <div class="small">Tip: start state gets a blue border; attractors are dashed-border SCCs.</div>
    </div>
  `;

  const vSlider = document.getElementById("i_v");
  const vLab = document.getElementById("i_vLabel");
  vSlider.addEventListener("input", e => vLab.textContent = Number(e.target.value).toFixed(2));

  document.getElementById("i_apply").addEventListener("click", () => {
    pushUndo(`edit node ${n.id}`);
    const label = document.getElementById("i_label").value;
    const viability = clamp01(Number(document.getElementById("i_v").value));
    const notes = document.getElementById("i_notes").value;

    const st = model.states.find(x => x.id === n.id);
    if (st){
      st.label = label;
      st.viability = viability;
      st.notes = notes;
    }
    n.label = label;
    n.v = viability;
    n.notes = notes;

    recomputeAnalysisAndStyle();
    selectNode(n);
  });

  document.getElementById("i_setStart").addEventListener("click", () => {
    pushUndo(`set start ${n.id}`);
    startId = n.id;
    model.meta.start = startId;
    recomputeAnalysisAndStyle();
    updateStartDropdown();
    selectNode(n);
  });
}

function selectEdge(e){
  selected = { kind:"edge", id:e.id };
  updateGraphStyles();

  const t = model.transitions.find(x => (x.from + "->" + x.to) === e.id);
  const p = Number(t?.p ?? e.p ?? 1);
  const dv = Number(t?.dv ?? e.dv ?? 0);
  const label = String(t?.label ?? e.label ?? "");

  document.getElementById("inspector").innerHTML = `
    <div class="col">
      <div><span class="mono">edge</span>: <span class="mono">${escapeHtml(e.id)}</span></div>
      <div class="small">from <span class="mono">${escapeHtml(e.sourceId)}</span> to <span class="mono">${escapeHtml(e.targetId)}</span></div>

      <label>label (optional)</label>
      <input id="e_label" type="text" value="${escapeHtml(label)}"/>

      <label>probability p <span class="mono" id="e_pLabel">${p.toFixed(2)}</span></label>
      <input id="e_p" type="range" min="0" max="1" step="0.01" value="${p.toFixed(2)}"/>

      <label>impact dv (optional) <span class="mono" id="e_dvLabel">${dv.toFixed(2)}</span></label>
      <input id="e_dv" type="range" min="-0.5" max="0.5" step="0.01" value="${dv.toFixed(2)}"/>

      <div class="row">
        <button id="e_apply" class="primary">Apply</button>
      </div>
      <div class="small">Walk uses p as weights; if “Apply dv impacts” is on, dv shifts target viability on traversal.</div>
    </div>
  `;

  const pSlider = document.getElementById("e_p");
  const pLab = document.getElementById("e_pLabel");
  pSlider.addEventListener("input", ev => pLab.textContent = Number(ev.target.value).toFixed(2));

  const dvSlider = document.getElementById("e_dv");
  const dvLab = document.getElementById("e_dvLabel");
  dvSlider.addEventListener("input", ev => dvLab.textContent = Number(ev.target.value).toFixed(2));

  document.getElementById("e_apply").addEventListener("click", () => {
    pushUndo(`edit edge ${e.id}`);
    const newLabel = document.getElementById("e_label").value;
    const newP = clamp01(Number(document.getElementById("e_p").value));
    const newDv = Number(document.getElementById("e_dv").value);

    const tr = model.transitions.find(x => (x.from + "->" + x.to) === e.id);
    if (tr){
      tr.label = newLabel;
      tr.p = newP;
      tr.dv = newDv;
    }
    e.label = newLabel;
    e.p = newP;
    e.dv = newDv;

    updateEdgeLabelVisibility();
    applyEdgeFilter();
    recomputeAnalysisAndStyle();
    selectEdge(e);
  });
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;");
}

/* ---------------------------
   Safe-to-fail probes
---------------------------- */
function enabledProbeTypes(){
  return [...document.querySelectorAll(".probeType")]
    .filter(x => x.checked)
    .map(x => x.value);
}

function probe(){
  setSeedFromString(document.getElementById("seed").value);
  const types = enabledProbeTypes();
  if (!types.length) return;

  const amp = Number(document.getElementById("amp").value);
  const pAmp = Number(document.getElementById("pAmp").value);

  pushUndo("safe-to-fail probe");

  const type = types[Math.floor(rng() * types.length)];
  const ids = model.states.map(s => s.id);

  const edgeKey = (t) => t.from + "->" + t.to;

  function addHistoryLabel(s){
    hist.unshift({ when: new Date().toISOString(), label: s });
    if (hist.length > 40) hist.pop();
  }

  if (type === "v"){
    const s = model.states[Math.floor(rng()*model.states.length)];
    const delta = (rng()*2 - 1) * amp;
    s.viability = clamp01(s.viability + delta);
    addHistoryLabel(`probe: viability ${s.id} += ${delta.toFixed(2)}`);
  }
  else if (type === "p" && model.transitions.length){
    const t = model.transitions[Math.floor(rng()*model.transitions.length)];
    const delta = (rng()*2 - 1) * pAmp;
    t.p = clamp01(t.p + delta);
    addHistoryLabel(`probe: p ${edgeKey(t)} += ${delta.toFixed(2)}`);
  }
  else if (type === "add"){
    const existing = new Set(model.transitions.map(edgeKey));
    let tries = 30;
    while (tries--){
      const from = ids[Math.floor(rng()*ids.length)];
      const to = ids[Math.floor(rng()*ids.length)];
      if (from === to) continue;
      const k = from + "->" + to;
      if (existing.has(k)) continue;

      model.transitions.push({ from, to, p: clamp01(0.10 + rng()*0.40), dv: 0, label:"" });
      addHistoryLabel(`probe: add edge ${k}`);
      break;
    }
  }
  else if (type === "rm" && model.transitions.length){
    const idx = Math.floor(rng()*model.transitions.length);
    const k = edgeKey(model.transitions[idx]);
    model.transitions.splice(idx, 1);
    addHistoryLabel(`probe: remove edge ${k}`);
  }
  else if (type === "rew" && model.transitions.length){
    const t = model.transitions[Math.floor(rng()*model.transitions.length)];
    const old = edgeKey(t);
    let tries = 20;
    while (tries--){
      const to = ids[Math.floor(rng()*ids.length)];
      if (to === t.from) continue;
      const k = t.from + "->" + to;
      if (model.transitions.some(x => (x.from + "->" + x.to) === k)) continue;
      t.to = to;
      break;
    }
    addHistoryLabel(`probe: rewire ${old} -> ${edgeKey(t)}`);
  }

  const structural = (type === "add" || type === "rm" || type === "rew");
  const autoRelayout = document.getElementById("autoRelayout").checked;
  renderModel({preservePositions:true, relayout: structural && autoRelayout});
}

/* ---------------------------
   Random walk simulation
---------------------------- */
function walk(steps){
  setSeedFromString(document.getElementById("seed").value);

  const applyDv = document.getElementById("applyDv").checked;

  pushUndo(`walk ${steps} steps${applyDv ? " (dv impacts)" : ""}`);

  let current = startId;

  function outgoingEdges(id){
    return graphLinks.filter(e => e.visible && e.sourceId === id).map(e => ({ e, p: Number(e.p ?? 1) }));
  }

  for (let i=0;i<steps;i++){
    const outs = outgoingEdges(current);
    if (!outs.length){
      current = startId;
      continue;
    }
    const chosen = weightedChoice(outs, outs.map(x => x.p));
    const e = chosen.e;
    const next = e.targetId;

    heat.node[next] = (heat.node[next] ?? 0) + 1;
    heat.edge[e.id] = (heat.edge[e.id] ?? 0) + 1;

    if (applyDv){
      const dv = Number(e.dv ?? 0);
      const st = model.states.find(s => s.id === next);
      if (st){
        st.viability = clamp01(st.viability + dv);
      }
      const n = graphNodes.find(n => n.id === next);
      if (n) n.v = model.states.find(s=>s.id===next)?.viability ?? n.v;
    }

    current = next;
  }

  graphNodes.forEach(n => {
    const st = model.states.find(s => s.id === n.id);
    if (st) n.v = st.viability;
  });

  recomputeAnalysisAndStyle();
}

/* ---------------------------
   Export / import / png
---------------------------- */
function exportJSON(){
  const m = deepClone(model);
  m.layout = { positions: graphNodes.map(n => ({ id:n.id, x:n.x ?? 0, y:n.y ?? 0 })) };
  m.meta = m.meta || {};
  m.meta.start = startId;

  const blob = new Blob([JSON.stringify(m, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "viability-model.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function importJSON(file){
  const reader = new FileReader();
  reader.onload = (ev) => {
    try{
      const parsed = normalizeModel(JSON.parse(ev.target.result));
      pushUndo("import model");

      model = parsed;
      startId = model.meta.start;

      heat = { node:{}, edge:{} };

      renderModel({preservePositions:false, relayout:false});
      recomputeAnalysisAndStyle();
    } catch (err){
      alert("Import failed: " + (err?.message ?? err));
    }
  };
  reader.readAsText(file);
}

function exportPNG(){
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(svg.node());
  const svgBlob = new Blob([svgString], {type:"image/svg+xml;charset=utf-8"});
  const url = URL.createObjectURL(svgBlob);
  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement("canvas");
    canvas.width = width * 2;
    canvas.height = height * 2;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#0f1115";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.scale(2, 2);
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);

    const png = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = png;
    a.download = "viability-graph.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  };
  img.src = url;
}

/* ---------------------------
   Buttons + UI wiring
---------------------------- */
function wireUi(){
  document.getElementById("thr").addEventListener("input", (e) => {
    thr = Number(e.target.value);
    document.getElementById("thrLabel").textContent = thr.toFixed(2);
    recomputeAnalysisAndStyle();
  });

  document.getElementById("pCut").addEventListener("input", (e) => {
    pCut = Number(e.target.value);
    document.getElementById("pCutLabel").textContent = pCut.toFixed(2);
    applyEdgeFilter();
    updateSimulationLinks();
    recomputeAnalysisAndStyle();
  });

  document.getElementById("amp").addEventListener("input", (e) => {
    document.getElementById("ampLabel").textContent = Number(e.target.value).toFixed(2);
  });
  document.getElementById("pAmp").addEventListener("input", (e) => {
    document.getElementById("pAmpLabel").textContent = Number(e.target.value).toFixed(2);
  });

  document.getElementById("showEdgeLabels").addEventListener("change", () => {
    updateEdgeLabelVisibility();
    updateGraphStyles();
  });

  document.getElementById("startSelect").addEventListener("change", (e) => {
    pushUndo("change start state");
    startId = e.target.value;
    model.meta.start = startId;
    recomputeAnalysisAndStyle();
  });

  document.getElementById("probeBtn").addEventListener("click", () => probe());
  document.getElementById("walkBtn").addEventListener("click", () => {
    const steps = Math.max(1, Math.min(50000, Number(document.getElementById("walkSteps").value || 250)));
    walk(steps);
  });
  document.getElementById("relayoutBtn").addEventListener("click", () => runLayout());
  document.getElementById("undoBtn").addEventListener("click", () => undo());
  document.getElementById("resetBtn").addEventListener("click", () => {
    pushUndo("reset");
    model = deepClone(baseline);
    model = normalizeModel(model);
    heat = { node:{}, edge:{} };
    startId = model.meta.start;
    renderModel({preservePositions:false, relayout:true});
  });

  document.getElementById("clearHeatBtn").addEventListener("click", () => {
    pushUndo("clear heat");
    heat = { node:{}, edge:{} };
    recomputeAnalysisAndStyle();
  });

  document.getElementById("focusAttractorsBtn").addEventListener("click", () => {
    const attractors = graphNodes.filter(n => n.isAttractor);
    if (!attractors.length) return;
    focusNodes(attractors);
  });

  document.getElementById("exportBtn").addEventListener("click", () => exportJSON());
  document.getElementById("pngBtn").addEventListener("click", () => exportPNG());

  document.getElementById("importFile").addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (file) importJSON(file);
    e.target.value = "";
  });

  document.addEventListener("keydown", (e) => {
    const isUndo = (e.key.toLowerCase() === "z") && (e.ctrlKey || e.metaKey);
    if (isUndo){
      e.preventDefault();
      undo();
    }
  });
}

function focusNodes(nodes){
  const xs = nodes.map(n => n.x).filter(Number.isFinite);
  const ys = nodes.map(n => n.y).filter(Number.isFinite);
  if (!xs.length || !ys.length) return;

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  const padding = 60;
  const boundsWidth = Math.max(1, maxX - minX);
  const boundsHeight = Math.max(1, maxY - minY);
  const scale = Math.min(width / (boundsWidth + padding), height / (boundsHeight + padding), 4);

  const translateX = (width - scale * (minX + maxX)) / 2;
  const translateY = (height - scale * (minY + maxY)) / 2;

  svg.transition().duration(500).call(
    zoom.transform,
    d3.zoomIdentity.translate(translateX, translateY).scale(scale)
  );
}

/* ---------------------------
   Boot
---------------------------- */
function boot(){
  if (!window.d3){
    document.getElementById("cy").innerHTML = `
      <div style="padding:16px; font-size:13px; color:#ffb4b4;">
        <strong>Graph renderer unavailable.</strong><br/>
        D3.js is required to render the graph. Check network access to the CDN.
      </div>`;
    return;
  }

  initD3();
  wireUi();

  model = normalizeModel(model);
  thr = Number(document.getElementById("thr").value);
  pCut = Number(document.getElementById("pCut").value);
  startId = model.meta.start;

  document.getElementById("thrLabel").textContent = thr.toFixed(2);
  document.getElementById("pCutLabel").textContent = pCut.toFixed(2);
  document.getElementById("ampLabel").textContent = Number(document.getElementById("amp").value).toFixed(2);
  document.getElementById("pAmpLabel").textContent = Number(document.getElementById("pAmp").value).toFixed(2);

  updateStartDropdown();
  renderModel({preservePositions:false, relayout:true});
  clearSelection();
}

boot();

</script>
</body>
</html>
