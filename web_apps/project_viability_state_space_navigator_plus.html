<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project Viability State-Space Navigator (Plus)</title>

<!-- Cytoscape.js + fCoSE -->
<script src="https://unpkg.com/cytoscape@3.29.6/dist/cytoscape.min.js"></script>
<script src="https://unpkg.com/cytoscape-fcose@2.2.2/cytoscape-fcose.js"></script>

<style>
  :root{
    --bg:#0f1115;
    --panel:#151924;
    --panel2:#111522;
    --text:#e7e9ee;
    --muted:#aab0bd;
    --accent:#7aa2ff;
    --good:#4caf50;
    --mid:#ff9800;
    --bad:#f44336;
    --line:#2a3146;
  }
  body{
    margin:0; height:100vh; display:flex; flex-direction:column;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:var(--bg); color:var(--text);
  }
  #toolbar{
    display:flex; gap:10px; align-items:center;
    padding:10px 12px; background:var(--panel);
    border-bottom:1px solid var(--line);
    flex-wrap:wrap;
  }
  #main{ flex:1; min-height:0; display:flex; }
  #panel{
    width:360px; max-width:45vw; min-width:320px;
    background:var(--panel2); border-right:1px solid var(--line);
    overflow:auto; padding:12px;
  }
  #cy{ flex:1; min-width:0; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .col{ display:flex; flex-direction:column; gap:6px; }
  .section{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
    background:rgba(255,255,255,0.02);
    margin-bottom:10px;
  }
  .section h3{
    margin:0 0 8px 0; font-size:13px; letter-spacing:0.02em;
    color:var(--muted); font-weight:650;
  }
  label{ font-size:12px; color:var(--muted); }
  input[type="range"]{ width:180px; }
  input[type="number"], input[type="text"], textarea, select{
    background:#0c0f18; color:var(--text);
    border:1px solid var(--line);
    border-radius:8px; padding:8px;
    font-size:13px;
    outline:none;
  }
  textarea{ min-height:70px; resize:vertical; }
  button{
    background:#1b2236; color:var(--text);
    border:1px solid var(--line);
    border-radius:10px;
    padding:8px 10px;
    font-size:13px;
    cursor:pointer;
  }
  button:hover{ border-color:#3a4567; }
  button.primary{ background:#203057; border-color:#2f3d67; }
  button.danger{ background:#3b1f25; border-color:#5a2b35; }
  .pill{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px;
    border:1px solid var(--line);
    background:rgba(255,255,255,0.03);
    font-size:12px; color:var(--muted);
  }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
  .dot.good{ background:var(--good); }
  .dot.mid{ background:var(--mid); }
  .dot.bad{ background:var(--bad); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
  #history{ display:flex; flex-direction:column; gap:6px; }
  .histItem{
    border:1px solid var(--line);
    border-radius:10px;
    padding:8px;
    background:rgba(0,0,0,0.15);
    color:var(--muted);
    font-size:12px;
    line-height:1.25;
  }
  .small{ font-size:12px; color:var(--muted); }
  .rightSpacer{ margin-left:auto; }
</style>
</head>

<body>
  <div id="toolbar">
    <div class="row">
      <span class="pill"><span class="dot good"></span>stable</span>
      <span class="pill"><span class="dot mid"></span>marginal</span>
      <span class="pill"><span class="dot bad"></span>non-viable</span>
    </div>

    <div class="row">
      <label>Viability threshold <span id="thrLabel" class="mono">0.50</span></label>
      <input id="thr" type="range" min="0" max="1" step="0.01" value="0.50"/>
    </div>

    <div class="row">
      <label>Edge cutoff p ≥ <span id="pCutLabel" class="mono">0.00</span></label>
      <input id="pCut" type="range" min="0" max="1" step="0.01" value="0.00"/>
    </div>

    <button id="probeBtn" class="primary">Safe-to-fail probe</button>
    <button id="walkBtn">Walk</button>
    <input id="walkSteps" type="number" min="1" max="50000" value="250" style="width:90px" title="Walk steps"/>

    <button id="relayoutBtn">Relayout</button>
    <button id="undoBtn">Undo</button>
    <button id="resetBtn" class="danger">Reset</button>

    <div class="rightSpacer"></div>

    <button id="pngBtn">PNG</button>
    <button id="exportBtn">Export JSON</button>
    <label class="pill" style="cursor:pointer;">
      Import JSON
      <input id="importFile" type="file" accept=".json,application/json" style="display:none"/>
    </label>
  </div>

  <div id="main">
    <div id="panel">
      <div class="section">
        <h3>Model + simulation controls</h3>
        <div class="row">
          <div class="col" style="flex:1;">
            <label>Start state</label>
            <select id="startSelect"></select>
          </div>
          <div class="col" style="flex:1;">
            <label>RNG seed (repeatable probes)</label>
            <input id="seed" type="text" value="rowland41" placeholder="any string"/>
          </div>
        </div>

        <div class="row">
          <div class="col">
            <label>Probe amplitude (viability Δ)</label>
            <input id="amp" type="range" min="0" max="0.5" step="0.01" value="0.20"/>
            <div class="small">Current: <span id="ampLabel" class="mono">0.20</span></div>
          </div>
          <div class="col">
            <label>Probability nudge (p Δ)</label>
            <input id="pAmp" type="range" min="0" max="0.5" step="0.01" value="0.15"/>
            <div class="small">Current: <span id="pAmpLabel" class="mono">0.15</span></div>
          </div>
        </div>

        <div class="row">
          <label class="pill" style="cursor:pointer;">
            <input id="applyDv" type="checkbox" />
            Apply dv impacts during walk
          </label>
          <label class="pill" style="cursor:pointer;">
            <input id="showEdgeLabels" type="checkbox" />
            Show edge labels
          </label>
          <label class="pill" style="cursor:pointer;">
            <input id="autoRelayout" type="checkbox" checked/>
            Auto-relayout on structural probe
          </label>
        </div>

        <div class="row">
          <div class="col" style="flex:1;">
            <label>Probe palette (enabled probe types)</label>
            <div class="row">
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="v" checked/> viability nudge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="p" checked/> p nudge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="add" checked/> add edge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="rm" checked/> remove edge</label>
              <label class="pill" style="cursor:pointer;"><input type="checkbox" class="probeType" value="rew" checked/> rewire edge</label>
            </div>
          </div>
        </div>

        <div class="row">
          <button id="clearHeatBtn">Clear heat</button>
          <button id="focusAttractorsBtn">Focus attractors</button>
        </div>

        <div class="small">
          <span class="mono">JSON schema</span> (minimal):<br/>
          <span class="mono">{"states":[{"id":"S1","label":"...","viability":0.7}],"transitions":[{"from":"S1","to":"S2","p":0.4,"dv":-0.05,"label":"..."}],"meta":{"start":"S1"}}</span>
        </div>
      </div>

      <div class="section">
        <h3>System diagnostics</h3>
        <div id="stats" class="mono"></div>
      </div>

      <div class="section">
        <h3>Inspector (click a node or edge)</h3>
        <div id="inspector" class="small">Nothing selected.</div>
      </div>

      <div class="section">
        <h3>History</h3>
        <div id="history"></div>
      </div>
    </div>

    <div id="cy"></div>
  </div>

<script>
/* ---------------------------
   Utility: cloning + RNG
---------------------------- */
function deepClone(obj){
  if (typeof structuredClone === "function") return structuredClone(obj);
  return JSON.parse(JSON.stringify(obj));
}

// Seeded RNG (mulberry32) + string hashing.
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
let rng = Math.random;
function setSeedFromString(s){
  const seedGen = xmur3(String(s ?? ""));
  const seed = seedGen();
  rng = mulberry32(seed);
  return seed;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  if (total <= 0) return items[Math.floor(rng()*items.length)];
  let r = rng() * total;
  for (let i=0;i<items.length;i++){
    r -= weights[i];
    if (r <= 0) return items[i];
  }
  return items[items.length-1];
}

/* ---------------------------
   Default model
---------------------------- */
const baseline = {
  meta: { title: "Steel-mill-esque toy model", start: "S1" },
  states: [
    { id:"S1", label:"Baseline Ops", viability:0.72, notes:"Normal throughput; manageable variance." },
    { id:"S2", label:"New Vendor", viability:0.55, notes:"Interface churn; paperwork + integration debt." },
    { id:"S3", label:"Automation", viability:0.83, notes:"Higher throughput; brittleness if skills decay." },
    { id:"S4", label:"Industrial Action", viability:0.32, notes:"Coordination cost spikes; governance stress." },
    { id:"S5", label:"Market Shock", viability:0.18, notes:"Demand collapse; cash constraints dominate." }
  ],
  transitions: [
    { from:"S1", to:"S2", p:0.35, dv:-0.02, label:"vendor swap" },
    { from:"S2", to:"S3", p:0.55, dv:+0.04, label:"stabilise + automate" },
    { from:"S1", to:"S4", p:0.15, dv:-0.08, label:"labour dispute" },
    { from:"S4", to:"S5", p:0.60, dv:-0.10, label:"strike + shock" },
    { from:"S3", to:"S5", p:0.10, dv:-0.12, label:"automation backlash" },
    { from:"S5", to:"S1", p:0.25, dv:+0.06, label:"restructure" },
    { from:"S3", to:"S1", p:0.30, dv:-0.03, label:"reversion" }
  ]
};

let model = deepClone(baseline);
let thr = 0.50;
let pCut = 0.00;
let startId = model?.meta?.start || (model.states[0]?.id ?? "S1");
let heat = { node:{}, edge:{} }; // counts from walks

/* ---------------------------
   Cytoscape init
---------------------------- */
if (window.cytoscapeFcose) {
  cytoscape.use(window.cytoscapeFcose);
}

const cy = cytoscape({
  container: document.getElementById("cy"),
  elements: [],
  style: [
    {
      selector: "node",
      style: {
        "label": "data(label)",
        "color": "#e7e9ee",
        "text-valign": "center",
        "text-halign": "center",
        "font-size": 10,
        "text-outline-width": 2,
        "text-outline-color": "#0f1115",
        "background-color": "#999",
        "border-width": "mapData(h, 0, 1, 1, 8)",
        "border-color": "#0f1115",
        "width": "mapData(v, 0, 1, 22, 44)",
        "height": "mapData(v, 0, 1, 22, 44)"
      }
    },
    {
      selector: "node.start",
      style: {
        "border-color": "#7aa2ff",
        "border-width": 5
      }
    },
    {
      selector: "node.attractor",
      style: {
        "border-style": "dashed",
        "border-width": 6
      }
    },
    {
      selector: "node.selected",
      style: { "text-outline-color": "#7aa2ff" }
    },
    {
      selector: "edge",
      style: {
        "curve-style": "bezier",
        "target-arrow-shape": "triangle",
        "line-color": "#667099",
        "target-arrow-color": "#667099",
        "width": "mapData(w, 0, 1, 1, 7)",
        "opacity": 0.9
      }
    },
    {
      selector: "edge.selected",
      style: { "line-color": "#7aa2ff", "target-arrow-color": "#7aa2ff" }
    },
    {
      selector: "edge[labelVisible = 'true']",
      style: {
        "label": "data(label)",
        "font-size": 9,
        "text-background-opacity": 1,
        "text-background-color": "#0f1115",
        "text-background-padding": 2,
        "color": "#e7e9ee",
        "text-rotation": "autorotate"
      }
    }
  ],
  layout: { name:"fcose", quality:"default", randomize:true, animate:false, packComponents:true }
});

function runLayout(){
  cy.layout({
    name:"fcose",
    quality:"default",
    randomize:true,
    animate:false,
    packComponents:true,
    nodeRepulsion: 8000,
    idealEdgeLength: 120
  }).run();
}

/* ---------------------------
   Model <-> Cytoscape render
---------------------------- */
function normalizeModel(m){
  if (!m || !Array.isArray(m.states) || !Array.isArray(m.transitions)) {
    throw new Error("JSON must contain 'states' and 'transitions' arrays.");
  }

  const ids = new Set();
  m.states = m.states.map(s => {
    if (!s.id) throw new Error("Every state needs an 'id'.");
    if (ids.has(s.id)) throw new Error("Duplicate state id: " + s.id);
    ids.add(s.id);
    return {
      id: String(s.id),
      label: String(s.label ?? s.id),
      viability: clamp01(Number(s.viability ?? 0.5)),
      notes: String(s.notes ?? "")
    };
  });

  const existing = new Set();
  m.transitions = m.transitions
    .filter(t => t && t.from && t.to)
    .map(t => {
      const from = String(t.from), to = String(t.to);
      if (!ids.has(from) || !ids.has(to)) return null;
      const key = from + "->" + to;
      // allow parallel edges? we choose no: collapse duplicates by keeping first
      if (existing.has(key)) return null;
      existing.add(key);
      return {
        from,
        to,
        p: clamp01(Number(t.p ?? 1.0)),
        dv: Number(t.dv ?? 0),
        label: String(t.label ?? "")
      };
    })
    .filter(Boolean);

  if (!m.meta) m.meta = {};
  m.meta.title = String(m.meta.title ?? "Untitled");
  m.meta.start = String(m.meta.start ?? m.states[0]?.id ?? "");
  if (!ids.has(m.meta.start)) m.meta.start = m.states[0]?.id ?? "";

  // layout is optional; pass-through if present
  if (m.layout && Array.isArray(m.layout.positions)) {
    m.layout.positions = m.layout.positions
      .filter(p => p && ids.has(String(p.id)))
      .map(p => ({ id:String(p.id), x:Number(p.x), y:Number(p.y) }));
  } else {
    m.layout = null;
  }

  return m;
}

function buildElementsFromModel(m){
  const els = [];
  for (const s of m.states){
    els.push({ data:{ id:s.id, label:s.label, v:s.viability, notes:s.notes, h:0 } });
  }
  for (const t of m.transitions){
    const eid = t.from + "->" + t.to;
    els.push({ data:{ id:eid, source:t.from, target:t.to, p:t.p, dv:t.dv, label:t.label, w:0, labelVisible:"false" } });
  }
  return els;
}

function capturePositions(){
  const pos = new Map();
  cy.nodes().forEach(n => pos.set(n.id(), { x:n.position("x"), y:n.position("y") }));
  return pos;
}

function restorePositions(posMap){
  if (!posMap) return;
  cy.nodes().forEach(n => {
    const p = posMap.get(n.id());
    if (p) n.position({ x:p.x, y:p.y });
  });
}

function applyImportedLayout(m){
  if (!m?.layout?.positions) return;
  const posMap = new Map(m.layout.positions.map(p => [p.id, {x:p.x, y:p.y}]));
  restorePositions(posMap);
}

function renderModel({preservePositions=true, relayout=false} = {}){
  const posMap = preservePositions ? capturePositions() : null;

  cy.elements().remove();
  cy.add(buildElementsFromModel(model));

  // restore from captured positions (for "soft" updates)
  restorePositions(posMap);

  // restore explicit imported layout if present
  applyImportedLayout(model);

  ensureStartState();
  updateStartDropdown();
  updateEdgeLabelVisibility();
  applyEdgeFilter();
  recomputeAnalysisAndStyle();

  if (relayout) runLayout();
}

/* ---------------------------
   Styling + analysis
---------------------------- */
function colourForViability(v){
  if (v >= thr) return getComputedStyle(document.documentElement).getPropertyValue("--good").trim();
  if (v >= thr * 0.6) return getComputedStyle(document.documentElement).getPropertyValue("--mid").trim();
  return getComputedStyle(document.documentElement).getPropertyValue("--bad").trim();
}

function applyEdgeFilter(){
  cy.edges().forEach(e => {
    const p = Number(e.data("p") ?? 1);
    if (p < pCut) e.hide();
    else e.show();
  });
}

function updateEdgeLabelVisibility(){
  const show = document.getElementById("showEdgeLabels").checked;
  cy.edges().forEach(e => {
    if (!show) {
      e.data("labelVisible", "false");
      return;
    }
    const p = Number(e.data("p") ?? 1);
    const dv = Number(e.data("dv") ?? 0);
    const label = e.data("label");
    const composed = (label && label.trim().length)
      ? label
      : `p=${p.toFixed(2)} dv=${dv.toFixed(2)}`;
    e.data("label", composed);
    e.data("labelVisible", "true");
  });
}

function buildAdjacencyFromVisibleEdges(){
  const ids = model.states.map(s => s.id);
  const adj = new Map(ids.map(id => [id, []]));
  cy.edges(":visible").forEach(e => {
    const from = e.data("source");
    const to = e.data("target");
    if (adj.has(from)) adj.get(from).push(to);
  });
  return adj;
}

// Tarjan SCC for directed graphs
function tarjanSCC(ids, adj){
  let index = 0;
  const stack = [];
  const onStack = new Set();
  const indices = new Map();
  const lowlink = new Map();
  const sccs = [];

  function strongconnect(v){
    indices.set(v, index);
    lowlink.set(v, index);
    index++;
    stack.push(v);
    onStack.add(v);

    for (const w of (adj.get(v) || [])){
      if (!indices.has(w)){
        strongconnect(w);
        lowlink.set(v, Math.min(lowlink.get(v), lowlink.get(w)));
      } else if (onStack.has(w)){
        lowlink.set(v, Math.min(lowlink.get(v), indices.get(w)));
      }
    }

    if (lowlink.get(v) === indices.get(v)){
      const scc = [];
      while (true){
        const w = stack.pop();
        onStack.delete(w);
        scc.push(w);
        if (w === v) break;
      }
      sccs.push(scc);
    }
  }

  for (const v of ids){
    if (!indices.has(v)) strongconnect(v);
  }
  return sccs;
}

function detectAttractors(ids, adj, sccs){
  const nodeToScc = new Map();
  sccs.forEach((scc, i) => scc.forEach(id => nodeToScc.set(id, i)));

  // quick self-loop check
  const hasSelfLoop = new Set();
  for (const [from, tos] of adj.entries()){
    if (tos.includes(from)) hasSelfLoop.add(from);
  }

  const attractorSccIdx = new Set();
  for (let i=0;i<sccs.length;i++){
    const scc = sccs[i];
    const sccSet = new Set(scc);

    let outgoing = false;
    for (const v of scc){
      for (const w of (adj.get(v) || [])){
        if (!sccSet.has(w)) { outgoing = true; break; }
      }
      if (outgoing) break;
    }

    const isCycle = (scc.length > 1) || (scc.length === 1 && hasSelfLoop.has(scc[0]));
    if (!outgoing && isCycle) attractorSccIdx.add(i);
  }

  const attractorNodes = new Set();
  attractorSccIdx.forEach(i => sccs[i].forEach(n => attractorNodes.add(n)));

  return { attractorNodes, attractorSccIdx };
}

function recomputeAnalysisAndStyle(){
  // heat normalisation
  const maxNodeHeat = Math.max(1, ...Object.values(heat.node));
  const maxEdgeHeat = Math.max(1, ...Object.values(heat.edge));

  // update node data + base classes
  cy.nodes().forEach(n => {
    const v = Number(n.data("v") ?? 0.5);
    n.style("background-color", colourForViability(v));

    const h = (heat.node[n.id()] ?? 0) / maxNodeHeat;
    n.data("h", clamp01(h));

    n.removeClass("start attractor selected");
    if (n.id() === startId) n.addClass("start");
  });

  // update edge weights for styling
  cy.edges().forEach(e => {
    const eid = e.id();
    const h = (heat.edge[eid] ?? 0) / maxEdgeHeat;
    // base width encodes probability; heat adds emphasis
    const p = Number(e.data("p") ?? 1);
    const w = clamp01(0.15 + 0.85 * p) * 0.65 + clamp01(h) * 0.35;
    e.data("w", clamp01(w));
    e.removeClass("selected");
  });

  // SCCs / attractors computed on visible edges
  const ids = model.states.map(s => s.id);
  const adj = buildAdjacencyFromVisibleEdges();
  const sccs = tarjanSCC(ids, adj);
  const { attractorNodes, attractorSccIdx } = detectAttractors(ids, adj, sccs);

  cy.nodes().forEach(n => {
    if (attractorNodes.has(n.id())) n.addClass("attractor");
  });

  updateStats({ ids, adj, sccs, attractorNodes, attractorSccIdx });
  updateHistoryUI();
}

function updateStats({ ids, adj, sccs, attractorNodes }){
  const nodes = cy.nodes();
  const visEdges = cy.edges(":visible");
  const allEdges = cy.edges();

  const vs = nodes.map(n => Number(n.data("v") ?? 0.5));
  const avgV = vs.reduce((a,b)=>a+b,0) / Math.max(1, vs.length);

  let stable=0, marginal=0, bad=0;
  for (const v of vs){
    if (v >= thr) stable++;
    else if (v >= thr*0.6) marginal++;
    else bad++;
  }

  // "risk heuristic": high degree + low viability
  const risk = nodes.map(n => {
    const v = Number(n.data("v") ?? 0.5);
    const deg = n.indegree() + n.outdegree();
    const score = (deg + 1) * (1 - v);
    return { id:n.id(), label:n.data("label"), v, deg, score };
  }).sort((a,b)=>b.score-a.score).slice(0,5);

  // summarise attractors
  const attractorList = [];
  if (attractorNodes.size){
    // group by SCC via adjacency recomputation over ids: quick by re-tarjan on current view
    // (we already have sccs upstream; but for display, we just list nodes)
    attractorList.push([...attractorNodes].join(", "));
  }

  document.getElementById("stats").textContent =
`title: ${model?.meta?.title ?? "Untitled"}
nodes: ${nodes.length} | edges: ${allEdges.length} (visible ${visEdges.length})
avg viability: ${avgV.toFixed(3)} | threshold: ${thr.toFixed(2)}
stable/marginal/bad: ${stable}/${marginal}/${bad}

SCCs (visible graph): ${sccs.length}
attractor nodes: ${attractorNodes.size}${attractorNodes.size ? " -> " + [...attractorNodes].slice(0,12).join(", ") + (attractorNodes.size>12?" …":"") : ""}

top risk (deg*(1-v)):
${risk.map(r => `- ${r.id} "${r.label}" v=${r.v.toFixed(2)} deg=${r.deg} score=${r.score.toFixed(2)}`).join("\n")}
`;
}

/* ---------------------------
   Start state + dropdown
---------------------------- */
function ensureStartState(){
  const ids = new Set(model.states.map(s => s.id));
  if (!ids.has(startId)) startId = model.states[0]?.id ?? "";
  model.meta.start = startId;
}
function updateStartDropdown(){
  const sel = document.getElementById("startSelect");
  const current = startId;

  sel.innerHTML = "";
  for (const s of model.states){
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = `${s.id}: ${s.label}`;
    if (s.id === current) opt.selected = true;
    sel.appendChild(opt);
  }
}

/* ---------------------------
   Undo + history
---------------------------- */
const undoStack = [];
const hist = [];

function pushUndo(label){
  const snapshot = {
    label,
    model: deepClone(model),
    heat: deepClone(heat),
    positions: [...capturePositions().entries()].map(([id,p]) => ({id, x:p.x, y:p.y}))
  };
  undoStack.push(snapshot);
  hist.unshift({ when: new Date().toISOString(), label });
  if (hist.length > 40) hist.pop();
}

function undo(){
  const snap = undoStack.pop();
  if (!snap) return;
  model = normalizeModel(deepClone(snap.model));
  heat = deepClone(snap.heat);

  renderModel({preservePositions:false, relayout:false});

  // restore positions from snapshot
  const posMap = new Map(snap.positions.map(p => [p.id, {x:p.x, y:p.y}]));
  restorePositions(posMap);

  recomputeAnalysisAndStyle();
}

function updateHistoryUI(){
  const el = document.getElementById("history");
  el.innerHTML = "";
  if (!hist.length){
    el.innerHTML = `<div class="histItem">No actions yet.</div>`;
    return;
  }
  for (const h of hist.slice(0,18)){
    const div = document.createElement("div");
    div.className = "histItem";
    div.textContent = `${h.when.replace("T"," ").replace("Z","")} — ${h.label}`;
    el.appendChild(div);
  }
}

/* ---------------------------
   Inspector (node + edge)
---------------------------- */
let selected = { kind:null, id:null };

function clearSelection(){
  selected = {kind:null,id:null};
  cy.nodes().removeClass("selected");
  cy.edges().removeClass("selected");
  document.getElementById("inspector").innerHTML = "Nothing selected.";
}

function selectNode(n){
  clearSelection();
  selected = { kind:"node", id:n.id() };
  n.addClass("selected");

  const s = model.states.find(x => x.id === n.id());
  const v = Number(s?.viability ?? n.data("v") ?? 0.5);

  document.getElementById("inspector").innerHTML = `
    <div class="col">
      <div><span class="mono">id</span>: <span class="mono">${n.id()}</span></div>

      <label>label</label>
      <input id="i_label" type="text" value="${escapeHtml(s?.label ?? n.data("label") ?? n.id())}"/>

      <label>viability <span class="mono" id="i_vLabel">${v.toFixed(2)}</span></label>
      <input id="i_v" type="range" min="0" max="1" step="0.01" value="${v.toFixed(2)}"/>

      <label>notes</label>
      <textarea id="i_notes">${escapeHtml(s?.notes ?? "")}</textarea>

      <div class="row">
        <button id="i_apply" class="primary">Apply</button>
        <button id="i_setStart">Set start</button>
      </div>
      <div class="small">Tip: start state gets a blue border; attractors are dashed-border SCCs.</div>
    </div>
  `;

  const vSlider = document.getElementById("i_v");
  const vLab = document.getElementById("i_vLabel");
  vSlider.addEventListener("input", e => vLab.textContent = Number(e.target.value).toFixed(2));

  document.getElementById("i_apply").addEventListener("click", () => {
    pushUndo(`edit node ${n.id()}`);
    const label = document.getElementById("i_label").value;
    const viability = clamp01(Number(document.getElementById("i_v").value));
    const notes = document.getElementById("i_notes").value;

    const st = model.states.find(x => x.id === n.id());
    if (st){
      st.label = label;
      st.viability = viability;
      st.notes = notes;
    }
    n.data("label", label);
    n.data("v", viability);
    n.data("notes", notes);

    recomputeAnalysisAndStyle();
    selectNode(n);
  });

  document.getElementById("i_setStart").addEventListener("click", () => {
    pushUndo(`set start ${n.id()}`);
    startId = n.id();
    model.meta.start = startId;
    recomputeAnalysisAndStyle();
    updateStartDropdown();
    selectNode(n);
  });
}

function selectEdge(e){
  clearSelection();
  selected = { kind:"edge", id:e.id() };
  e.addClass("selected");

  const t = model.transitions.find(x => (x.from + "->" + x.to) === e.id());
  const p = Number(t?.p ?? e.data("p") ?? 1);
  const dv = Number(t?.dv ?? e.data("dv") ?? 0);
  const label = String(t?.label ?? e.data("label") ?? "");

  document.getElementById("inspector").innerHTML = `
    <div class="col">
      <div><span class="mono">edge</span>: <span class="mono">${escapeHtml(e.id())}</span></div>
      <div class="small">from <span class="mono">${escapeHtml(e.data("source"))}</span> to <span class="mono">${escapeHtml(e.data("target"))}</span></div>

      <label>label (optional)</label>
      <input id="e_label" type="text" value="${escapeHtml(label)}"/>

      <label>probability p <span class="mono" id="e_pLabel">${p.toFixed(2)}</span></label>
      <input id="e_p" type="range" min="0" max="1" step="0.01" value="${p.toFixed(2)}"/>

      <label>impact dv (optional) <span class="mono" id="e_dvLabel">${dv.toFixed(2)}</span></label>
      <input id="e_dv" type="range" min="-0.5" max="0.5" step="0.01" value="${dv.toFixed(2)}"/>

      <div class="row">
        <button id="e_apply" class="primary">Apply</button>
      </div>
      <div class="small">Walk uses p as weights; if “Apply dv impacts” is on, dv shifts target viability on traversal.</div>
    </div>
  `;

  const pSlider = document.getElementById("e_p");
  const pLab = document.getElementById("e_pLabel");
  pSlider.addEventListener("input", ev => pLab.textContent = Number(ev.target.value).toFixed(2));

  const dvSlider = document.getElementById("e_dv");
  const dvLab = document.getElementById("e_dvLabel");
  dvSlider.addEventListener("input", ev => dvLab.textContent = Number(ev.target.value).toFixed(2));

  document.getElementById("e_apply").addEventListener("click", () => {
    pushUndo(`edit edge ${e.id()}`);
    const newLabel = document.getElementById("e_label").value;
    const newP = clamp01(Number(document.getElementById("e_p").value));
    const newDv = Number(document.getElementById("e_dv").value);

    const tr = model.transitions.find(x => (x.from + "->" + x.to) === e.id());
    if (tr){
      tr.label = newLabel;
      tr.p = newP;
      tr.dv = newDv;
    }
    e.data("label", newLabel);
    e.data("p", newP);
    e.data("dv", newDv);

    updateEdgeLabelVisibility();
    applyEdgeFilter();
    recomputeAnalysisAndStyle();
    selectEdge(e);
  });
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;");
}

/* ---------------------------
   Safe-to-fail probes
---------------------------- */
function enabledProbeTypes(){
  return [...document.querySelectorAll(".probeType")]
    .filter(x => x.checked)
    .map(x => x.value);
}

function probe(){
  setSeedFromString(document.getElementById("seed").value);
  const types = enabledProbeTypes();
  if (!types.length) return;

  const amp = Number(document.getElementById("amp").value);
  const pAmp = Number(document.getElementById("pAmp").value);

  pushUndo("safe-to-fail probe");

  const type = types[Math.floor(rng() * types.length)];
  const ids = model.states.map(s => s.id);

  const edgeKey = (t) => t.from + "->" + t.to;

  function addHistoryLabel(s){
    hist.unshift({ when: new Date().toISOString(), label: s });
    if (hist.length > 40) hist.pop();
  }

  if (type === "v"){
    const s = model.states[Math.floor(rng()*model.states.length)];
    const delta = (rng()*2 - 1) * amp;
    s.viability = clamp01(s.viability + delta);
    addHistoryLabel(`probe: viability ${s.id} += ${delta.toFixed(2)}`);
  }
  else if (type === "p" && model.transitions.length){
    const t = model.transitions[Math.floor(rng()*model.transitions.length)];
    const delta = (rng()*2 - 1) * pAmp;
    t.p = clamp01(t.p + delta);
    addHistoryLabel(`probe: p ${edgeKey(t)} += ${delta.toFixed(2)}`);
  }
  else if (type === "add"){
    // try a few times to find a new pair
    const existing = new Set(model.transitions.map(edgeKey));
    let tries = 30;
    while (tries--){
      const from = ids[Math.floor(rng()*ids.length)];
      const to = ids[Math.floor(rng()*ids.length)];
      if (from === to) continue;
      const k = from + "->" + to;
      if (existing.has(k)) continue;

      model.transitions.push({ from, to, p: clamp01(0.10 + rng()*0.40), dv: 0, label:"" });
      addHistoryLabel(`probe: add edge ${k}`);
      break;
    }
  }
  else if (type === "rm" && model.transitions.length){
    const idx = Math.floor(rng()*model.transitions.length);
    const k = edgeKey(model.transitions[idx]);
    model.transitions.splice(idx, 1);
    addHistoryLabel(`probe: remove edge ${k}`);
  }
  else if (type === "rew" && model.transitions.length){
    const t = model.transitions[Math.floor(rng()*model.transitions.length)];
    const old = edgeKey(t);
    let tries = 20;
    while (tries--){
      const to = ids[Math.floor(rng()*ids.length)];
      if (to === t.from) continue;
      const k = t.from + "->" + to;
      // avoid duplicates
      if (model.transitions.some(x => (x.from + "->" + x.to) === k)) continue;
      t.to = to;
      break;
    }
    addHistoryLabel(`probe: rewire ${old} -> ${edgeKey(t)}`);
  }

  // structural changes: rerender
  const structural = (type === "add" || type === "rm" || type === "rew");
  const autoRelayout = document.getElementById("autoRelayout").checked;
  renderModel({preservePositions:true, relayout: structural && autoRelayout});
}

/* ---------------------------
   Random walk simulation
---------------------------- */
function walk(steps){
  setSeedFromString(document.getElementById("seed").value);

  const applyDv = document.getElementById("applyDv").checked;

  pushUndo(`walk ${steps} steps${applyDv ? " (dv impacts)" : ""}`);

  let current = startId;

  // precompute outgoing edges per node (visible edges only)
  function outgoingEdges(id){
    const edges = cy.edges(`:visible[source = "${id}"]`);
    const arr = [];
    edges.forEach(e => {
      const p = Number(e.data("p") ?? 1);
      arr.push({ e, p });
    });
    return arr;
  }

  for (let i=0;i<steps;i++){
    const outs = outgoingEdges(current);
    if (!outs.length){
      // dead end: teleport to start
      current = startId;
      continue;
    }
    const chosen = weightedChoice(outs, outs.map(x => x.p));
    const e = chosen.e;
    const next = e.data("target");

    // accumulate heat
    heat.node[next] = (heat.node[next] ?? 0) + 1;
    heat.edge[e.id()] = (heat.edge[e.id()] ?? 0) + 1;

    if (applyDv){
      const dv = Number(e.data("dv") ?? 0);
      const st = model.states.find(s => s.id === next);
      if (st){
        st.viability = clamp01(st.viability + dv);
      }
      const n = cy.getElementById(next);
      if (n && n.length) n.data("v", model.states.find(s=>s.id===next)?.viability ?? n.data("v"));
    }

    current = next;
  }

  // sync viability values from model into cy nodes (if dv impacts were applied)
  cy.nodes().forEach(n => {
    const st = model.states.find(s => s.id === n.id());
    if (st) n.data("v", st.viability);
  });

  recomputeAnalysisAndStyle();
}

/* ---------------------------
   Export / import / png
---------------------------- */
function exportJSON(){
  const m = deepClone(model);
  // include positions as layout for reproducibility
  m.layout = { positions: cy.nodes().map(n => ({ id:n.id(), x:n.position("x"), y:n.position("y") })) };
  m.meta = m.meta || {};
  m.meta.start = startId;

  const blob = new Blob([JSON.stringify(m, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "viability-model.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function importJSON(file){
  const reader = new FileReader();
  reader.onload = (ev) => {
    try{
      const parsed = normalizeModel(JSON.parse(ev.target.result));
      pushUndo("import model");

      model = parsed;
      startId = model.meta.start;

      // reset heat on import (usually what you want)
      heat = { node:{}, edge:{} };

      renderModel({preservePositions:false, relayout:false});
      // if imported layout exists, we already applied it in renderModel()
      recomputeAnalysisAndStyle();
    } catch (err){
      alert("Import failed: " + (err?.message ?? err));
    }
  };
  reader.readAsText(file);
}

function exportPNG(){
  const png = cy.png({ full:true, scale:2, bg:"#0f1115" });
  const a = document.createElement("a");
  a.href = png;
  a.download = "viability-graph.png";
  document.body.appendChild(a);
  a.click();
  a.remove();
}

/* ---------------------------
   Buttons + UI wiring
---------------------------- */
document.getElementById("thr").addEventListener("input", (e) => {
  thr = Number(e.target.value);
  document.getElementById("thrLabel").textContent = thr.toFixed(2);
  recomputeAnalysisAndStyle();
});

document.getElementById("pCut").addEventListener("input", (e) => {
  pCut = Number(e.target.value);
  document.getElementById("pCutLabel").textContent = pCut.toFixed(2);
  applyEdgeFilter();
  recomputeAnalysisAndStyle();
});

document.getElementById("amp").addEventListener("input", (e) => {
  document.getElementById("ampLabel").textContent = Number(e.target.value).toFixed(2);
});
document.getElementById("pAmp").addEventListener("input", (e) => {
  document.getElementById("pAmpLabel").textContent = Number(e.target.value).toFixed(2);
});

document.getElementById("showEdgeLabels").addEventListener("change", () => {
  updateEdgeLabelVisibility();
});

document.getElementById("startSelect").addEventListener("change", (e) => {
  pushUndo("change start state");
  startId = e.target.value;
  model.meta.start = startId;
  recomputeAnalysisAndStyle();
});

document.getElementById("probeBtn").addEventListener("click", () => probe());
document.getElementById("walkBtn").addEventListener("click", () => {
  const steps = Math.max(1, Math.min(50000, Number(document.getElementById("walkSteps").value || 250)));
  walk(steps);
});
document.getElementById("relayoutBtn").addEventListener("click", () => runLayout());
document.getElementById("undoBtn").addEventListener("click", () => undo());
document.getElementById("resetBtn").addEventListener("click", () => {
  pushUndo("reset");
  model = deepClone(baseline);
  model = normalizeModel(model);
  heat = { node:{}, edge:{} };
  startId = model.meta.start;
  renderModel({preservePositions:false, relayout:true});
});

document.getElementById("clearHeatBtn").addEventListener("click", () => {
  pushUndo("clear heat");
  heat = { node:{}, edge:{} };
  recomputeAnalysisAndStyle();
});

document.getElementById("focusAttractorsBtn").addEventListener("click", () => {
  const attractors = cy.nodes(".attractor");
  if (!attractors.length) return;
  cy.fit(attractors, 40);
});

document.getElementById("exportBtn").addEventListener("click", () => exportJSON());
document.getElementById("pngBtn").addEventListener("click", () => exportPNG());

document.getElementById("importFile").addEventListener("change", (e) => {
  const file = e.target.files?.[0];
  if (file) importJSON(file);
  e.target.value = "";
});

// keyboard shortcut: ctrl/cmd+z for undo
document.addEventListener("keydown", (e) => {
  const isUndo = (e.key.toLowerCase() === "z") && (e.ctrlKey || e.metaKey);
  if (isUndo){
    e.preventDefault();
    undo();
  }
});

/* ---------------------------
   Cytoscape interactions
---------------------------- */
cy.on("tap", (evt) => {
  if (evt.target === cy) clearSelection();
});
cy.on("tap", "node", (evt) => selectNode(evt.target));
cy.on("tap", "edge", (evt) => selectEdge(evt.target));

/* ---------------------------
   Boot
---------------------------- */
(function boot(){
  model = normalizeModel(model);
  thr = Number(document.getElementById("thr").value);
  pCut = Number(document.getElementById("pCut").value);
  startId = model.meta.start;

  document.getElementById("thrLabel").textContent = thr.toFixed(2);
  document.getElementById("pCutLabel").textContent = pCut.toFixed(2);
  document.getElementById("ampLabel").textContent = Number(document.getElementById("amp").value).toFixed(2);
  document.getElementById("pAmpLabel").textContent = Number(document.getElementById("pAmp").value).toFixed(2);

  updateStartDropdown();
  renderModel({preservePositions:false, relayout:true});
  clearSelection();
})();
</script>
</body>
</html>
