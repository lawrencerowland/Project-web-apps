<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>White Space Analysis</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --ink:#111;
      --muted:#666;
      --hair:#ddd;
      --wash:#f7f7f7;
      --accent:#111;
      --shade: rgba(120,120,120,0.12);
      --shadeStroke: rgba(120,120,120,0.35);
      --pt: rgba(20,20,20,0.85);
      --pt2: rgba(20,20,20,0.55);
      --bg: #fff;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html, body { background: var(--bg); color: var(--ink); font-family: var(--sans); margin:0; padding:0; }
    a { color: inherit; text-decoration: none; border-bottom: 1px solid var(--hair); }
    a:hover { border-bottom-color: var(--ink); }
    .wrap { max-width: 1180px; margin: 28px auto; padding: 0 18px 48px; }
    header { display:flex; gap: 18px; align-items: flex-start; justify-content: space-between; flex-wrap: wrap; }
    h1 { font-size: 20px; font-weight: 650; margin: 0 0 6px; letter-spacing: 0.2px; }
    .lede { max-width: 820px; line-height: 1.35; color: var(--ink); margin: 0; }
    .lede small { color: var(--muted); }
    .pillrow { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    .pill { border: 1px solid var(--hair); border-radius: 999px; padding: 6px 10px; font-size: 12px; color: var(--muted); background: #fff; }
    .grid { display:grid; gap: 18px; margin-top: 18px; }
    .grid.two { grid-template-columns: 1.1fr 0.9fr; }
    @media (max-width: 980px){ .grid.two { grid-template-columns: 1fr; } }

    .card {
      border: 1px solid var(--hair);
      border-radius: 12px;
      background: #fff;
      padding: 14px 14px 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .card h2 { font-size: 13px; font-weight: 700; margin: 0 0 10px; letter-spacing: 0.3px; text-transform: uppercase; color: var(--muted); }
    .card p { margin: 10px 0; color: var(--ink); line-height: 1.4; }
    .card .sub { color: var(--muted); font-size: 13px; margin: 6px 0 0; }

    .dimlist { display:grid; gap: 10px; }
    .dim {
      display:grid; grid-template-columns: 210px 1fr; gap: 12px;
      padding: 10px; border-radius: 10px; border: 1px solid var(--hair);
      background: linear-gradient(#fff, #fff), linear-gradient(90deg, transparent, rgba(0,0,0,0.02));
    }
    @media (max-width: 720px){ .dim { grid-template-columns: 1fr; } }
    .dim .name { font-weight: 650; font-size: 13px; }
    .dim .desc { color: var(--muted); font-size: 13px; line-height: 1.35; }
    .tag { display:inline-block; font-family: var(--mono); font-size: 12px; padding: 2px 6px; border:1px solid var(--hair); border-radius: 8px; background: #fff; color: var(--muted); margin-right: 8px; }

    /* Table */
    table { width:100%; border-collapse: collapse; font-size: 13px; }
    thead th {
      position: sticky; top: 0; background: #fff;
      border-bottom: 1px solid var(--hair);
      padding: 10px 8px;
      text-align: right;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.2px;
      cursor: pointer;
      user-select:none;
      white-space: nowrap;
    }
    thead th:first-child, tbody td:first-child { text-align: left; }
    tbody td { border-bottom: 1px solid #f0f0f0; padding: 10px 8px; text-align: right; }
    tbody tr:hover { background: rgba(0,0,0,0.02); }
    .hint { color: var(--muted); font-size: 12px; margin-top: 8px; }
    .mini { font-size: 12px; color: var(--muted); }

    /* Multiples */
    .controls { display:flex; gap: 12px; align-items: flex-start; justify-content: space-between; flex-wrap: wrap; }
    .checkrow { display:flex; gap: 10px; flex-wrap: wrap; }
    .check {
      border: 1px solid var(--hair);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap: 8px;
      align-items: center;
      cursor:pointer;
      background:#fff;
    }
    .check input { accent-color: #111; }
    .controls .right { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn {
      border: 1px solid var(--hair);
      background: #fff;
      color: var(--muted);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      cursor:pointer;
    }
    .btn:hover{ border-color: #bbb; color: var(--ink); }

    .multiples {
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(3, minmax(220px, 1fr));
      gap: 14px;
    }
    @media (max-width: 980px){ .multiples { grid-template-columns: repeat(2, minmax(220px, 1fr)); } }
    @media (max-width: 640px){ .multiples { grid-template-columns: 1fr; } }

    .plot {
      border: 1px solid var(--hair);
      border-radius: 12px;
      padding: 8px 8px 10px;
      background: #fff;
    }
    .plot .title { font-size: 12px; color: var(--muted); margin: 2px 4px 6px; }
    .plot svg { width: 100%; height: auto; display:block; }
    .axis path, .axis line { stroke: #cfcfcf; shape-rendering: crispEdges; }
    .axis text { fill: #888; font-size: 10px; }
    .label { fill: #444; font-size: 10px; font-weight: 650; }
    .pt { fill: var(--pt); }
    .ptGhost { fill: var(--pt2); }
    .entrant { fill: none; stroke: #111; stroke-width: 1.6px; }
    .entrant2 { fill: #111; opacity: 0.06; }
    .shade { fill: var(--shade); stroke: var(--shadeStroke); stroke-width: 1; }
    .legend { display:flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 8px; }
    .chip { display:flex; gap: 8px; align-items: center; padding: 6px 8px; border:1px solid var(--hair); border-radius: 10px; font-size: 12px; color: var(--muted); }
    .dot { width: 8px; height: 8px; border-radius: 99px; background: #111; }
    .box { width: 10px; height: 10px; border: 1px solid var(--shadeStroke); background: var(--shade); border-radius: 2px; }
    .cross { width: 10px; height: 10px; border: 2px solid #111; transform: rotate(45deg); }

    /* Tooltip */
    .tip {
      position: fixed;
      pointer-events: none;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 10px;
      padding: 10px 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      font-size: 12px;
      color: #111;
      max-width: 290px;
      z-index: 9999;
      display: none;
    }
    .tip .t { font-weight: 750; margin-bottom: 6px; }
    .tip .k { color: var(--muted); }
    .tip .grid { display:grid; gap: 2px; margin-top: 6px; }
    .tip .row { display:flex; justify-content: space-between; gap: 10px; font-family: var(--mono); font-size: 11px; color: #222; }
    .tip code { font-family: var(--mono); font-size: 11px; background: #f6f6f6; padding: 1px 4px; border-radius: 6px; border: 1px solid #eee; }

    /* Sliders */
    .sliders { display:grid; grid-template-columns: 1fr 1fr; gap: 10px 14px; margin-top: 10px; }
    @media (max-width: 900px){ .sliders { grid-template-columns: 1fr; } }
    .slider {
      border: 1px solid var(--hair);
      border-radius: 12px;
      padding: 10px 10px;
      background: #fff;
    }
    .slider .top { display:flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .slider .nm { font-size: 12px; font-weight: 650; color: #333; }
    .slider .val { font-family: var(--mono); font-size: 12px; color: var(--muted); }
    .slider input[type="range"] { width: 100%; margin-top: 8px; }

    /* Text blocks */
    .bullets { margin: 8px 0 0; padding-left: 18px; color: #222; }
    .bullets li { margin: 6px 0; line-height: 1.35; }
    .callout {
      border-left: 3px solid #111;
      padding: 8px 10px;
      margin: 10px 0 0;
      background: linear-gradient(90deg, rgba(0,0,0,0.03), transparent 40%);
      border-radius: 8px;
      color: #222;
      font-size: 13px;
      line-height: 1.35;
    }
    .mono { font-family: var(--mono); }
    .footer { margin-top: 18px; padding-top: 14px; border-top: 1px solid var(--hair); color: var(--muted); font-size: 12px; line-height: 1.35; }
    .coda { margin-top: 12px; font-size: 13px; color: #222; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>White space analysis: capability scorecard → pairwise “white space” map (Energy & Infrastructure digital transformation delivery)</h1>
        <p class="lede">
          This is a <b>hypothesis model</b> (0–10 inputs) that treats each firm as a point in a capability space; the shaded zones are the <b>largest empty “high–high” rectangles</b> per dimension-pair—i.e., places where no incumbent currently sits and a new entrant could plausibly over-index. Adjust any scores/sliders to reflect your priors; the geometry (not the exact numbers) is the point.
          <br/><small>Interpretation: higher scores are “more of the input capability,” not business outcomes; you can swap dimensions, recompute the small multiples, and test an entrant profile against the shaded whitespace.</small>
        </p>
        <div class="pillrow">
          <div class="pill">Tufte-ish: small multiples, thin ink, no chartjunk</div>
          <div class="pill">Whitespace heuristic: “largest empty top-right rectangle”</div>
          <div class="pill">Entrant profile: adjustable; plotted as a rotated square</div>
        </div>
        <div class="pillrow">
          <button class="btn" id="btnPrompt">View creation prompt</button>
        </div>
        <div class="callout" id="promptText" style="display:none;"></div>
      </div>
    </header>

    <div class="grid two">
      <section class="card" id="dimsCard">
        <h2>Orthogonal input dimensions (0–10)</h2>
        <div class="dimlist" id="dimList"></div>
        <p class="sub">
          These six are chosen to be <i>inputs</i> (capability endowments) rather than outputs; they’re also reasonably separable in practice (bench scale ≠ contract innovation ≠ OT depth, etc.).
        </p>
      </section>

      <section class="card" id="tableCard">
        <h2>Numeric scores (click a column to sort)</h2>
        <div style="overflow:auto; max-height: 460px; border-radius: 12px; border:1px solid var(--hair);">
          <table id="scoreTable"></table>
        </div>
        <div class="hint">
          Scores are deliberately coarse (integer-ish) so you can debate and revise them fast. Export: <button class="btn" id="btnCsv">Download CSV</button>
        </div>
      </section>
    </div>

    <section class="card" id="plotsCard">
      <h2>Tufte small multiple: dimension × dimension (auto-selects 4 dims to maximize visible whitespace)</h2>

      <div class="controls">
        <div>
          <div class="mini" style="margin-bottom:8px;">
            Choose <b>exactly 4</b> dimensions (we render the 6 pairwise plots). Default selection is the 4-dimension set with the <b>largest total empty high–high area</b>.
          </div>
          <div class="checkrow" id="dimChecks"></div>
        </div>

        <div class="right">
          <button class="btn" id="btnAutoPick" title="Pick the 4 dimensions with the largest total whitespace across their 6 pairs.">Auto-pick whitespace dims</button>
          <button class="btn" id="btnResetEntrant" title="Reset entrant profile to the suggested whitespace-filling shape.">Reset entrant</button>
        </div>
      </div>

      <div class="legend">
        <div class="chip"><span class="dot"></span> incumbents (5 firms)</div>
        <div class="chip"><span class="box"></span> shaded “best whitespace bet” (largest empty high–high rectangle)</div>
        <div class="chip"><span class="cross"></span> entrant hypothesis</div>
      </div>

      <div class="multiples" id="multiples"></div>

      <div class="grid two" style="margin-top: 14px;">
        <div class="card" style="border: 1px solid var(--hair);">
          <h2>Entrant hypothesis (drag sliders; plots update live)</h2>
          <p class="sub">Think of this as your “offer-as-vector”: where would a new firm sit in capability-space if it tried to occupy the shaded rectangles?</p>
          <div class="sliders" id="sliders"></div>
          <div class="callout" id="entrantReadout"></div>
        </div>

        <div class="card" style="border: 1px solid var(--hair);">
          <h2>Where the whitespace is (computed + interpreted)</h2>
          <div id="whitespaceList"></div>
          <p class="sub">The computed list is purely geometric; the interpretation below is the commercial reading (what you’d have to be “true at” organizationally to sit there).</p>

          <ul class="bullets" id="whitespaceNarrative"></ul>

          <h2 style="margin-top: 14px;">A plausible entrant offering to fill it</h2>
          <div class="callout" id="offering"></div>
        </div>
      </div>

      <div class="footer">
        Notes: (1) “Largest empty top-right rectangle” implicitly encodes a strategy: compete on <i>capability maxima</i> rather than cost. (2) If you care about cost leadership or mid-market crowding, swap to a different emptiness criterion (e.g., densest void in the middle). (3) The incumbents are treated as points; in reality each is a distribution across sub-practices.
        <div class="coda">If you want to get sharper, try adding a seventh dimension for “<span class="mono">operator-embedded delivery</span>” (ex-plant / ex-control-room talent + safety case fluency) and see how violently it re-partitions the empty space.</div>
      </div>
    </section>
  </div>

  <div class="tip" id="tip"></div>

  <script>
    // -----------------------------
    // Data model (0–10, hypothesis)
    // -----------------------------
    const dims = [
      {
        key: "ot",
        short: "OT depth",
        name: "OT/Engineering & Asset Lifecycle Depth",
        desc: "Ability to work credibly across the hard edge: OT systems, engineering disciplines, reliability/maintenance, asset lifecycle, safety-critical constraints, and the political economy of the plant / network."
      },
      {
        key: "gov",
        short: "Governance",
        name: "Programme Governance & Capital Controls Rigor",
        desc: "Capital programme assurance: cost/schedule control, risk quantification, stage-gate discipline, commercial controls, claims-ready documentation, and governance operating model design."
      },
      {
        key: "ip",
        short: "Productized IP",
        name: "Industrialized / Productized IP",
        desc: "Repeatable, tool-supported delivery (templates, reference architectures, playbooks-as-code, accelerators, data models) that reduces bespoke work while staying domain-specific (not generic frameworks)."
      },
      {
        key: "ai",
        short: "Industrial Data/AI",
        name: "Data/AI & Cloud Engineering for Industrial Data",
        desc: "Industrial data platforms (OT/IT integration), cloud/platform engineering, MLOps for asset analytics, and the practicalities of latency, security zones, historian data, and edge constraints."
      },
      {
        key: "scale",
        short: "Scale",
        name: "Delivery Scale & Multi-country Mobilization",
        desc: "Bench depth, multi-geo staffing, 24/7 support models, sourcing footprint, and the capacity to run multiple complex programmes simultaneously without thin governance."
      },
      {
        key: "comm",
        short: "Commercial innovation",
        name: "Commercial / Contract Innovation",
        desc: "Outcome-based pricing, gainshare structures, modular “menu” packaging, warranty-like commitments, and contracting that aligns incentives beyond time-and-materials."
      }
    ];

    const firms = [
      {
        firm: "Deloitte",
        scores: { ot: 6, gov: 7, ip: 5, ai: 7, scale: 8, comm: 5 }
      },
      {
        firm: "Accenture",
        scores: { ot: 6, gov: 6, ip: 6, ai: 9, scale: 9, comm: 6 }
      },
      {
        firm: "Sopra Steria",
        scores: { ot: 5, gov: 6, ip: 5, ai: 6, scale: 6, comm: 5 }
      },
      {
        firm: "MiGSO Pcubed",
        scores: { ot: 4, gov: 9, ip: 3, ai: 3, scale: 5, comm: 4 }
      },
      {
        firm: "CPC Project Services",
        scores: { ot: 5, gov: 8, ip: 2, ai: 3, scale: 4, comm: 4 }
      }
    ];

    // Default entrant hypothesis: aimed at the computed whitespace (can be edited via sliders)
    let entrant = { ot: 9, gov: 8, ip: 9, ai: 8, scale: 5, comm: 8 };

    const creationPrompt = `Deloitte, Accenture, Sopra Steria, MiGSO Pcubed and CPC Project services lead in the delivery of digital transformation programmes in asset and capital intensive sectors such as Energy and Infrastructure. "Break out the capabilities of these five across a number of meaningful orthogonal dimensions, say five or six. Where the dimensions are input variables rather than output variables. "Give me a table of numeric scores of the five against the dimensions. "I want to see where the white space is, across these dimensions. I need to see this within a Tufte small multiple, where the plots are each of one dimension against another dimension ( and not against the five companies). Select the most important dimensions for those plots for the small multiple, such that we can see a large are of white space, where a new entrant could occupy that white space."`;

    // -----------------------------
    // Helpers
    // -----------------------------
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const fmt = (x) => (Math.round(x * 100) / 100).toFixed(2);

    function dimByKey(k){ return dims.find(d => d.key === k); }

    function download(filename, text) {
      const el = document.createElement("a");
      el.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
      el.setAttribute("download", filename);
      el.style.display = "none";
      document.body.appendChild(el);
      el.click();
      document.body.removeChild(el);
    }

    // "Largest empty top-right rectangle" for a given (xDim, yDim):
    // Find x0,y0 maximizing area (10-x0)*(10-y0) such that no firm has x>=x0 and y>=y0.
    function largestEmptyTopRight(xKey, yKey) {
      const xs = firms.map(f => f.scores[xKey]);
      const ys = firms.map(f => f.scores[yKey]);

      // Candidate thresholds just above observed points (+epsilon) plus 0.
      const eps = 0.01;
      const candX = Array.from(new Set([0, ...xs.map(v => clamp(v + eps, 0, 10))])).sort((a,b)=>a-b);
      const candY = Array.from(new Set([0, ...ys.map(v => clamp(v + eps, 0, 10))])).sort((a,b)=>a-b);

      let best = { x0: 10, y0: 10, area: 0 };

      for (const x0 of candX) {
        for (const y0 of candY) {
          const anyIn = firms.some(f => f.scores[xKey] >= x0 && f.scores[yKey] >= y0);
          if (!anyIn) {
            const area = (10 - x0) * (10 - y0);
            if (area > best.area + 1e-9) best = { x0, y0, area };
          }
        }
      }
      return best; // {x0,y0,area}
    }

    // Choose 4 dims maximizing sum of whitespace areas across their 6 pairs
    function autoPickDims() {
      const keys = dims.map(d => d.key);
      const combos = [];

      for (let a=0; a<keys.length; a++){
        for (let b=a+1; b<keys.length; b++){
          for (let c=b+1; c<keys.length; c++){
            for (let d=c+1; d<keys.length; d++){
              const pick = [keys[a], keys[b], keys[c], keys[d]];
              const pairs = [];
              let sumArea = 0;

              for (let i=0; i<pick.length; i++){
                for (let j=i+1; j<pick.length; j++){
                  const x = pick[i], y = pick[j];
                  const w = largestEmptyTopRight(x, y);
                  sumArea += w.area;
                  pairs.push({ x, y, ...w });
                }
              }
              combos.push({ pick, sumArea, pairs });
            }
          }
        }
      }
      combos.sort((p,q) => q.sumArea - p.sumArea);
      return combos[0];
    }

    // -----------------------------
    // Render: dimension list
    // -----------------------------
    function renderDimList(){
      const host = d3.select("#dimList").html("");
      const items = host.selectAll("div.dim")
        .data(dims)
        .enter()
        .append("div")
        .attr("class","dim");

      items.append("div")
        .html(d => `<div class="name"><span class="tag">${d.short}</span>${d.name}</div>`);

      items.append("div")
        .attr("class","desc")
        .text(d => d.desc);
    }

    // -----------------------------
    // Render: score table (sortable)
    // -----------------------------
    let sortState = { key: "firm", dir: 1 };

    function renderTable(){
      const table = d3.select("#scoreTable").html("");
      const thead = table.append("thead");
      const tbody = table.append("tbody");

      const cols = [
        { key: "firm", label: "Firm", align: "left" },
        ...dims.map(d => ({ key: d.key, label: d.short, align: "right" }))
      ];

      const headRow = thead.append("tr");
      headRow.selectAll("th")
        .data(cols)
        .enter()
        .append("th")
        .style("text-align", d => d.align)
        .text(d => d.label)
        .on("click", (e, d) => {
          if (sortState.key === d.key) sortState.dir *= -1;
          else { sortState.key = d.key; sortState.dir = (d.key === "firm") ? 1 : -1; }
          renderTable();
        });

      const rowsData = firms.map(f => ({
        firm: f.firm,
        ...Object.fromEntries(dims.map(d => [d.key, f.scores[d.key]]))
      }));

      const sorted = rowsData.slice().sort((a,b) => {
        const k = sortState.key;
        const dir = sortState.dir;
        if (k === "firm") return dir * d3.ascending(a.firm, b.firm);
        return dir * (a[k] - b[k]);
      });

      const rows = tbody.selectAll("tr")
        .data(sorted)
        .enter()
        .append("tr");

      rows.selectAll("td")
        .data(r => cols.map(c => ({ col: c, val: r[c.key] })))
        .enter()
        .append("td")
        .style("text-align", d => d.col.align)
        .text(d => d.col.key === "firm" ? d.val : d.val);
    }

    function exportCsv(){
      const header = ["Firm", ...dims.map(d=>d.name)];
      const lines = [header.join(",")];
      for (const f of firms){
        const row = [f.firm, ...dims.map(d => f.scores[d.key])];
        lines.push(row.join(","));
      }
      download("capability_scores.csv", lines.join("\n"));
    }

    // -----------------------------
    // Render: dimension checkboxes (pick exactly 4)
    // -----------------------------
    let selected = autoPickDims().pick.slice();

    function renderChecks(){
      const host = d3.select("#dimChecks").html("");
      const cards = host.selectAll("label.check")
        .data(dims)
        .enter()
        .append("label")
        .attr("class","check");

      cards.append("input")
        .attr("type","checkbox")
        .attr("checked", d => selected.includes(d.key) ? true : null)
        .on("change", (e, d) => {
          const checked = e.target.checked;
          if (checked) {
            if (selected.length >= 4){
              // prevent >4
              e.target.checked = false;
              return;
            }
            selected.push(d.key);
          } else {
            selected = selected.filter(k => k !== d.key);
          }

          // enforce exactly 4 to plot; if not, clear plots
          renderChecks();
          renderMultiples();
          renderWhitespaceText();
          renderEntrantReadout();
        });

      cards.append("div")
        .html(d => `<div style="font-weight:650; color:#333">${d.short}</div><div class="mini" style="margin-top:2px">${d.name}</div>`);
    }

    // -----------------------------
    // Render: entrant sliders
    // -----------------------------
    function renderSliders(){
      const host = d3.select("#sliders").html("");
      const s = host.selectAll("div.slider")
        .data(dims)
        .enter()
        .append("div")
        .attr("class","slider");

      s.append("div").attr("class","top")
        .html(d => `<div class="nm">${d.short}</div><div class="val"><span id="val_${d.key}">${entrant[d.key]}</span>/10</div>`);

      s.append("input")
        .attr("type","range")
        .attr("min", 0)
        .attr("max", 10)
        .attr("step", 0.1)
        .attr("value", d => entrant[d.key])
        .on("input", (e, d) => {
          entrant[d.key] = +e.target.value;
          d3.select(`#val_${d.key}`).text(fmt(entrant[d.key]));
          renderMultiples();         // update plots
          renderWhitespaceText();    // update computed list & narrative
          renderEntrantReadout();
        });
    }

    function resetEntrant(){
      entrant = { ot: 9, gov: 8, ip: 9, ai: 8, scale: 5, comm: 8 };
      renderSliders();
      renderMultiples();
      renderWhitespaceText();
      renderEntrantReadout();
    }

    // -----------------------------
    // Tooltips
    // -----------------------------
    const tip = d3.select("#tip");
    function showTip(html, x, y){
      tip.style("display","block")
        .style("left", (x + 12) + "px")
        .style("top", (y + 12) + "px")
        .html(html);
    }
    function hideTip(){ tip.style("display","none"); }

    // -----------------------------
    // Render: small multiples (6 pair plots for 4 dims)
    // -----------------------------
    function renderMultiples(){
      const host = d3.select("#multiples").html("");

      if (selected.length !== 4){
        host.append("div")
          .attr("class","mini")
          .style("color","var(--muted)")
          .text("Select exactly 4 dimensions to render the 6 small multiples.");
        return;
      }

      // create the 6 unique pairs
      const pairs = [];
      for (let i=0; i<selected.length; i++){
        for (let j=i+1; j<selected.length; j++){
          pairs.push({ xKey: selected[i], yKey: selected[j] });
        }
      }

      const cells = host.selectAll("div.plot")
        .data(pairs)
        .enter()
        .append("div")
        .attr("class","plot");

      cells.append("div")
        .attr("class","title")
        .text(p => `${dimByKey(p.yKey).short} vs ${dimByKey(p.xKey).short}`);

      // plot config
      const W = 320, H = 250;
      const margin = { top: 18, right: 16, bottom: 28, left: 34 };
      const iw = W - margin.left - margin.right;
      const ih = H - margin.top - margin.bottom;

      const x = d3.scaleLinear().domain([0,10]).range([0, iw]);
      const y = d3.scaleLinear().domain([0,10]).range([ih, 0]);

      cells.each(function(p){
        const svg = d3.select(this).append("svg")
          .attr("viewBox", `0 0 ${W} ${H}`)
          .attr("role", "img")
          .attr("aria-label", `${p.xKey} by ${p.yKey} scatterplot`);

        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        // whitespace rectangle (largest empty high-high)
        const ws = largestEmptyTopRight(p.xKey, p.yKey);
        g.append("rect")
          .attr("class","shade")
          .attr("x", x(ws.x0))
          .attr("y", y(10))
          .attr("width", x(10) - x(ws.x0))
          .attr("height", y(ws.y0) - y(10));

        // faint gridlines at 5 (Tufte-ish: minimal)
        [5].forEach(t => {
          g.append("line").attr("x1", x(0)).attr("x2", x(10)).attr("y1", y(t)).attr("y2", y(t))
            .attr("stroke", "#efefef").attr("stroke-width", 1);
          g.append("line").attr("x1", x(t)).attr("x2", x(t)).attr("y1", y(0)).attr("y2", y(10))
            .attr("stroke", "#efefef").attr("stroke-width", 1);
        });

        // axes
        g.append("g")
          .attr("class","axis")
          .attr("transform", `translate(0,${ih})`)
          .call(d3.axisBottom(x).tickValues([0,5,10]).tickSize(3));

        g.append("g")
          .attr("class","axis")
          .call(d3.axisLeft(y).tickValues([0,5,10]).tickSize(3));

        // axis labels (small, inside)
        g.append("text").attr("class","label")
          .attr("x", 0).attr("y", -6)
          .text(dimByKey(p.yKey).short);

        g.append("text").attr("class","label")
          .attr("x", iw).attr("y", ih + 24).attr("text-anchor","end")
          .text(dimByKey(p.xKey).short);

        // points
        g.selectAll("circle.pt")
          .data(firms)
          .enter()
          .append("circle")
          .attr("class","pt")
          .attr("r", 3.4)
          .attr("cx", d => x(d.scores[p.xKey]))
          .attr("cy", d => y(d.scores[p.yKey]))
          .on("mousemove", (e, d) => {
            const lines = dims.map(dd => `<div class="row"><span>${dd.short}</span><span>${d.scores[dd.key]}</span></div>`).join("");
            showTip(
              `<div class="t">${d.firm}</div>
               <div><span class="k">${dimByKey(p.xKey).short}</span>: <code>${d.scores[p.xKey]}</code>
                    &nbsp;&nbsp;<span class="k">${dimByKey(p.yKey).short}</span>: <code>${d.scores[p.yKey]}</code></div>
               <div class="grid">${lines}</div>`,
              e.clientX, e.clientY
            );
          })
          .on("mouseleave", hideTip);

        // entrant marker (rotated square)
        const ex = x(entrant[p.xKey]);
        const ey = y(entrant[p.yKey]);
        g.append("rect")
          .attr("x", ex - 5.2).attr("y", ey - 5.2)
          .attr("width", 10.4).attr("height", 10.4)
          .attr("transform", `rotate(45, ${ex}, ${ey})`)
          .attr("class","entrant2");

        g.append("rect")
          .attr("x", ex - 5.2).attr("y", ey - 5.2)
          .attr("width", 10.4).attr("height", 10.4)
          .attr("transform", `rotate(45, ${ex}, ${ey})`)
          .attr("class","entrant")
          .on("mousemove", (e) => {
            showTip(
              `<div class="t">Entrant hypothesis</div>
               <div><span class="k">${dimByKey(p.xKey).short}</span>: <code>${fmt(entrant[p.xKey])}</code>
                    &nbsp;&nbsp;<span class="k">${dimByKey(p.yKey).short}</span>: <code>${fmt(entrant[p.yKey])}</code></div>
               <div class="sub">Shaded region is empty among incumbents; the entrant can be “placed” to test fit.</div>`,
              e.clientX, e.clientY
            );
          })
          .on("mouseleave", hideTip);

        // annotate whitespace thresholds lightly
        g.append("text")
          .attr("x", x(ws.x0) + 4)
          .attr("y", y(10) + 12)
          .attr("font-size", 10)
          .attr("fill", "#666")
          .text(`empty if ≥${fmt(ws.x0)} & ≥${fmt(ws.y0)}`);

        // subtle frame
        g.append("rect")
          .attr("x", 0).attr("y", 0).attr("width", iw).attr("height", ih)
          .attr("fill","none")
          .attr("stroke","#f0f0f0");
      });
    }

    // -----------------------------
    // Render: whitespace list + narrative + offering
    // -----------------------------
    function renderEntrantReadout(){
      const card = d3.select("#entrantReadout");
      // Evaluate "hits" against shaded rectangles for currently selected pairs
      if (selected.length !== 4){
        card.html(`Select 4 dimensions to evaluate the entrant against the shaded whitespace rectangles.`);
        return;
      }

      const pairs = [];
      for (let i=0; i<selected.length; i++){
        for (let j=i+1; j<selected.length; j++){
          const xKey = selected[i], yKey = selected[j];
          const ws = largestEmptyTopRight(xKey, yKey);
          const inShade = (entrant[xKey] >= ws.x0 && entrant[yKey] >= ws.y0);
          pairs.push({ xKey, yKey, ws, inShade });
        }
      }

      const hits = pairs.filter(p => p.inShade).length;
      const total = pairs.length;

      const topLine = `<b>Entrant fit vs shaded whitespace:</b> ${hits}/${total} plots place the entrant inside the empty “high–high” region.`;
      const detail = pairs.map(p => {
        const xS = dimByKey(p.xKey).short, yS = dimByKey(p.yKey).short;
        const mark = p.inShade ? "✓" : "·";
        return `<div class="mini mono">${mark} ${yS} vs ${xS}: needs ≥${fmt(p.ws.x0)} and ≥${fmt(p.ws.y0)}</div>`;
      }).join("");

      card.html(`${topLine}<div style="margin-top:8px">${detail}</div>`);
    }

    function renderWhitespaceText(){
      const host = d3.select("#whitespaceList").html("");

      // Compute best whitespace rectangles across ALL dimension pairs
      const pairs = [];
      for (let i=0; i<dims.length; i++){
        for (let j=i+1; j<dims.length; j++){
          const xKey = dims[i].key, yKey = dims[j].key;
          const ws = largestEmptyTopRight(xKey, yKey);
          pairs.push({ xKey, yKey, ...ws });
        }
      }
      pairs.sort((a,b) => b.area - a.area);

      const top = pairs.slice(0, 5);
      const rows = top.map(p => {
        const x = dimByKey(p.xKey).short;
        const y = dimByKey(p.yKey).short;
        return `<li><span class="mono">${y} × ${x}</span> → empty for <span class="mono">x≥${fmt(p.x0)}, y≥${fmt(p.y0)}</span> (area ≈ <span class="mono">${fmt(p.area)}</span>)</li>`;
      }).join("");

      host.append("div")
        .html(`<div class="mini">Top whitespace bets across all 15 pairs (largest empty “high–high” rectangles):</div>
               <ul class="bullets">${rows}</ul>`);

      // Narrative interpretation (stable, but keyed to our definitions)
      const narr = d3.select("#whitespaceNarrative").html("");

      const bullets = [
        `<b>“Hard-edge + productization” is thinly occupied:</b> the incumbents split between (i) big-platform delivery and (ii) programme-assurance boutiques; the <i>combination</i> of deep OT/engineering fluency with genuinely productized industrial delivery assets remains a rare point in the space.`,
        `<b>Governance is abundant; governance-with-code is not:</b> MiGSO/CPC sit high on controls, but low on industrialized tooling; the whitespace is an assurance model where cost/schedule control is instrumented (telemetry, probabilistic forecasting, contract analytics) rather than a reporting cadence.`,
        `<b>Commercial innovation is the missing keystone:</b> outcome-based contracts are discussed widely, but sustained “gainshare + warranty-like” commitments that couple OT reality with data/AI instrumentation are uncommon—mostly because few players can underwrite the operational risk with credible measurement.`,
        `<b>Scale is orthogonal to credibility:</b> high scale exists, but scale <i>with</i> operator-embedded delivery and safety-case literacy is scarce; the whitespace favors a firm that stays mid-scale but unusually “thick” in industrial craft.`,
      ];

      narr.selectAll("li")
        .data(bullets)
        .enter()
        .append("li")
        .html(d => d);

      // Offering: the entrant story that sits in the whitespace
      const offering = `
        <b>“Controls + Twin + Contract” Industrial Transformation Studio</b><br/>
        A new entrant could package a repeatable, software-like delivery system for capital programmes and brownfield digitization: (1) an <span class="mono">OT/IT data spine</span> (historians + edge + governance), (2) a <span class="mono">digital twin / critical-asset model</span> used to drive prioritized work (reliability, energy efficiency, integrity), and (3) <span class="mono">instrumented programme controls</span> (schedule-risk simulation, claims-ready traceability, scope/change telemetry). Commercially, sell it as modular “capability units” with <span class="mono">gainshare + measurement warranties</span> (you’re paid on verified improvements and the variance you remove), while retaining boutique-grade assurance rigor—i.e., you occupy the shaded rectangles by being simultaneously <i>craft-deep</i>, <i>tool-rich</i>, and <i>contract-innovative</i>.
      `;
      d3.select("#offering").html(offering);

      // If selected dims exist, also show why they were auto-picked (sum whitespace)
      const best = autoPickDims();
      const pickedNames = best.pick.map(k => dimByKey(k).short).join(", ");
      host.append("div")
        .attr("class","callout")
        .style("margin-top","10px")
        .html(`<b>Auto-picked 4D set:</b> <span class="mono">${pickedNames}</span> (maximizes total visible whitespace across its 6 pairs; total area ≈ <span class="mono">${fmt(best.sumArea)}</span>).`);
    }

    function togglePrompt(){
      const promptEl = document.querySelector("#promptText");
      if (promptEl.style.display === "none"){
        promptEl.style.display = "block";
        promptEl.textContent = `Prompt used: ${creationPrompt}`;
      } else {
        promptEl.style.display = "none";
      }
    }

    // -----------------------------
    // Wire buttons
    // -----------------------------
    d3.select("#btnCsv").on("click", exportCsv);

    d3.select("#btnAutoPick").on("click", () => {
      selected = autoPickDims().pick.slice();
      renderChecks();
      renderMultiples();
      renderWhitespaceText();
      renderEntrantReadout();
    });

    d3.select("#btnResetEntrant").on("click", () => resetEntrant());
    d3.select("#btnPrompt").on("click", togglePrompt);

    // -----------------------------
    // Initial render
    // -----------------------------
    renderDimList();
    renderTable();
    renderChecks();
    renderSliders();
    renderMultiples();
    renderWhitespaceText();
    renderEntrantReadout();
  </script>
</body>
</html>
